<!--
- [INPUT]: 依赖 二分查找、二叉树等算法基础概念
- [OUTPUT]: 本文档提供 O(log n) 时间复杂度的多层次直觉理解
- [POS]: 算法题模块的基础认知文档，为二分查找等 O(log n) 算法提供理论支撑
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 理解 O(log n)

> O(log n) 是算法里最优美的复杂度之一。

## 现象层：O(log n) 长什么样？

| n（数据量） | log₂(n)（操作次数） |
| ----------- | ------------------- |
| 8           | 3                   |
| 16          | 4                   |
| 1,024       | 10                  |
| 1,000,000   | ~20                 |
| 10亿        | ~30                 |

**10亿条数据，只需要约30次操作就能找到目标。** 这就是 O(log n) 的威力。

## 本质层：为什么是 log？

**O(log n) 的本质就是：每一步操作都把问题规模砍掉一半。**

二分查找是最经典的例子：

```javascript
// 1024 个元素的有序数组，找目标值
// 第 1 次：砍半 → 剩 512
// 第 2 次：砍半 → 剩 256
// 第 3 次：砍半 → 剩 128
// ...
// 第 10 次：砍半 → 剩 1 → 找到了！
```

数学上就是在问：**n 要除以多少次 2 才能变成 1？** 答案就是 log₂(n)。

```
n ÷ 2 ÷ 2 ÷ 2 ··· = 1  ⟹  次数 = log₂(n)
```

## 哲学层：O(log n) 的直觉隐喻

### 🎯 隐喻一：猜数字游戏

我心里想一个 1~100 的数，你来猜：

- **笨方法 O(n)**：从1猜到100，最多猜100次
- **聪明方法 O(log n)**：每次猜中间值，我告诉你"大了"或"小了"
  - 猜50 → "大了" → 范围缩到 1~49
  - 猜25 → "小了" → 范围缩到 26~49
  - 猜37 → ...最多 **7次** 必中！

### 🎯 隐喻二：翻字典

查"Python"这个词，你不会从第一页翻起。你会：

1. 翻到字典中间 → M，P 在后面 → 后半本
2. 翻到后半本中间 → S，P 在前面 → 前半段
3. 继续缩小...几次就找到了

**这就是人类天生就懂的 O(log n) 思维。**

### 🎯 隐喻三：树的高度

一棵**平衡**二叉树，n 个节点的树高度是 log₂(n)：

```
         8 个节点的树高 = 3 = log₂(8)
            ○             ← 第 1 层
          /   \
         ○     ○          ← 第 2 层
        / \   / \
       ○   ○ ○   ○        ← 第 3 层
      /
     ○
```

从根到叶子最多走 **log n** 步。二叉搜索树查找、堆操作，都是这个道理。

## 核心认知

> **看到 O(log n)，脑子里只需要浮现一个动作：对半砍。**
>
> - **二分查找**：每次砍掉一半搜索空间
> - **平衡二叉树**：每次往下走一层，排除一半节点
> - **分治算法**（如归并排序的层数）：每层把问题分成两半
>
> 凡是"每一步都能丢掉一半数据"的算法，复杂度就是 O(log n)。

## 对比感受增长速度

```
O(1)      →  ■
O(log n)  →  ■■■                          ← 增长极慢，几乎是常数
O(n)      →  ■■■■■■■■■■■■■■■■■■■■
O(n log n)→  ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
O(n²)     →  ■■■■■■■■■■■■■■■■■■■■ × 20行...
```

O(log n) 是仅次于 O(1) 的最高效复杂度。**数据量翻倍，操作次数只加 1。** 这就是它的终极精髓。
