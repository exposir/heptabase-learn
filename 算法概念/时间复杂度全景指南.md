<!--
- [INPUT]: 依赖算法基础概念与常见数据结构知识
- [OUTPUT]: 本文档提供所有常见时间复杂度的直觉理解与对比分析
- [POS]: 算法概念模块的核心认知文档，建立复杂度分析的全局视野
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 时间复杂度全景指南

> 复杂度不是数学游戏，而是对"问题规模增长时，代价如何膨胀"的直觉判断。

## 全局速览

| 复杂度     | 名称     | n=10  | n=100        | n=1000  | n=100万  | 一句话理解             |
| ---------- | -------- | ----- | ------------ | ------- | -------- | ---------------------- |
| O(1)       | 常数     | 1     | 1            | 1       | 1        | 无论多少数据，一步到位 |
| O(log n)   | 对数     | 3     | 7            | 10      | 20       | 每次砍掉一半           |
| O(n)       | 线性     | 10    | 100          | 1000    | 100万    | 看一遍全部数据         |
| O(n log n) | 线性对数 | 33    | 664          | 9966    | 2000万   | 看一遍，每次顺便砍半   |
| O(n²)      | 平方     | 100   | 1万          | 100万   | 1万亿 💀 | 每个人跟每个人握手     |
| O(n³)      | 立方     | 1000  | 100万        | 10亿 💀 | ∞        | 三层嵌套循环           |
| O(2ⁿ)      | 指数     | 1024  | 1.27×10³⁰ 💀 | ∞       | ∞        | 每加一个元素，翻倍     |
| O(n!)      | 阶乘     | 362万 | ∞            | ∞       | ∞        | 所有排列组合都试一遍   |

---

## O(1) — 常数时间

### 直觉

**不管书架上有10本书还是100万本书，拿第3本永远只需要伸一次手。**

### 本质

操作次数与数据量 n **完全无关**。可能是1次操作，也可能是100次，但关键是它是一个**固定的数**。

### 典型场景

```javascript
// 数组按索引访问 — O(1)
const val = arr[5];

// 哈希表查找 — O(1) 平均
const val = map.get("key");

// 栈的 push/pop — O(1)
stack.push(1);
stack.pop();

// 数学公式直接计算 — O(1)
// 求 1+2+...+n，不用循环
const sum = (n * (n + 1)) / 2;
```

### 核心认知

> O(1) 是**理想国**。能用公式代替循环、能用哈希表代替搜索，就是把 O(n) 压缩成 O(1) 的艺术。

---

## O(log n) — 对数时间

### 直觉

**每一步都把问题砍掉一半，所以再大的问题也几步就解决。**

10亿条数据 → 约30次操作。数据量翻倍，操作次数只加 1。

### 本质

反复**除以某个常数**（通常是2），直到剩下1：

```
n ÷ 2 ÷ 2 ÷ 2 ··· = 1  ⟹  次数 = log₂(n)
```

### 典型场景

```javascript
// 二分查找 — O(log n)
function binarySearch(arr, target) {
  let left = 0,
    right = arr.length - 1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}

// 平衡二叉搜索树查找 — O(log n)
// 堆的插入/删除 — O(log n)
// 快速幂 — O(log n)
```

### 核心认知

> 看到 **"有序"** 或 **"每次排除一半"**，就是 O(log n)。它是效率的黄金标准。

---

## O(n) — 线性时间

### 直觉

**要找全班最高的人，你必须看一遍每个人。少看一个都可能漏掉答案。**

### 本质

每个元素**恰好处理一次**（或常数次）。操作次数与数据量成正比。

### 典型场景

```javascript
// 遍历数组 — O(n)
let max = arr[0];
for (let i = 1; i < arr.length; i++) {
  if (arr[i] > max) max = arr[i];
}

// 线性搜索 — O(n)
const index = arr.indexOf(target);

// 计数、求和 — O(n)
const sum = arr.reduce((a, b) => a + b, 0);

// 双指针技巧 — O(n)
// 虽然两个指针，但总共走了 n 步
```

### 核心认知

> O(n) 是"**至少看一遍**"的代价。很多问题的下界就是 O(n)——你不看完数据，怎么知道答案？优化的目标往往是从 O(n²) 降到 O(n)。

---

## O(n log n) — 线性对数时间

### 直觉

**把全校学生排队：先分成小组排好，再组与组合并。分 log n 层，每层处理 n 个人。**

### 本质

O(n log n) = **做 log n 轮，每轮处理 n 个元素**。或者反过来理解：对 n 个元素，每个元素经历 log n 次操作。

### 典型场景

```javascript
// 归并排序 — O(n log n)
// 分成 log n 层，每层合并 n 个元素
[8, 3, 5, 1, 4, 2, 7, 6][(8, 3, 5, 1)][(4, 2, 7, 6)][(8, 3)][(5, 1)][(4, 2)][ // 第 1 层：分
  (7, 6)
][(3, 8)][(1, 5)][(2, 4)][(6, 7)][(1, 3, 5, 8)][(2, 4, 6, 7)][ // 第 2 层：分 // 第 2 层：合并（n次比较） // 第 1 层：合并（n次比较）
  (1, 2, 3, 4, 5, 6, 7, 8)
]; // 结果
// 共 log₂(8) = 3 层，每层 8 次操作 → 8 × 3 = 24

// 快速排序（平均）— O(n log n)
// 堆排序 — O(n log n)
// JavaScript 的 Array.sort() — O(n log n)
```

### 核心认知

> O(n log n) 是**基于比较的排序的理论下界**——不可能更快了。看到排序相关的问题，心里默认就是 O(n log n)。

---

## O(n²) — 平方时间

### 直觉

**全班30个人，每个人跟每个人握一次手。30 × 30 = 900 次握手。**

人数翻倍 → 握手次数变为4倍。

### 本质

**双重循环**——对每个元素，都要扫描一遍其他所有元素。

### 典型场景

```javascript
// 冒泡排序 — O(n²)
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n - i - 1; j++) {
    if (arr[j] > arr[j + 1]) {
      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
    }
  }
}

// 暴力两数之和 — O(n²)
for (let i = 0; i < n; i++) {
  for (let j = i + 1; j < n; j++) {
    if (arr[i] + arr[j] === target) return [i, j];
  }
}

// 所有子串枚举 — O(n²)
```

### 核心认知

> 看到**两层嵌套循环**，警报响起：O(n²)！面试中遇到 O(n²) 的暴力解，面试官一定会问"能优化吗？"。常见优化路径：
>
> - 用哈希表降到 O(n)
> - 先排序 + 双指针降到 O(n log n)
> - 用单调栈/滑动窗口降到 O(n)

---

## O(n³) — 立方时间

### 直觉

**三层嵌套循环。n=100 就是 100万次操作，n=1000 就是 10亿次——已经很危险了。**

### 典型场景

```javascript
// 矩阵乘法（朴素）— O(n³)
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    for (let k = 0; k < n; k++) {
      C[i][j] += A[i][k] * B[k][j];
    }
  }
}

// Floyd 最短路算法 — O(n³)
for (let k = 0; k < n; k++) {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
    }
  }
}
```

### 核心认知

> 三层循环是**实际可用的极限边界**。再往上就进入了几乎不可用的领域。

---

## O(2ⁿ) — 指数时间

### 直觉

**每加一个元素，工作量翻倍。** 像细胞分裂：1→2→4→8→16→...

n=20 就是 100万，n=30 就是 10亿，n=40 就是万亿。增长速度恐怖。

### 本质

问题的每个元素都有**两种选择**（选或不选、左或右），穷举所有组合。

### 典型场景

```javascript
// 斐波那契（朴素递归）— O(2ⁿ)
function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2); // 每次分裂成两个子问题
}

// 子集枚举 — O(2ⁿ)
// [1,2,3] 的所有子集：[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]
// 每个元素选或不选 → 2×2×2 = 2³ = 8 个子集

// 暴力回溯（无剪枝） — O(2ⁿ)
```

### 核心认知

> O(2ⁿ) 是**暴力穷举的信号**。看到它你要想：能不能用**动态规划（DP）**把它降下来？
>
> - 斐波那契：O(2ⁿ) → DP → O(n)
> - 背包问题：O(2ⁿ) → DP → O(n×W)
>
> **DP 的本质就是用空间换时间，消灭指数级的重复计算。**

---

## O(n!) — 阶乘时间

### 直觉

**全排列问题：n 个人排队，有多少种排法？**

- 3人 → 6种
- 5人 → 120种
- 10人 → 362万种
- 13人 → 60亿种 💀
- 20人 → 2.4×10¹⁸ 💀💀💀

### 典型场景

```javascript
// 全排列 — O(n!)
function permute(arr) {
  if (arr.length <= 1) return [arr];
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
    for (const perm of permute(rest)) {
      result.push([arr[i], ...perm]);
    }
  }
  return result;
}

// 旅行商问题（暴力）— O(n!)
// 尝试所有城市访问顺序，找最短路径
```

### 核心认知

> O(n!) 是**复杂度的地狱**。n 超过 15 就基本不可用。遇到 O(n!) 问题，要么用 DP/剪枝优化，要么接受这是 NP-hard 问题，寻找近似解。

---

## 增长速度对比（n=16）

```
O(1)       →  1
O(log n)   →  4
O(n)       →  16
O(n log n) →  64
O(n²)      →  256
O(n³)      →  4,096
O(2ⁿ)      →  65,536
O(n!)      →  20,922,789,888,000  （约 20 万亿）
```

可视化增长曲线：

```
操作次数 ↑
         │                                          ╱ O(n!)
         │                                        ╱
         │                                      ╱
         │                                   ╱   ╱ O(2ⁿ)
         │                                ╱   ╱
         │                            ╱    ╱
         │                        ╱     ╱
         │                   ╱       ╱        ╱ O(n²)
         │              ╱         ╱       ╱
         │         ╱           ╱      ╱
         │     ╱            ╱     ╱          ╱ O(n log n)
         │  ╱            ╱    ╱          ╱
         │╱           ╱   ╱         ╱        ╱ O(n)
         │         ╱  ╱        ╱         ╱
         │      ╱╱        ╱         ╱
         │   ╱╱       ╱        ╱              ── O(log n)
         │ ╱╱     ╱       ╱
         │╱   ╱       ╱                       ── O(1)
         └──────────────────────────────────→ n
```

---

## 面试中的复杂度速查

| 数据规模 n | 可接受的复杂度   | 说明                |
| ---------- | ---------------- | ------------------- |
| n ≤ 15     | O(n!) 或 O(2ⁿ)   | 暴力/回溯可以接受   |
| n ≤ 25     | O(2ⁿ)            | 子集枚举极限        |
| n ≤ 100    | O(n³)            | 三层循环勉强可以    |
| n ≤ 5000   | O(n²)            | 双层循环的极限      |
| n ≤ 10⁶    | O(n log n)       | 排序级别            |
| n ≤ 10⁸    | O(n)             | 线性扫描            |
| n > 10⁸    | O(log n) 或 O(1) | 必须用二分/数学公式 |

> **面试技巧**：先看数据规模，反推可接受的复杂度，再选算法。这是"从约束倒推解法"的核心思维。

---

## 终极认知：复杂度的哲学

```
O(1)       → 先知：不需要看数据就知道答案（公式、哈希表）
O(log n)   → 智者：每次只需要看一半（二分、平衡树）
O(n)       → 观察者：老老实实看一遍全部数据
O(n log n) → 组织者：看一遍，顺便排好序
O(n²)      → 社交者：每个人跟每个人都聊一遍
O(n³)      → 调解者：每对关系都要找中间人
O(2ⁿ)      → 穷举者：所有可能性都试一遍
O(n!)      → 疯子：所有排列组合都试一遍
```

**算法优化的本质，就是从疯子变成先知的过程。**
