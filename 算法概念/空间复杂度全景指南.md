<!--
- [INPUT]: 依赖算法基础概念与常见数据结构知识
- [OUTPUT]: 本文档提供所有常见空间复杂度的直觉理解与对比分析
- [POS]: 算法概念模块的核心认知文档，与时间复杂度全景指南互为姊妹篇
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 空间复杂度全景指南

> 时间复杂度衡量"要做多久"，空间复杂度衡量"要占多大地方"。两者常常是一场**博弈**——用空间换时间，或用时间换空间。

## 核心概念

### 什么是空间复杂度？

空间复杂度衡量算法运行时**额外**需要的内存空间，随输入规模 n 的增长关系。

```
总空间 = 输入数据本身 + 额外辅助空间
                        ↑
              空间复杂度只关心这个部分
```

> **关键词：额外。** 输入数据本身不算，我们只关心你"额外借了多少空间"。

### 原地算法 vs 非原地算法

| 类型                   | 额外空间         | 举例                       |
| ---------------------- | ---------------- | -------------------------- |
| 原地（in-place）       | O(1) 或 O(log n) | 快速排序、冒泡排序、双指针 |
| 非原地（out-of-place） | O(n) 或更多      | 归并排序、哈希表、动态规划 |

---

## 全局速览

| 空间复杂度 | 名称         | 额外空间   | 一句话理解                    |
| ---------- | ------------ | ---------- | ----------------------------- |
| O(1)       | 常数空间     | 几个变量   | 只用几个临时变量，不随 n 变化 |
| O(log n)   | 对数空间     | 递归栈深度 | 递归每次砍半，栈深 log n      |
| O(n)       | 线性空间     | 一份副本   | 需要一个和输入等大的辅助结构  |
| O(n log n) | 线性对数空间 | 罕见       | 少数特殊算法                  |
| O(n²)      | 平方空间     | 二维表格   | 需要 n×n 的矩阵或表           |
| O(2ⁿ)      | 指数空间     | 所有子集   | 存储所有组合结果              |

---

## O(1) — 常数空间

### 直觉

**无论处理10个数还是10亿个数，你只带了一个笔记本，笔记本大小不变。**

### 本质

只使用**固定数量**的变量，不随输入规模增长。

### 典型场景

```javascript
// 求数组最大值 — 空间 O(1)
function findMax(arr) {
  let max = arr[0]; // 就这一个额外变量
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) max = arr[i];
  }
  return max;
}

// 双指针 — 空间 O(1)
function twoSumSorted(arr, target) {
  let left = 0,
    right = arr.length - 1; // 就两个指针
  while (left < right) {
    const sum = arr[left] + arr[right];
    if (sum === target) return [left, right];
    if (sum < target) left++;
    else right--;
  }
}

// 原地反转数组 — 空间 O(1)
function reverse(arr) {
  let i = 0,
    j = arr.length - 1;
  while (i < j) {
    [arr[i], arr[j]] = [arr[j], arr[i]];
    i++;
    j--;
  }
}

// 冒泡排序 — 空间 O(1)
// 原地交换，不需要额外数组
```

### 核心认知

> O(1) 空间是**最高追求**。面试中如果能在 O(1) 空间内解决问题，面试官会眼前一亮。常见技巧：
>
> - **双指针**代替新数组
> - **位运算**代替哈希表
> - **原地交换**代替额外存储
> - **数学公式**代替遍历累加

---

## O(log n) — 对数空间

### 直觉

**你在翻一本 1024 页的字典，每次记住"当前翻到哪一半"。翻 10 次就找到了，你的笔记本上最多记 10 条笔记。**

### 本质

通常来自**递归调用栈的深度**。每次递归把问题砍半，栈深度就是 log n。

### 典型场景

```javascript
// 二分查找（递归版）— 空间 O(log n)
function binarySearch(arr, target, left, right) {
  if (left > right) return -1;
  const mid = Math.floor((left + right) / 2);
  if (arr[mid] === target) return mid;
  if (arr[mid] < target) return binarySearch(arr, target, mid + 1, right);
  return binarySearch(arr, target, left, mid - 1);
  // 每次递归压一层栈，共 log n 层
}

// 快速排序（平均情况）— 空间 O(log n)
// 每次 partition 把数组分半，递归栈深 log n

// 平衡二叉树的递归遍历 — 空间 O(log n)
// 树高 = log n，递归栈深 = 树高
```

### ⚠️ 陷阱：迭代 vs 递归

```javascript
// 二分查找（迭代版）— 空间 O(1)！
function binarySearch(arr, target) {
  let left = 0,
    right = arr.length - 1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}
// 同样的算法，迭代写法空间 O(1)，递归写法空间 O(log n)
```

### 核心认知

> O(log n) 空间几乎总是来自**递归栈**。如果你能把递归改成迭代，空间就能从 O(log n) 降到 O(1)。

---

## O(n) — 线性空间

### 直觉

**全班 30 个人的成绩，你要用一张表记下每个人的信息。人越多，表越长。**

### 本质

需要一个**与输入等大**的辅助数据结构。

### 典型场景

```javascript
// 哈希表 — 空间 O(n)
function twoSum(nums, target) {
  const map = new Map(); // 最坏情况存 n 个元素
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) return [map.get(complement), i];
    map.set(nums[i], i);
  }
}

// 归并排序 — 空间 O(n)
// 需要一个等大的临时数组来合并

// 创建新数组 — 空间 O(n)
const doubled = arr.map((x) => x * 2); // 新数组，长度 = n

// 递归遍历链表/树（非平衡情况）— 空间 O(n)
// 最坏情况：链表或退化成链的树，递归栈深 = n

// BFS 队列 — 空间 O(n)
// 最宽的一层可能有 n/2 个节点

// 动态规划的一维 DP 表 — 空间 O(n)
const dp = new Array(n).fill(0);
```

### 核心认知

> O(n) 空间是最常见的"额外代价"。**时间换空间的经典博弈**：
>
> | 方案                   | 时间  | 空间 |
> | ---------------------- | ----- | ---- |
> | 暴力两数之和（双循环） | O(n²) | O(1) |
> | 哈希表两数之和         | O(n)  | O(n) |
>
> 用 O(n) 空间的哈希表，把时间从 O(n²) 降到 O(n)。**这就是空间换时间。**

---

## O(n²) — 平方空间

### 直觉

**全班 30 个人，你要记录任意两个人之间的关系。需要一张 30×30 的表格。**

### 本质

需要一个 **n × n 的二维数组**（矩阵）。

### 典型场景

```javascript
// 图的邻接矩阵 — 空间 O(n²)
const graph = Array.from({ length: n }, () => new Array(n).fill(0));
// n 个节点，需要 n×n 的矩阵存储边

// 二维 DP 表 — 空间 O(n²)
// 最长公共子序列
const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));

// Floyd 最短路 — 空间 O(n²)
// 距离矩阵 dist[i][j]

// 所有点对之间的距离 — 空间 O(n²)
```

### 优化技巧：滚动数组

```javascript
// 原始 DP — 空间 O(n²)
const dp = Array.from({ length: n }, () => new Array(n).fill(0));
for (let i = 1; i < n; i++) {
  for (let j = 1; j < n; j++) {
    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
  }
}

// 滚动数组优化 — 空间 O(n)！
// 如果当前行只依赖上一行，只需要保留两行
const prev = new Array(n).fill(0);
const curr = new Array(n).fill(0);
// n² → n，空间直接降一个维度
```

### 核心认知

> O(n²) 空间在 n 较大时很奢侈。优化方向：
>
> - **邻接矩阵 → 邻接表**：稀疏图可从 O(n²) 降到 O(n + E)
> - **二维 DP → 滚动数组**：只依赖上一行时，空间从 O(n²) 降到 O(n)

---

## O(2ⁿ) — 指数空间

### 直觉

**列出 n 个元素的所有子集并存储下来。3 个元素有 8 个子集，20 个元素有 100 万个子集。**

### 典型场景

```javascript
// 生成所有子集并存储 — 空间 O(2ⁿ)
function subsets(nums) {
  const result = [[]];
  for (const num of nums) {
    const newSubsets = result.map((sub) => [...sub, num]);
    result.push(...newSubsets);
  }
  return result; // result 长度 = 2ⁿ
}

// 记忆化搜索（状态压缩 DP）— 空间 O(2ⁿ)
// 用 bitmask 表示"哪些元素被选了"
const memo = new Map(); // 最多 2ⁿ 种状态
```

### 核心认知

> O(2ⁿ) 空间意味着你在**存储所有组合**。通常只在 n ≤ 20 时可行。

---

## 空间复杂度 vs 时间复杂度：经典博弈

### 博弈一览表

| 问题         | 时间优先方案                | 空间优先方案                |
| ------------ | --------------------------- | --------------------------- |
| 两数之和     | O(n) 时间 + O(n) 哈希表     | O(n²) 时间 + O(1) 双循环    |
| 斐波那契     | O(n) 时间 + O(n) DP 表      | O(n) 时间 + O(1) 滚动变量   |
| 排序         | O(n log n) 归并 + O(n) 空间 | O(n log n) 堆排 + O(1) 空间 |
| 判断是否有环 | O(n) 哈希表记录 + O(n) 空间 | O(n) 快慢指针 + O(1) 空间   |
| 图存储       | O(1) 查边 + O(n²) 邻接矩阵  | O(度) 查边 + O(n+E) 邻接表  |

### 斐波那契：空间优化的经典演示

```javascript
// 方案 1：朴素递归 — 时间 O(2ⁿ)，空间 O(n)（栈深）
function fib1(n) {
  if (n <= 1) return n;
  return fib1(n - 1) + fib1(n - 2);
}

// 方案 2：DP 数组 — 时间 O(n)，空间 O(n)
function fib2(n) {
  const dp = [0, 1];
  for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2];
  return dp[n];
}

// 方案 3：滚动变量 — 时间 O(n)，空间 O(1) ✨
function fib3(n) {
  if (n <= 1) return n;
  let prev = 0,
    curr = 1;
  for (let i = 2; i <= n; i++) {
    [prev, curr] = [curr, prev + curr];
  }
  return curr;
}

// 方案 4：矩阵快速幂 — 时间 O(log n)，空间 O(1) 🏆
// 理论最优解，面试了解即可
```

> **从 O(2ⁿ) 时间 + O(n) 空间 → O(n) 时间 + O(1) 空间**，这就是算法优化的完整旅程。

---

## 隐藏的空间消耗

### 1. 递归调用栈

```javascript
// 看起来没用额外空间，但递归栈也是空间！
function sum(n) {
  if (n === 0) return 0;
  return n + sum(n - 1); // 栈深 n → 空间 O(n)
}

// 优化：尾递归 or 迭代 → 空间 O(1)
function sum(n) {
  let result = 0;
  for (let i = 1; i <= n; i++) result += i;
  return result;
}
```

### 2. 字符串拼接

```javascript
// 每次拼接都创建新字符串！
let s = "";
for (let i = 0; i < n; i++) {
  s += "a"; // 每次创建新字符串，总空间 O(n²)！
}

// 优化：数组 join
const parts = [];
for (let i = 0; i < n; i++) parts.push("a");
const s = parts.join(""); // 空间 O(n)
```

### 3. 切片操作

```javascript
// arr.slice() 创建新数组副本！
function process(arr) {
  if (arr.length === 0) return;
  process(arr.slice(1)); // 每次复制 n-1 个元素，总空间 O(n²)！
}

// 优化：用索引代替切片
function process(arr, start = 0) {
  if (start >= arr.length) return;
  process(arr, start + 1); // 空间 O(n)（仅递归栈）
}
```

---

## 面试中的空间复杂度速查

| 场景             | 空间复杂度 | 来源                   |
| ---------------- | ---------- | ---------------------- |
| 几个变量         | O(1)       | 指针、计数器、临时变量 |
| 递归砍半         | O(log n)   | 二分递归栈、平衡树遍历 |
| 哈希表/新数组    | O(n)       | 辅助数据结构           |
| 二维 DP/邻接矩阵 | O(n²)      | n×n 表格               |
| 存所有子集       | O(2ⁿ)      | 组合枚举结果           |
| 存所有排列       | O(n·n!)    | 全排列结果             |

---

## 终极认知：空间复杂度的哲学

```
O(1)      → 苦行僧：身无长物，只带必需品
O(log n)  → 登山者：每上一层留一个路标
O(n)      → 抄写员：把整本书抄了一遍
O(n²)     → 制图师：画一张所有人关系的全景图
O(2ⁿ)     → 收藏家：收集了所有可能的组合
```

> **时间是做事的速度，空间是做事的行李。**
>
> 好的算法，是一个轻装上阵、步履如飞的旅人——**带最少的行李，走最快的路。**
