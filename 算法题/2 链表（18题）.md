<!--
- [INPUT]: LeetCode 链表高频题
- [OUTPUT]: 题目清单、难度分级、核心考点与完整题解
- [POS]: 算法题模块 - 链表
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 二、链表（18题）

| 序号 | 题目名称                            | 难度   | 核心考点         | 优先级     |
| :--- | :---------------------------------- | :----- | :--------------- | :--------- |
| 20   | **反转链表 (LC 206)**               | Easy   | 迭代/递归        | ⭐⭐⭐⭐⭐ |
| 21   | **反转链表 II (LC 92)**             | Medium | 哨兵节点         | ⭐⭐⭐⭐   |
| 22   | **K个一组翻转链表 (LC 25)**         | Hard   | 递归/迭代分组    | ⭐⭐⭐⭐⭐ |
| 23   | **合并两个有序链表 (LC 21)**        | Easy   | 归并思想         | ⭐⭐⭐⭐⭐ |
| 24   | **合并K个有序链表 (LC 23)**         | Hard   | 分治/优先队列    | ⭐⭐⭐⭐⭐ |
| 25   | **环形链表 (LC 141)**               | Easy   | 快慢指针判环     | ⭐⭐⭐⭐⭐ |
| 26   | **环形链表 II (LC 142)**            | Medium | 快慢指针 + 数学  | ⭐⭐⭐⭐⭐ |
| 27   | **相交链表 (LC 160)**               | Easy   | 双指针等距       | ⭐⭐⭐⭐⭐ |
| 28   | **删除链表的倒数第N个节点 (LC 19)** | Medium | 快慢指针         | ⭐⭐⭐⭐⭐ |
| 29   | **两两交换链表中的节点 (LC 24)**    | Medium | 递归/迭代        | ⭐⭐⭐⭐   |
| 30   | **排序链表 (LC 148)**               | Medium | 归并排序         | ⭐⭐⭐⭐   |
| 31   | **回文链表 (LC 234)**               | Easy   | 快慢指针 + 反转  | ⭐⭐⭐⭐   |
| 32   | **LRU 缓存 (LC 146)**               | Medium | 哈希 + 双向链表  | ⭐⭐⭐⭐⭐ |
| 33   | **复制带随机指针的链表 (LC 138)**   | Medium | 哈希/原地复制    | ⭐⭐⭐⭐   |
| 34   | **重排链表 (LC 143)**               | Medium | 找中点+反转+合并 | ⭐⭐⭐⭐   |
| 35   | **奇偶链表 (LC 328)**               | Medium | 指针操作         | ⭐⭐⭐     |
| 36   | **旋转链表 (LC 61)**                | Medium | 成环再断开       | ⭐⭐⭐     |
| 37   | **分隔链表 (LC 86)**                | Medium | 双链表合并       | ⭐⭐⭐     |

---

## 1. 反转链表 (LC 206)

### 题目

给你单链表的头节点 `head`，请你反转链表，并返回反转后的链表。

```
输入：head = [1, 2, 3, 4, 5]
输出：[5, 4, 3, 2, 1]

输入：head = [1, 2]
输出：[2, 1]

输入：head = []
输出：[]
```

**约束：** 节点数范围 `[0, 5000]`

### 思路

**迭代法（三指针）**

1. 维护 `prev`（已反转部分的头）和 `curr`（当前节点）
2. 每步：保存 `curr.next` → 将 `curr.next` 指向 `prev` → 移动 `prev` 和 `curr`
3. 循环结束时 `prev` 就是新头节点

**递归法：** 假设后面的链表已经反转好了，只需要让 `head.next.next = head`，再把 `head.next = null`。

### 实现

```javascript
// 迭代法
function reverseList(head) {
  let prev = null; // 已反转部分的头（初始为空）
  let curr = head; // 当前待处理节点

  while (curr) {
    const next = curr.next; // 暂存下一个节点（否则断链后丢失）
    curr.next = prev; // 反转指针方向
    prev = curr; // prev 前进
    curr = next; // curr 前进
  }
  return prev; // prev 现在是新的头节点
}

// 递归法
function reverseListRecursive(head) {
  // base case：空链表或只有一个节点
  if (!head || !head.next) return head;

  // 递归反转后面的链表，newHead 是反转后的头
  const newHead = reverseListRecursive(head.next);

  // 反转当前节点：让后继节点指回自己
  head.next.next = head;
  head.next = null; // 断开原来的正向指针

  return newHead; // 头节点始终是最后一个节点
}
```

**复杂度：** 迭代 O(n)/O(1)，递归 O(n)/O(n)（调用栈）

### 核心洞察

**反转链表是链表操作的"Hello World"。** 迭代法的核心是"先保存后断链"——忘记保存 `next` 是最常见的错误。递归法的核心是"相信递归已经帮你反转好了后面的部分"——这是递归思维的本质。

---

## 2. 反转链表 II (LC 92)

### 题目

给你单链表的头指针 `head` 和两个整数 `left` 和 `right`，其中 `left <= right`。请你反转从位置 `left` 到位置 `right` 的链表节点，返回反转后的链表。

```
输入：head = [1, 2, 3, 4, 5], left = 2, right = 4
输出：[1, 4, 3, 2, 5]

输入：head = [5], left = 1, right = 1
输出：[5]
```

**约束：** `1 ≤ left ≤ right ≤ n`

### 思路

**哨兵节点 + 头插法**

1. 添加**哨兵节点** `dummy`（避免 `left = 1` 时头节点特殊处理）
2. 找到 `left` 的前一个节点 `prev`
3. 从 `left` 位置开始，将后续节点逐一**插入到 `prev` 后面**（头插法），重复 `right - left` 次

```
原始: 1 → [2 → 3 → 4] → 5    (反转 2-4)
Step1: 1 → [3 → 2 → 4] → 5    (把 3 插到 1 后面)
Step2: 1 → [4 → 3 → 2] → 5    (把 4 插到 1 后面)
```

### 实现

```javascript
function reverseBetween(head, left, right) {
  const dummy = new ListNode(0, head); // 哨兵节点
  let prev = dummy;

  // 走到 left 的前一个位置
  for (let i = 1; i < left; i++) {
    prev = prev.next;
  }

  // curr 始终指向待反转区间的第一个节点（位置不变但值在变）
  const curr = prev.next;

  // 头插法：每次把 curr.next 摘出来插到 prev 后面
  for (let i = 0; i < right - left; i++) {
    const next = curr.next; // 摘出 curr 的下一个节点
    curr.next = next.next; // curr 跳过 next
    next.next = prev.next; // next 插到 prev 后面
    prev.next = next; // prev 指向 next
  }

  return dummy.next;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**哨兵节点消除了头节点的特殊处理——这就是 Linus 说的"好品味"。** 没有哨兵节点时，`left = 1` 需要单独处理头节点变化；有了哨兵节点，所有情况统一。头插法则是"逐个摘出、逐个前置"的优雅操作，避免了先反转再拼接的复杂性。

---

## 3. K个一组翻转链表 (LC 25)

### 题目

给你链表的头节点 `head`，每 `k` 个节点一组进行翻转，请你返回修改后的链表。`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。**不能只改值，需要实际交换节点。**

```
输入：head = [1, 2, 3, 4, 5], k = 2
输出：[2, 1, 4, 3, 5]

输入：head = [1, 2, 3, 4, 5], k = 3
输出：[3, 2, 1, 4, 5]
```

**约束：** `1 ≤ k ≤ n ≤ 5000`

### 思路

**迭代法：先计数，再分组反转**

1. 先计数确认剩余节点 >= k（不足 k 个不反转）
2. 反转当前这 k 个节点（标准反转链表）
3. 把反转后的组与前一组和后一组连接起来
4. 重复直到剩余不足 k 个

### 实现

```javascript
function reverseKGroup(head, k) {
  const dummy = new ListNode(0, head);
  let prevGroupEnd = dummy; // 上一组反转后的尾节点

  while (true) {
    // Step 1: 检查剩余节点是否 >= k
    let check = prevGroupEnd;
    for (let i = 0; i < k; i++) {
      check = check.next;
      if (!check) return dummy.next; // 不足 k 个，直接返回
    }

    // Step 2: 反转从 prevGroupEnd.next 开始的 k 个节点
    let prev = null;
    let curr = prevGroupEnd.next;
    const groupStart = curr; // 反转后它会变成这组的尾节点

    for (let i = 0; i < k; i++) {
      const next = curr.next;
      curr.next = prev;
      prev = curr;
      curr = next;
    }
    // 反转后：prev 是这组的新头，curr 是下一组的头

    // Step 3: 连接——把反转后的组接入链表
    prevGroupEnd.next = prev; // 上一组尾 → 当前组新头
    groupStart.next = curr; // 当前组尾 → 下一组头

    // Step 4: 移动 prevGroupEnd 到当前组的尾部
    prevGroupEnd = groupStart;
  }
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**分组反转 = 单组反转 + 组间连接。** 难点不在反转本身（和 LC 206 一样），而在于**正确连接前后组**。`prevGroupEnd → 新头` 和 `旧头(现尾) → 下一组头` 这两根连接线是整道题的关键。

---

## 4. 合并两个有序链表 (LC 21)

### 题目

将两个升序链表合并为一个新的**升序**链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

```
输入：l1 = [1, 2, 4], l2 = [1, 3, 4]
输出：[1, 1, 2, 3, 4, 4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

**约束：** 两个链表的节点数目范围 `[0, 50]`

### 思路

**哨兵节点 + 双指针归并**

1. 创建哨兵节点 `dummy`，`tail` 指向当前构建链表的尾部
2. 同时遍历两个链表，比较当前节点值，取较小的接到 `tail` 后
3. 当一个链表遍历完，把另一个的剩余部分直接接上

### 实现

```javascript
function mergeTwoLists(l1, l2) {
  const dummy = new ListNode(0); // 哨兵节点
  let tail = dummy;

  while (l1 && l2) {
    if (l1.val <= l2.val) {
      tail.next = l1; // 取 l1 的当前节点
      l1 = l1.next;
    } else {
      tail.next = l2; // 取 l2 的当前节点
      l2 = l2.next;
    }
    tail = tail.next; // tail 前进
  }

  // 剩余部分直接接上（已经有序，无需逐个处理）
  tail.next = l1 || l2;

  return dummy.next;
}
```

**复杂度：** 时间 O(m + n)，空间 O(1)

### 核心洞察

**归并是有序数据结合的通用范式。** 链表的归并比数组更自然——不需要额外空间，只需要改变指针。`tail.next = l1 || l2` 这一行处理了所有剩余情况，体现了链表操作的优雅。

---

## 5. 合并K个有序链表 (LC 23)

### 题目

给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]

输入：lists = []
输出：[]
```

**约束：** `0 ≤ k ≤ 10⁴`，总节点数 `0 ≤ N ≤ 10⁴`

### 思路

**分治法（两两归并）**

1. 将 k 个链表两两配对，归并为 k/2 个链表
2. 重复直到只剩一个链表
3. 每轮归并总工作量 O(N)，共 O(log k) 轮 → 总 O(N log k)

**也可用最小堆/优先队列**，但 JS 没有内置堆，分治法更简洁。

### 实现

```javascript
function mergeKLists(lists) {
  if (!lists.length) return null;

  // 分治：不断两两归并，直到只剩一个
  while (lists.length > 1) {
    const merged = [];
    for (let i = 0; i < lists.length; i += 2) {
      const l1 = lists[i];
      const l2 = i + 1 < lists.length ? lists[i + 1] : null;
      merged.push(mergeTwoLists(l1, l2));
    }
    lists = merged;
  }
  return lists[0];
}

// 复用 LC 21 的合并两个有序链表
function mergeTwoLists(l1, l2) {
  const dummy = new ListNode(0);
  let tail = dummy;
  while (l1 && l2) {
    if (l1.val <= l2.val) {
      tail.next = l1;
      l1 = l1.next;
    } else {
      tail.next = l2;
      l2 = l2.next;
    }
    tail = tail.next;
  }
  tail.next = l1 || l2;
  return dummy.next;
}
```

**复杂度：** 时间 O(N log k)，空间 O(log k)（递归栈或归并层数）

### 核心洞察

**分治是"规模缩减"的终极武器。** 把 k 路归并拆成两两归并，每轮问题规模减半——这和归并排序是同一思想。顺序归并（1合2，12合3，123合4...）时间是 O(Nk)，分治归并是 O(N log k)，差距在于**平衡的分治避免了重复扫描**。

---

## 6. 环形链表 (LC 141)

### 题目

给你一个链表的头节点 `head`，判断链表中是否有环。如果链表中存在环，则返回 `true`；否则返回 `false`。

```
输入：head = [3, 2, 0, -4], pos = 1（尾节点连接到下标 1）
输出：true

输入：head = [1, 2], pos = 0
输出：true

输入：head = [1], pos = -1
输出：false
```

**约束：** 节点数范围 `[0, 10⁴]`

### 思路

**快慢指针（Floyd 判环）**

1. `slow` 每次走 1 步，`fast` 每次走 2 步
2. 如果有环，`fast` 一定会追上 `slow`（每步距离差减 1）
3. 如果无环，`fast` 会先到达 `null`

**为什么一定会相遇？** 当两个指针都在环内时，它们的距离每步减小 1，所以一定会减到 0（相遇）。

### 实现

```javascript
function hasCycle(head) {
  let slow = head,
    fast = head;

  while (fast && fast.next) {
    slow = slow.next; // 慢指针走 1 步
    fast = fast.next.next; // 快指针走 2 步

    if (slow === fast) return true; // 相遇 → 有环
  }
  return false; // fast 到达 null → 无环
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**快慢指针的本质是"速度差"。** 两个不同速度的指针在环中就像跑道上的两个人——快的一定会"套圈"慢的。O(1) 空间判环，是 Floyd 算法的天才之处。

---

## 7. 环形链表 II (LC 142)

### 题目

给定一个链表的头节点 `head`，返回链表**开始入环的第一个节点**。如果链表无环返回 `null`。

```
输入：head = [3, 2, 0, -4], pos = 1
输出：返回索引为 1 的链表节点（值为 2）

输入：head = [1], pos = -1
输出：null
```

**约束：** 节点数范围 `[0, 10⁴]`

### 思路

**Floyd 判环 + 数学推导找入口**

1. Phase 1：快慢指针找到相遇点
2. Phase 2：数学推导——设头到入口距离 `a`，入口到相遇点距离 `b`，环长 `c`
   - 相遇时 `slow` 走了 `a + b`，`fast` 走了 `a + b + k·c`
   - `fast` 速度是 `slow` 的 2 倍：`2(a+b) = a + b + k·c` → `a + b = k·c` → `a = k·c - b`
   - 所以从**头节点**和**相遇点**各出发一个指针，每次走 1 步，它们会在入环点相遇

### 实现

```javascript
function detectCycle(head) {
  let slow = head,
    fast = head;

  // Phase 1：找到相遇点
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) {
      // Phase 2：从头和相遇点出发，找入口
      let ptr = head;
      while (ptr !== slow) {
        ptr = ptr.next;
        slow = slow.next;
      }
      return ptr; // 相遇点就是入环口
    }
  }
  return null; // 无环
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**数学是算法的隐藏武器。** Phase 1 找到环的存在，Phase 2 用 `a = k·c - b` 这个等式找到入口。关键洞察是：从头节点到入口的距离 = 从相遇点绕环到入口的距离。这个等式把"找环的入口"转化为"两个指针同速相遇"。

---

## 8. 相交链表 (LC 160)

### 题目

给你两个单链表的头节点 `headA` 和 `headB`，请你找出并返回两个单链表相交的起始节点。如果不存在相交节点返回 `null`。

```
输入：listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]（8 处相交）
输出：值为 8 的节点

输入：listA = [2,6,4], listB = [1,5]（不相交）
输出：null
```

**约束：** `1 ≤ m, n ≤ 3 × 10⁴`

### 思路

**双指针走完两条链表**

1. 指针 A 从 `headA` 开始，到末尾后跳到 `headB`
2. 指针 B 从 `headB` 开始，到末尾后跳到 `headA`
3. 如果有交点：两个指针走的总长度相同（`a + c + b = b + c + a`），一定在交点相遇
4. 如果无交点：两个指针同时到达 `null`

### 实现

```javascript
function getIntersectionNode(headA, headB) {
  let pA = headA,
    pB = headB;

  // 两指针最终走过的总路径长度相等
  while (pA !== pB) {
    pA = pA ? pA.next : headB; // A 走完跳到 B 的头
    pB = pB ? pB.next : headA; // B 走完跳到 A 的头
  }
  return pA; // 相交节点 或 null（都走完没有交点）
}
```

**复杂度：** 时间 O(m + n)，空间 O(1)

### 核心洞察

**让两条不等长的路径变等长——通过走对方的路。** `a + c + b = b + c + a`，这个等式保证了两个指针在第二轮遍历中一定同步到达交点（或 null）。不需要计算链表长度，不需要哈希表——纯粹的数学之美。

---

## 9. 删除链表的倒数第N个节点 (LC 19)

### 题目

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```
输入：head = [1, 2, 3, 4, 5], n = 2
输出：[1, 2, 3, 5]

输入：head = [1], n = 1
输出：[]
```

**约束：** 链表结点数为 `sz`，`1 ≤ n ≤ sz`

**进阶：** 能否一趟扫描?

### 思路

**快慢指针（一趟扫描）**

1. 哨兵节点 `dummy`（处理删除头节点的情况）
2. `fast` 先走 `n + 1` 步（比 slow 超前 n+1 步）
3. `fast` 和 `slow` 同步前进，直到 `fast` 到达 `null`
4. 此时 `slow` 恰好在倒数第 `n+1` 个节点（即待删除节点的前一个）
5. `slow.next = slow.next.next` 完成删除

### 实现

```javascript
function removeNthFromEnd(head, n) {
  const dummy = new ListNode(0, head);
  let fast = dummy,
    slow = dummy;

  // fast 先走 n+1 步，拉开 n+1 的间距
  for (let i = 0; i <= n; i++) {
    fast = fast.next;
  }

  // 同步前进，直到 fast 到达末尾
  while (fast) {
    fast = fast.next;
    slow = slow.next;
  }

  // slow 现在指向倒数第 n+1 个节点，跳过下一个节点
  slow.next = slow.next.next;

  return dummy.next;
}
```

**复杂度：** 时间 O(L)，空间 O(1)

### 核心洞察

**"倒数第 N 个"可以转化为"两个指针的间距"。** 快慢指针的间距维持在 n+1，当快指针到终点时，慢指针恰好在目标前一步。这比"先遍历求长度再定位"更优雅——一趟扫描 vs 两趟。

---

## 10. 两两交换链表中的节点 (LC 24)

### 题目

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。不能只修改节点的值。

```
输入：head = [1, 2, 3, 4]
输出：[2, 1, 4, 3]

输入：head = []
输出：[]

输入：head = [1]
输出：[1]
```

**约束：** 节点数范围 `[0, 100]`

### 思路

**迭代法（哨兵 + 三指针）**

每次交换一对节点 `(a, b)`，需要处理 `prev → a → b → next` 变成 `prev → b → a → next`。

### 实现

```javascript
function swapPairs(head) {
  const dummy = new ListNode(0, head);
  let prev = dummy;

  while (prev.next && prev.next.next) {
    const a = prev.next; // 第一个节点
    const b = prev.next.next; // 第二个节点

    // 交换 a 和 b
    a.next = b.next; // a 指向 b 的后继
    b.next = a; // b 指向 a
    prev.next = b; // prev 指向 b（新的前面节点）

    prev = a; // 移到下一对的前驱（a 现在是后面的节点）
  }
  return dummy.next;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**链表交换的关键是画图理清指针。** `prev → b → a → next` 这三根指针的修改顺序很重要——先断后连，避免丢失引用。这道题是 K 个一组翻转（LC 25）`k=2` 的特例。

---

## 11. 排序链表 (LC 148)

### 题目

给你链表的头结点 `head`，请将其按**升序**排列并返回排序后的链表。

```
输入：head = [4, 2, 1, 3]
输出：[1, 2, 3, 4]

输入：head = [-1, 5, 3, 4, 0]
输出：[-1, 0, 3, 4, 5]
```

**约束：** 节点数范围 `[0, 5 × 10⁴]`

**进阶：** 能否在 O(n log n) 时间和 O(1) 空间下排序？

### 思路

**归并排序（自顶向下）**

1. **找中点**：快慢指针找到链表中点，从中点断开
2. **递归排序**：分别对左右两半递归排序
3. **合并**：归并两个有序链表（LC 21）

链表天然适合归并排序：分割只需改指针（O(1)），不需要像数组那样复制。

### 实现

```javascript
function sortList(head) {
  // base case：空或单节点
  if (!head || !head.next) return head;

  // Step 1: 快慢指针找中点，断开链表
  let slow = head,
    fast = head.next;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }
  const mid = slow.next;
  slow.next = null; // 断开左右两半

  // Step 2: 递归排序左右两半
  const left = sortList(head);
  const right = sortList(mid);

  // Step 3: 合并两个有序链表
  return mergeTwoLists(left, right);
}

function mergeTwoLists(l1, l2) {
  const dummy = new ListNode(0);
  let tail = dummy;
  while (l1 && l2) {
    if (l1.val <= l2.val) {
      tail.next = l1;
      l1 = l1.next;
    } else {
      tail.next = l2;
      l2 = l2.next;
    }
    tail = tail.next;
  }
  tail.next = l1 || l2;
  return dummy.next;
}
```

**复杂度：** 时间 O(n log n)，空间 O(log n)（递归栈）

### 核心洞察

**归并排序是链表排序的最佳选择。** 数组排序用快排（cache-friendly），链表排序用归并（分割免费）。快排对链表不友好——随机访问 O(n)，pivot 选择困难。而归并的"找中点→分割→合并"完美契合链表特性。

---

## 12. 回文链表 (LC 234)

### 题目

给你一个单链表的头节点 `head`，请你判断该链表是否为回文链表。如果是返回 `true`；否则返回 `false`。

```
输入：head = [1, 2, 2, 1]
输出：true

输入：head = [1, 2]
输出：false
```

**约束：** `1 ≤ 节点数 ≤ 10⁵`

**进阶：** 能否用 O(n) 时间和 O(1) 空间？

### 思路

**快慢指针找中点 + 反转后半段 + 逐一比较**

1. 快慢指针找到链表中点
2. 反转后半段链表
3. 从头和从中点同时遍历比较
4. （可选）恢复链表原结构

### 实现

```javascript
function isPalindrome(head) {
  // Step 1: 找中点
  let slow = head,
    fast = head;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }

  // Step 2: 反转后半段
  let prev = null;
  while (slow) {
    const next = slow.next;
    slow.next = prev;
    prev = slow;
    slow = next;
  }

  // Step 3: 比较前半段和反转后的后半段
  let left = head,
    right = prev;
  while (right) {
    // right 是较短的（或等长的）反转后半段
    if (left.val !== right.val) return false;
    left = left.next;
    right = right.next;
  }
  return true;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**三个基础操作的组合解决一个复合问题。** 找中点（快慢指针）+ 反转链表 + 合并/比较——这三个操作在链表题中反复出现。掌握基础操作的组合能力，比记忆具体题目更重要。

---

## 13. LRU 缓存 (LC 146)

### 题目

请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以**正整数**作为容量初始化
- `int get(int key)` 如果 key 存在则返回值（标记为最近使用），否则返回 -1
- `void put(int key, int value)` 如果 key 存在则更新值；如果不存在则插入。超出容量时淘汰最久未使用的键值对

**get 和 put 必须以 O(1) 时间运行。**

```
输入：["LRUCache","put","put","get","put","get","put","get","get","get"]
      [[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]
输出：[null,null,null,1,null,-1,null,-1,3,4]
```

### 思路

**哈希表 + 双向链表**

- **哈希表**：`key → Node`，O(1) 查找
- **双向链表**：维护使用顺序。最近使用的放头部，最久未使用的在尾部
- `get`：哈希查找 → 移到链表头部 → 返回值
- `put`：存在则更新+移到头部；不存在则新建+加到头部，满了就删尾部

### 实现

```javascript
class ListNode {
  constructor(key = 0, val = 0) {
    this.key = key;
    this.val = val;
    this.prev = null;
    this.next = null;
  }
}

class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.map = new Map(); // key → ListNode

    // 哨兵节点：避免 null 检查
    this.head = new ListNode(); // dummy head
    this.tail = new ListNode(); // dummy tail
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }

  get(key) {
    if (!this.map.has(key)) return -1;
    const node = this.map.get(key);
    this._moveToHead(node); // 标记为最近使用
    return node.val;
  }

  put(key, value) {
    if (this.map.has(key)) {
      const node = this.map.get(key);
      node.val = value;
      this._moveToHead(node);
    } else {
      const node = new ListNode(key, value);
      this.map.set(key, node);
      this._addToHead(node);

      if (this.map.size > this.capacity) {
        const removed = this._removeTail(); // 淘汰最久未使用
        this.map.delete(removed.key);
      }
    }
  }

  // ---- 双向链表操作 ----
  _addToHead(node) {
    node.prev = this.head;
    node.next = this.head.next;
    this.head.next.prev = node;
    this.head.next = node;
  }

  _removeNode(node) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  }

  _moveToHead(node) {
    this._removeNode(node);
    this._addToHead(node);
  }

  _removeTail() {
    const node = this.tail.prev;
    this._removeNode(node);
    return node;
  }
}
```

**复杂度：** get/put 均 O(1)

### 核心洞察

**LRU = 哈希表（O(1)查找）+ 双向链表（O(1)增删 + 顺序维护）。** 哈希表负责"快速定位"，双向链表负责"维护时间顺序"。两个数据结构各司其职，组合出单一结构无法实现的 O(1) 全操作。哨兵节点再次消除了边界情况。

---

## 14. 复制带随机指针的链表 (LC 138)

### 题目

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random`，该指针可以指向链表中的任何节点或空节点。构造这个链表的**深拷贝**。

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：相同结构的深拷贝链表
```

**约束：** `0 ≤ n ≤ 1000`

### 思路

**三步法：交织 → 复制 random → 拆分**

1. 在每个原节点后面插入一个克隆节点：`A → A' → B → B' → C → C'`
2. 设置克隆节点的 `random`：`clone.random = original.random.next`
3. 将交织链表拆分为原链表和克隆链表

### 实现

```javascript
function copyRandomList(head) {
  if (!head) return null;

  // Step 1: 在每个节点后面插入克隆节点
  let curr = head;
  while (curr) {
    const clone = new Node(curr.val);
    clone.next = curr.next;
    curr.next = clone;
    curr = clone.next;
  }

  // Step 2: 设置克隆节点的 random
  curr = head;
  while (curr) {
    if (curr.random) {
      curr.next.random = curr.random.next; // 克隆的 random = 原节点 random 的克隆
    }
    curr = curr.next.next; // 跳过克隆节点
  }

  // Step 3: 拆分——分离原链表和克隆链表
  const dummy = new Node(0);
  let cloneTail = dummy;
  curr = head;
  while (curr) {
    cloneTail.next = curr.next; // 取出克隆节点
    cloneTail = cloneTail.next;
    curr.next = curr.next.next; // 恢复原链表
    curr = curr.next;
  }
  return dummy.next;
}
```

**复杂度：** 时间 O(n)，空间 O(1)（不计输出）

### 核心洞察

**"交织"是原地建立映射的天才技巧。** 哈希表法需要 O(n) 空间建立 `原节点→克隆节点` 的映射。交织法把克隆节点直接插在原节点旁边——位置本身就是映射关系。`original.next` 就是 `clone`，省去了哈希表。

---

## 15. 重排链表 (LC 143)

### 题目

给定一个单链表 `L: L0 → L1 → … → Ln-1 → Ln`，将其重新排列为：`L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …`。不能只改值。

```
输入：head = [1, 2, 3, 4]
输出：[1, 4, 2, 3]

输入：head = [1, 2, 3, 4, 5]
输出：[1, 5, 2, 4, 3]
```

**约束：** `1 ≤ 节点数 ≤ 5 × 10⁴`

### 思路

**三步走：找中点 → 反转后半段 → 合并两半**

1. 快慢指针找中点
2. 反转后半段
3. 交替合并前半段和反转后的后半段

### 实现

```javascript
function reorderList(head) {
  if (!head || !head.next) return;

  // Step 1: 找中点并断开
  let slow = head,
    fast = head;
  while (fast.next && fast.next.next) {
    slow = slow.next;
    fast = fast.next.next;
  }
  let second = slow.next;
  slow.next = null; // 断开前后半段

  // Step 2: 反转后半段
  let prev = null;
  while (second) {
    const next = second.next;
    second.next = prev;
    prev = second;
    second = next;
  }
  second = prev;

  // Step 3: 交替合并
  let first = head;
  while (second) {
    const next1 = first.next;
    const next2 = second.next;
    first.next = second;
    second.next = next1;
    first = next1;
    second = next2;
  }
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**链表的复合操作 = 基础操作的排列组合。** 找中点、反转、合并——同样的三个基础操作，在回文链表（LC 234）、排序链表（LC 148）、重排链表中以不同方式组合。掌握基础操作就是掌握了解决一类问题的能力。

---

## 16. 奇偶链表 (LC 328)

### 题目

给定单链表的头节点 `head`，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后将偶数节点接在奇数节点后面。第一个节点的索引被认为是奇数。

```
输入：head = [1, 2, 3, 4, 5]
输出：[1, 3, 5, 2, 4]

输入：head = [2, 1, 3, 5, 6, 4, 7]
输出：[2, 3, 6, 7, 1, 5, 4]
```

**约束：** `0 ≤ n ≤ 10⁴`，要求 O(1) 空间、O(n) 时间

### 思路

维护两条链：奇数链和偶数链。遍历完后把偶数链接到奇数链末尾。

### 实现

```javascript
function oddEvenList(head) {
  if (!head) return null;

  let odd = head; // 奇数链表头
  let even = head.next; // 偶数链表头
  const evenHead = even; // 保存偶数链表头，最后接上

  while (even && even.next) {
    odd.next = even.next; // 奇数节点跳过偶数
    odd = odd.next;
    even.next = odd.next; // 偶数节点跳过奇数
    even = even.next;
  }

  odd.next = evenHead; // 奇数链尾 → 偶数链头
  return head;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**分离再合并，比原地交错更简单。** 把奇偶节点分成两条链再拼接，比在原链表中腾挪更不容易出错。保存 `evenHead` 是关键——分离后需要它来拼接。

---

## 17. 旋转链表 (LC 61)

### 题目

给你一个链表的头节点 `head`，旋转链表，将链表每个节点向右移动 `k` 个位置。

```
输入：head = [1, 2, 3, 4, 5], k = 2
输出：[4, 5, 1, 2, 3]

输入：head = [0, 1, 2], k = 4
输出：[2, 0, 1]
```

**约束：** `0 ≤ k ≤ 2 × 10⁹`

### 思路

**成环再断开**

1. 遍历链表得到长度 `n`，同时找到尾节点
2. `k %= n`（处理 k > n）
3. 将尾节点连接到头节点形成**环**
4. 从原头节点走 `n - k` 步找到新的尾节点，在此处断开

### 实现

```javascript
function rotateRight(head, k) {
  if (!head || !head.next || k === 0) return head;

  // 计算链表长度，找到尾节点
  let len = 1,
    tail = head;
  while (tail.next) {
    tail = tail.next;
    len++;
  }

  k %= len;
  if (k === 0) return head; // 不需要旋转

  // 成环
  tail.next = head;

  // 找到新的尾节点：从头走 n-k 步
  let newTail = head;
  for (let i = 1; i < len - k; i++) {
    newTail = newTail.next;
  }

  // 断开环
  const newHead = newTail.next;
  newTail.next = null;

  return newHead;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**成环再断开比"截断再拼接"更优雅。** 形成环后只需要找到正确的断开位置——一步操作代替了"断开两段 + 重新拼接"的多步操作。`k %= n` 是处理超大 k 的关键。

---

## 18. 分隔链表 (LC 86)

### 题目

给你一个链表的头节点 `head` 和一个特定值 `x`，请你对链表进行分隔，使得所有**小于** `x` 的节点都出现在**大于或等于** `x` 的节点之前。应当保留两个分区中每个节点的初始相对位置。

```
输入：head = [1, 4, 3, 2, 5, 2], x = 3
输出：[1, 2, 2, 4, 3, 5]

输入：head = [2, 1], x = 2
输出：[1, 2]
```

**约束：** `0 ≤ n ≤ 200`

### 思路

**双链表收集再拼接**

1. 创建两个哨兵节点：`small`（< x 的节点）和 `big`（>= x 的节点）
2. 遍历原链表，根据值分到两条链中
3. 最后 `small` 尾部接 `big` 头部，`big` 尾部置 `null`

### 实现

```javascript
function partition(head, x) {
  const smallDummy = new ListNode(0); // < x 的链表
  const bigDummy = new ListNode(0); // >= x 的链表
  let small = smallDummy,
    big = bigDummy;

  while (head) {
    if (head.val < x) {
      small.next = head;
      small = small.next;
    } else {
      big.next = head;
      big = big.next;
    }
    head = head.next;
  }

  big.next = null; // 切断可能的残留指针（重要！）
  small.next = bigDummy.next; // 小链表尾 → 大链表头

  return smallDummy.next;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**分隔问题本质是"分类收集"。** 建两条链分别收集，最后拼接——思路极简，不容易出错。`big.next = null` 这一行至关重要：如果不断开，大链表的最后一个节点可能还指向小链表中的某个节点，形成环。
