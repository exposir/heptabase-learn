<!--
- [INPUT]: LeetCode 二叉树高频题
- [OUTPUT]: 题目清单、难度分级、核心考点与完整题解
- [POS]: 算法题模块 - 二叉树
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 三、二叉树（31题）

| 序号 | 题目名称                                      | 难度   | 核心考点        | 优先级     |
| :--- | :-------------------------------------------- | :----- | :-------------- | :--------- |
| 38   | **二叉树的前序遍历 (LC 144)**                 | Easy   | 递归/迭代       | ⭐⭐⭐⭐⭐ |
| 39   | **二叉树的中序遍历 (LC 94)**                  | Easy   | 递归/迭代       | ⭐⭐⭐⭐⭐ |
| 40   | **二叉树的后序遍历 (LC 145)**                 | Easy   | 递归/迭代       | ⭐⭐⭐⭐⭐ |
| 41   | **二叉树的层序遍历 (LC 102)**                 | Medium | BFS 模板        | ⭐⭐⭐⭐⭐ |
| 42   | **二叉树的最大深度 (LC 104)**                 | Easy   | DFS/BFS         | ⭐⭐⭐⭐⭐ |
| 43   | **对称二叉树 (LC 101)**                       | Easy   | 递归/迭代       | ⭐⭐⭐⭐⭐ |
| 44   | **翻转二叉树 (LC 226)**                       | Easy   | 递归            | ⭐⭐⭐⭐⭐ |
| 45   | **二叉树的直径 (LC 543)**                     | Easy   | 后序 + 全局变量 | ⭐⭐⭐⭐⭐ |
| 46   | **二叉树的最近公共祖先 (LC 236)**             | Medium | 递归思维        | ⭐⭐⭐⭐⭐ |
| 47   | **二叉树的右视图 (LC 199)**                   | Medium | BFS/DFS         | ⭐⭐⭐⭐   |
| 48   | **验证二叉搜索树 (LC 98)**                    | Medium | 中序遍历        | ⭐⭐⭐⭐⭐ |
| 49   | **二叉搜索树中第K小的元素 (LC 230)**          | Medium | 中序遍历        | ⭐⭐⭐⭐   |
| 50   | **从前序与中序遍历构造二叉树 (LC 105)**       | Medium | 分治递归        | ⭐⭐⭐⭐⭐ |
| 51   | **二叉树展开为链表 (LC 114)**                 | Medium | 前序变形        | ⭐⭐⭐⭐   |
| 52   | **二叉树的最大路径和 (LC 124)**               | Hard   | 后序 + 全局变量 | ⭐⭐⭐⭐⭐ |
| 53   | **二叉树的序列化与反序列化 (LC 297)**         | Hard   | 前序/层序       | ⭐⭐⭐⭐   |
| 54   | **二叉树的锯齿形层序遍历 (LC 103)**           | Medium | BFS + 方向      | ⭐⭐⭐⭐   |
| 55   | **路径总和 (LC 112)**                         | Easy   | DFS             | ⭐⭐⭐⭐   |
| 56   | **路径总和 II (LC 113)**                      | Medium | DFS + 回溯      | ⭐⭐⭐⭐   |
| 57   | **路径总和 III (LC 437)**                     | Medium | 前缀和 + DFS    | ⭐⭐⭐⭐   |
| 58   | **二叉搜索树的最近公共祖先 (LC 235)**         | Medium | BST特性         | ⭐⭐⭐     |
| 59   | **完全二叉树的节点个数 (LC 222)**             | Medium | 二分 + 位运算   | ⭐⭐⭐     |
| 60   | **填充每个节点的下一个右侧节点指针 (LC 116)** | Medium | BFS/递归        | ⭐⭐⭐     |
| 61   | **不同的二叉搜索树 (LC 96)**                  | Medium | 卡特兰数/DP     | ⭐⭐⭐⭐   |
| 62   | **不同的二叉搜索树 II (LC 95)**               | Medium | 递归构造        | ⭐⭐⭐     |
| 63   | **平衡二叉树 (LC 110)**                       | Easy   | 递归判断        | ⭐⭐⭐⭐   |
| 64   | **二叉树的最小深度 (LC 111)**                 | Easy   | BFS更优         | ⭐⭐⭐     |
| 65   | **求根节点到叶节点数字之和 (LC 129)**         | Medium | DFS             | ⭐⭐⭐     |
| 66   | **从中序与后序遍历构造二叉树 (LC 106)**       | Medium | 分治            | ⭐⭐⭐⭐   |
| 67   | **二叉搜索树迭代器 (LC 173)**                 | Medium | 中序迭代        | ⭐⭐⭐     |
| 68   | **将有序数组转换为二叉搜索树 (LC 108)**       | Easy   | 分治构造        | ⭐⭐⭐⭐   |

---

## 1. 二叉树的前序遍历 (LC 144)

> **Easy** | 核心考点：递归/迭代 | ⭐⭐⭐⭐⭐

### 题目

给你二叉树的根节点 `root`，返回它节点值的**前序遍历**（根 → 左 → 右）。

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

### 思路

递归天然契合树结构。迭代法用**显式栈**模拟递归：先压右子再压左子（后进先出→左先处理）。

### 实现

```javascript
// 递归
function preorderTraversal(root) {
  const result = [];
  const dfs = (node) => {
    if (!node) return;
    result.push(node.val); // 根
    dfs(node.left); // 左
    dfs(node.right); // 右
  };
  dfs(root);
  return result;
}

// 迭代（显式栈）
function preorderIterative(root) {
  if (!root) return [];
  const result = [],
    stack = [root];
  while (stack.length) {
    const node = stack.pop();
    result.push(node.val);
    if (node.right) stack.push(node.right); // 先压右
    if (node.left) stack.push(node.left); // 再压左（后出）
  }
  return result;
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**递归是树的母语。** 迭代法的关键是用栈模拟调用栈，注意压栈顺序（先右后左）保证左子树先被处理。

---

## 2. 二叉树的中序遍历 (LC 94)

> **Easy** | 核心考点：递归/迭代 | ⭐⭐⭐⭐⭐

### 题目

给定一个二叉树的根节点 `root`，返回它的**中序遍历**（左 → 根 → 右）。

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

### 思路

迭代法：一路向左压栈，弹出时访问，然后转向右子树。

### 实现

```javascript
function inorderTraversal(root) {
  const result = [],
    stack = [];
  let curr = root;

  while (curr || stack.length) {
    // 一路向左，全部压栈
    while (curr) {
      stack.push(curr);
      curr = curr.left;
    }
    // 弹出（最左节点）→ 访问 → 转向右子树
    curr = stack.pop();
    result.push(curr.val);
    curr = curr.right;
  }
  return result;
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**中序迭代的模式是"一路向左→弹出访问→转右"。** 这个模式在 BST 相关题目中反复出现（验证BST、第K小、BST迭代器）。掌握它就掌握了一类题。

---

## 3. 二叉树的后序遍历 (LC 145)

> **Easy** | 核心考点：递归/迭代 | ⭐⭐⭐⭐⭐

### 题目

给你一棵二叉树的根节点 `root`，返回其节点值的**后序遍历**（左 → 右 → 根）。

```
输入：root = [1,null,2,3]
输出：[3,2,1]
```

### 思路

**技巧：前序(根左右)变形为(根右左)，再反转得到(左右根)**。

### 实现

```javascript
function postorderTraversal(root) {
  if (!root) return [];
  const result = [],
    stack = [root];

  while (stack.length) {
    const node = stack.pop();
    result.push(node.val);
    if (node.left) stack.push(node.left); // 先压左
    if (node.right) stack.push(node.right); // 再压右（后出→右先处理）
  }
  return result.reverse(); // 根右左 → 左右根
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**后序 = 反转的"修改版前序"。** 前序是根左右，把左右交换得根右左，再反转整个结果就是左右根（后序）。用已知解法推导新解法——这是组合思维。

---

## 4. 二叉树的层序遍历 (LC 102)

> **Medium** | 核心考点：BFS 模板 | ⭐⭐⭐⭐⭐

### 题目

给你二叉树的根节点 `root`，返回其节点值的**层序遍历**（逐层从左到右）。

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

### 思路

**BFS + 按层分组**：每轮处理队列中当前层的所有节点（记录层大小），子节点入队。

### 实现

```javascript
function levelOrder(root) {
  if (!root) return [];
  const result = [],
    queue = [root];

  while (queue.length) {
    const levelSize = queue.length; // 当前层的节点数
    const level = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      level.push(node.val);
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    result.push(level);
  }
  return result;
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**`levelSize = queue.length` 是层序遍历的灵魂。** 在处理前锁定当前层的节点数，就能精确区分层与层的边界。所有层序变体（锯齿形、右视图、层平均值）都基于这个模板。

---

## 5. 二叉树的最大深度 (LC 104)

> **Easy** | 核心考点：DFS/BFS | ⭐⭐⭐⭐⭐

### 题目

给定一个二叉树 `root`，返回其最大深度（根节点到最远叶子节点的最长路径上的节点数）。

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

### 实现

```javascript
function maxDepth(root) {
  if (!root) return 0;
  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**树的深度 = 1 + max(左子树深度, 右子树深度)。** 这是递归最本质的表达：把大问题分解为完全相同的子问题。一行代码，一个真理。

---

## 6. 对称二叉树 (LC 101)

> **Easy** | 核心考点：递归/迭代 | ⭐⭐⭐⭐⭐

### 题目

给你一个二叉树的根节点 `root`，检查它是否**轴对称**。

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

### 实现

```javascript
function isSymmetric(root) {
  const check = (left, right) => {
    if (!left && !right) return true;
    if (!left || !right) return false;
    return (
      left.val === right.val &&
      check(left.left, right.right) && // 外侧比较
      check(left.right, right.left)
    ); // 内侧比较
  };
  return check(root.left, root.right);
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**对称 = 镜像比较。** 不是比较同一棵子树，而是比较"左的左 vs 右的右"和"左的右 vs 右的左"——交叉配对。

---

## 7. 翻转二叉树 (LC 226)

> **Easy** | 核心考点：递归 | ⭐⭐⭐⭐⭐

### 题目

给你一棵二叉树的根节点 `root`，翻转这棵二叉树（每个节点的左右子树交换），并返回其根节点。

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

### 实现

```javascript
function invertTree(root) {
  if (!root) return null;
  [root.left, root.right] = [root.right, root.left]; // 交换左右子树
  invertTree(root.left); // 递归翻转左子树
  invertTree(root.right); // 递归翻转右子树
  return root;
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**翻转 = 每个节点交换左右子树。** 递归保证了从根到叶每个节点都被翻转。前序、后序都可以，中序不行（交换后会重复处理同一侧）。

---

## 8. 二叉树的直径 (LC 543)

> **Easy** | 核心考点：后序 + 全局变量 | ⭐⭐⭐⭐⭐

### 题目

给你一棵二叉树的根节点，返回该树的**直径**——任意两节点间最长路径的边数（路径可能不经过根节点）。

```
输入：root = [1,2,3,4,5]
输出：3（路径 [4,2,1,3] 或 [5,2,1,3]）
```

### 思路

经过每个节点的最长路径 = 左子树深度 + 右子树深度。用后序遍历计算深度，同时更新全局最大径。

### 实现

```javascript
function diameterOfBinaryTree(root) {
  let maxDiam = 0;

  const depth = (node) => {
    if (!node) return 0;
    const left = depth(node.left);
    const right = depth(node.right);
    maxDiam = Math.max(maxDiam, left + right); // 经过当前节点的路径长度
    return 1 + Math.max(left, right); // 返回当前节点的深度
  };

  depth(root);
  return maxDiam;
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**"返回值"和"更新全局变量"做不同的事。** 返回值传递"深度"给父节点，全局变量记录"直径"的最大值。这种"后序遍历 + 全局变量"模式在最大路径和（LC 124）中也出现。

---

## 9. 二叉树的最近公共祖先 (LC 236)

> **Medium** | 核心考点：递归思维 | ⭐⭐⭐⭐⭐

### 题目

给定一个二叉树，找到该树中两个指定节点 `p` 和 `q` 的**最近公共祖先 (LCA)**。

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5（一个节点可以是自己的祖先）
```

### 实现

```javascript
function lowestCommonAncestor(root, p, q) {
  if (!root || root === p || root === q) return root;

  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);

  if (left && right) return root; // p 和 q 分布在两侧 → 当前节点是 LCA
  return left || right; // 都在同一侧 → 返回非空的那个
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**递归返回"找到的信息"：** null=没找到，非null=找到了p或q或它们的LCA。当左右都非空时，说明p和q分居两侧——当前节点就是LCA。简洁到不可能更简。

---

## 10. 二叉树的右视图 (LC 199)

> **Medium** | 核心考点：BFS/DFS | ⭐⭐⭐⭐

### 题目

给定一个二叉树的根节点 `root`，想象自己站在它的右侧，返回从顶部到底部能看到的节点值。

```
输入：root = [1,2,3,null,5,null,4]
输出：[1,3,4]
```

### 实现

```javascript
function rightSideView(root) {
  if (!root) return [];
  const result = [],
    queue = [root];

  while (queue.length) {
    const size = queue.length;
    for (let i = 0; i < size; i++) {
      const node = queue.shift();
      if (i === size - 1) result.push(node.val); // 每层最后一个
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
  }
  return result;
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**右视图 = 每层的最后一个节点。** 层序遍历模板 + 判断 `i === size - 1`。左视图只需改为 `i === 0`。

---

## 11. 验证二叉搜索树 (LC 98)

> **Medium** | 核心考点：中序遍历 | ⭐⭐⭐⭐⭐

### 题目

给你一个二叉树的根节点 `root`，判断其是否是一个有效的**二叉搜索树 (BST)**。

```
输入：root = [5,1,4,null,null,3,6]
输出：false（4 在 5 的右子树中但小于 5）
```

### 思路

**中序遍历 BST 得到严格递增序列。** 只需验证中序遍历的每个值都大于前一个值。

### 实现

```javascript
function isValidBST(root) {
  let prev = -Infinity;

  const inorder = (node) => {
    if (!node) return true;
    if (!inorder(node.left)) return false; // 左
    if (node.val <= prev) return false; // 根：必须严格大于前一个
    prev = node.val;
    return inorder(node.right); // 右
  };

  return inorder(root);
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**BST 的中序遍历是有序的——这是 BST 最重要的性质。** 把"验证树结构"转化为"验证序列单调性"，复杂的结构问题变成简单的线性问题。

---

## 12. 二叉搜索树中第K小的元素 (LC 230)

> **Medium** | 核心考点：中序遍历 | ⭐⭐⭐⭐

### 题目

给定一个二叉搜索树的根节点 `root` 和一个整数 `k`，返回树中第 `k` 小的元素（1-indexed）。

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

### 实现

```javascript
function kthSmallest(root, k) {
  const stack = [];
  let curr = root;

  while (curr || stack.length) {
    while (curr) {
      stack.push(curr);
      curr = curr.left;
    }
    curr = stack.pop();
    if (--k === 0) return curr.val; // 第 k 个出栈的就是答案
    curr = curr.right;
  }
}
```

**复杂度：** 时间 O(H + k)，空间 O(H)

### 核心洞察

**中序遍历的第 k 个元素 = BST 中第 k 小。** 迭代中序遍历可以在找到答案时提前终止，无需遍历整棵树。

---

## 13. 从前序与中序遍历构造二叉树 (LC 105)

> **Medium** | 核心考点：分治递归 | ⭐⭐⭐⭐⭐

### 题目

给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是前序遍历，`inorder` 是中序遍历，请构造并返回二叉树。

```
输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出：[3,9,20,null,null,15,7]
```

### 思路

1. 前序的第一个元素是根
2. 在中序中找到根的位置，左边是左子树，右边是右子树
3. 递归构造左右子树

### 实现

```javascript
function buildTree(preorder, inorder) {
  const inMap = new Map();
  inorder.forEach((val, idx) => inMap.set(val, idx)); // O(1) 查找根在中序中的位置

  let preIdx = 0;

  const build = (inLeft, inRight) => {
    if (inLeft > inRight) return null;

    const rootVal = preorder[preIdx++];
    const root = new TreeNode(rootVal);
    const inIdx = inMap.get(rootVal); // 根在中序中的位置

    root.left = build(inLeft, inIdx - 1); // 左子树
    root.right = build(inIdx + 1, inRight); // 右子树

    return root;
  };

  return build(0, inorder.length - 1);
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**前序定根，中序定界。** 前序告诉你"根是谁"，中序告诉你"左右子树的范围"。两个信息互补，递归构造。哈希表预处理中序位置把查找从 O(n) 优化到 O(1)。

---

## 14. 二叉树展开为链表 (LC 114)

> **Medium** | 核心考点：前序变形 | ⭐⭐⭐⭐

### 题目

给你二叉树的根结点 `root`，请你将它展开为一个单链表：展开后的单链表应该使用 TreeNode，其中 `right` 子指针指向下一个节点，`left` 指针始终为 `null`。展开后的顺序应该与前序遍历一致。

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

### 思路

**寻找前驱法（O(1) 空间）**：对每个节点，找到左子树的最右节点（前序遍历中左子树的最后一个），把右子树接到该节点后面，然后把左子树移到右边。

### 实现

```javascript
function flatten(root) {
  let curr = root;
  while (curr) {
    if (curr.left) {
      // 找左子树的最右节点（前驱）
      let predecessor = curr.left;
      while (predecessor.right) predecessor = predecessor.right;

      predecessor.right = curr.right; // 右子树接到前驱后面
      curr.right = curr.left; // 左子树移到右边
      curr.left = null; // 清空左指针
    }
    curr = curr.right; // 前进到下一个
  }
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**找前驱是将树"拉平"的关键。** 左子树最右节点是前序中左子树的最后一个——把右子树接在它后面，就把"右子树"放到了正确的前序位置。这和 Morris 遍历的思想相通。

---

## 15. 二叉树的最大路径和 (LC 124)

> **Hard** | 核心考点：后序 + 全局变量 | ⭐⭐⭐⭐⭐

### 题目

二叉树中的**路径**被定义为沿父节点-子节点连接的某些节点序列。路径中至少包含一个节点，且不一定经过根节点。**路径和**是路径中各节点值的总和。给你一个二叉树的根节点 `root`，返回其最大路径和。

```
输入：root = [-10,9,20,null,null,15,7]
输出：42（路径 15 → 20 → 7）
```

### 实现

```javascript
function maxPathSum(root) {
  let maxSum = -Infinity;

  const dfs = (node) => {
    if (!node) return 0;
    // 左右子树的最大贡献值（负贡献直接丢弃）
    const left = Math.max(0, dfs(node.left));
    const right = Math.max(0, dfs(node.right));

    // 经过当前节点的最大路径和（可能是全局最大）
    maxSum = Math.max(maxSum, node.val + left + right);

    // 返回当前节点能向父节点贡献的最大值（只能选一条路）
    return node.val + Math.max(left, right);
  };

  dfs(root);
  return maxSum;
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**"经过当前节点的路径"和"向父节点的贡献"是两个不同的量。** 经过当前节点取左+右+自身（更新全局最大值），但向父节点只能贡献一条路径（选左或右中更大的）。这种"双重语义"是此题的难点，也是"后序+全局变量"模式的经典应用。

---

## 16. 二叉树的序列化与反序列化 (LC 297)

> **Hard** | 核心考点：前序/层序 | ⭐⭐⭐⭐

### 题目

设计一个算法将二叉树**序列化**为字符串，并能将字符串**反序列化**为原始二叉树。

### 实现

```javascript
function serialize(root) {
  const result = [];
  const dfs = (node) => {
    if (!node) {
      result.push("null");
      return;
    }
    result.push(String(node.val));
    dfs(node.left);
    dfs(node.right);
  };
  dfs(root);
  return result.join(",");
}

function deserialize(data) {
  const nodes = data.split(",");
  let idx = 0;

  const dfs = () => {
    if (nodes[idx] === "null") {
      idx++;
      return null;
    }
    const node = new TreeNode(Number(nodes[idx++]));
    node.left = dfs();
    node.right = dfs();
    return node;
  };
  return dfs();
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**前序遍历 + null 标记 = 完整的树结构信息。** 只有前序或中序无法唯一确定树（需要两种遍历），但加上 null 标记后前序就足够了——因为 null 精确地标记了子树的边界。

---

## 17. 二叉树的锯齿形层序遍历 (LC 103)

> **Medium** | 核心考点：BFS + 方向 | ⭐⭐⭐⭐

### 题目

给你二叉树的根节点 `root`，返回其节点值的**锯齿形层序遍历**（先从左往右，再从右往左交替进行）。

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

### 实现

```javascript
function zigzagLevelOrder(root) {
  if (!root) return [];
  const result = [],
    queue = [root];
  let leftToRight = true;

  while (queue.length) {
    const size = queue.length;
    const level = [];
    for (let i = 0; i < size; i++) {
      const node = queue.shift();
      level.push(node.val);
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    result.push(leftToRight ? level : level.reverse());
    leftToRight = !leftToRight; // 交替方向
  }
  return result;
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**锯齿形 = 层序遍历 + 偶数层反转。** 在标准 BFS 模板上加一个方向标志位即可。

---

## 18. 路径总和 (LC 112)

> **Easy** | 核心考点：DFS | ⭐⭐⭐⭐

### 题目

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum`，判断该树中是否存在**根节点到叶子节点**的路径，这条路径上所有节点值相加等于目标和。

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true（路径 5→4→11→2）
```

### 实现

```javascript
function hasPathSum(root, targetSum) {
  if (!root) return false;
  // 叶子节点：检查剩余值是否等于当前节点值
  if (!root.left && !root.right) return root.val === targetSum;
  // 递归：减去当前值，继续检查左右子树
  return (
    hasPathSum(root.left, targetSum - root.val) ||
    hasPathSum(root.right, targetSum - root.val)
  );
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**"做减法"比"做加法"更优雅。** 不传累积和，而是递减 targetSum，到叶子节点时只需判断是否等于节点值。减法免去了额外参数。

---

## 19. 路径总和 II (LC 113)

> **Medium** | 核心考点：DFS + 回溯 | ⭐⭐⭐⭐

### 题目

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum`，找出所有**从根节点到叶子节点**路径总和等于给定目标和的路径。

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

### 实现

```javascript
function pathSum(root, targetSum) {
  const result = [];

  const dfs = (node, remain, path) => {
    if (!node) return;
    path.push(node.val);

    if (!node.left && !node.right && remain === node.val) {
      result.push([...path]); // 找到一条路径，拷贝保存
    }

    dfs(node.left, remain - node.val, path);
    dfs(node.right, remain - node.val, path);
    path.pop(); // 回溯：撤销选择
  };

  dfs(root, targetSum, []);
  return result;
}
```

**复杂度：** 时间 O(n²)（最坏情况拷贝路径），空间 O(h)

### 核心洞察

**路径总和 II = 路径总和 + 回溯记录路径。** `path.pop()` 是回溯的标志——递归返回时撤销选择，保证路径只记录当前分支。`[...path]` 拷贝是必要的，因为 path 是引用类型。

---

## 20. 路径总和 III (LC 437)

> **Medium** | 核心考点：前缀和 + DFS | ⭐⭐⭐⭐

### 题目

给定一个二叉树的根节点 `root` 和一个整数 `targetSum`，求该二叉树里路径和等于 `targetSum` 的路径数目。路径不需要从根节点开始，也不需要在叶子节点结束，但方向必须向下。

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3（路径：5→3, 5→2→1, -3→11）
```

### 思路

**前缀和 + 哈希表（类似子数组和为 K）**

1. 维护从根到当前节点的前缀和 `currSum`
2. 如果存在某个祖先节点的前缀和 `prevSum` 使得 `currSum - prevSum === targetSum`，说明这段路径和为 target
3. 用哈希表记录所有前缀和的出现次数

### 实现

```javascript
function pathSum(root, targetSum) {
  const prefixMap = new Map([[0, 1]]); // 前缀和为 0 出现 1 次
  let count = 0;

  const dfs = (node, currSum) => {
    if (!node) return;
    currSum += node.val;

    // 检查是否存在 prefixSum 使得 currSum - prefixSum = targetSum
    count += prefixMap.get(currSum - targetSum) || 0;

    // 记录当前前缀和
    prefixMap.set(currSum, (prefixMap.get(currSum) || 0) + 1);

    dfs(node.left, currSum);
    dfs(node.right, currSum);

    // 回溯：离开当前节点时撤销前缀和记录
    prefixMap.set(currSum, prefixMap.get(currSum) - 1);
  };

  dfs(root, 0);
  return count;
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**树上的前缀和 = 数组前缀和 + 回溯。** 核心思想和"子数组和等于K"（LC 560）完全一样，唯一区别是树需要**回溯**——离开分支时撤销前缀和记录，因为不同分支的前缀和不共享。

---

## 21. 二叉搜索树的最近公共祖先 (LC 235)

> **Medium** | 核心考点：BST特性 | ⭐⭐⭐

### 题目

给定一个二叉搜索树，找到两个指定节点的最近公共祖先。

```
输入：root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出：6
```

### 实现

```javascript
function lowestCommonAncestor(root, p, q) {
  while (root) {
    if (p.val < root.val && q.val < root.val) {
      root = root.left; // 都在左子树
    } else if (p.val > root.val && q.val > root.val) {
      root = root.right; // 都在右子树
    } else {
      return root; // 分叉点就是 LCA
    }
  }
}
```

**复杂度：** 时间 O(h)，空间 O(1)

### 核心洞察

**BST 的有序性让 LCA 变成了方向选择。** 普通二叉树的 LCA 需要后序遍历（O(n)），BST 只需要沿着树走（O(h)）——利用 BST 性质判断 p 和 q 在同侧还是异侧。

---

## 22. 完全二叉树的节点个数 (LC 222)

> **Medium** | 核心考点：二分 + 位运算 | ⭐⭐⭐

### 题目

给你一棵**完全二叉树**的根节点 `root`，求出该树的节点个数。

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**进阶：** 能否设计 O(log²n) 的算法？

### 思路

完全二叉树：如果左右子树高度相同 → 左子树是满二叉树（节点数 `2^h - 1`）；否则右子树是上一层的满二叉树。

### 实现

```javascript
function countNodes(root) {
  if (!root) return 0;

  let leftH = 0,
    rightH = 0;
  let l = root,
    r = root;
  while (l) {
    leftH++;
    l = l.left;
  }
  while (r) {
    rightH++;
    r = r.right;
  }

  if (leftH === rightH) return (1 << leftH) - 1; // 满二叉树

  return 1 + countNodes(root.left) + countNodes(root.right);
}
```

**复杂度：** 时间 O(log²n)，空间 O(log n)

### 核心洞察

**利用"完全"的性质跳过一半的计算。** 每次递归只深入一侧，另一侧用公式直接算——每层只计算 O(log n) 的高度，共 O(log n) 层。

---

## 23. 填充每个节点的下一个右侧节点指针 (LC 116)

> **Medium** | 核心考点：BFS/递归 | ⭐⭐⭐

### 题目

给定一个**完美二叉树**，填充每个节点的 `next` 指针，让它指向其下一个右侧节点。如果找不到则设为 `null`。

### 实现

```javascript
function connect(root) {
  if (!root) return null;
  let leftmost = root;

  while (leftmost.left) {
    let curr = leftmost;
    while (curr) {
      curr.left.next = curr.right; // 同父节点的左→右
      if (curr.next) curr.right.next = curr.next.left; // 跨父节点的右→左
      curr = curr.next;
    }
    leftmost = leftmost.left; // 进入下一层
  }
  return root;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**利用已建立的 next 指针遍历同层。** 上一层的 next 连接让我们可以不用队列就能遍历同一层——用已解决的子问题帮助解决当前问题。

---

## 24. 不同的二叉搜索树 (LC 96)

> **Medium** | 核心考点：卡特兰数/DP | ⭐⭐⭐⭐

### 题目

给你一个整数 `n`，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的**二叉搜索树**有多少种？

```
输入：n = 3
输出：5
```

### 思路

**动态规划（卡特兰数）**：以 `i` 为根时，左子树 `i-1` 个节点，右子树 `n-i` 个节点。`G(n) = Σ G(i-1) × G(n-i)` for `i = 1..n`。

### 实现

```javascript
function numTrees(n) {
  const dp = new Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;

  for (let i = 2; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
      dp[i] += dp[j - 1] * dp[i - j]; // 左子树 × 右子树
    }
  }
  return dp[n];
}
```

**复杂度：** 时间 O(n²)，空间 O(n)

### 核心洞察

**结构计数 = 笛卡尔积。** 以每个值为根，左右子树互相独立——方案数是乘法关系。这就是卡特兰数的第 n 项：`C(n) = C(2n, n) / (n+1)`。

---

## 25. 不同的二叉搜索树 II (LC 95)

> **Medium** | 核心考点：递归构造 | ⭐⭐⭐

### 题目

给你一个整数 `n`，请你生成并返回所有由 `n` 个节点组成的、值从 `1` 到 `n` 互不相同的不同**二叉搜索树**。

### 实现

```javascript
function generateTrees(n) {
  const build = (start, end) => {
    if (start > end) return [null];
    const trees = [];
    for (let i = start; i <= end; i++) {
      const lefts = build(start, i - 1);
      const rights = build(i + 1, end);
      for (const l of lefts) {
        for (const r of rights) {
          const root = new TreeNode(i);
          root.left = l;
          root.right = r;
          trees.push(root);
        }
      }
    }
    return trees;
  };
  return build(1, n);
}
```

**复杂度：** 时间 O(4^n / n^(3/2))（卡特兰数），空间同

### 核心洞察

**LC 96 的"计数"变成了"枚举"。** 从乘法计数到笛卡尔积枚举——结构相同，只是从数字变成了实际构造。

---

## 26. 平衡二叉树 (LC 110)

> **Easy** | 核心考点：递归判断 | ⭐⭐⭐⭐

### 题目

给定一个二叉树，判断它是否是**高度平衡**的（每个节点的左右子树的高度差不超过 1）。

### 实现

```javascript
function isBalanced(root) {
  const height = (node) => {
    if (!node) return 0;
    const left = height(node.left);
    if (left === -1) return -1; // 左子树不平衡，剪枝
    const right = height(node.right);
    if (right === -1) return -1; // 右子树不平衡，剪枝
    if (Math.abs(left - right) > 1) return -1; // 当前不平衡
    return 1 + Math.max(left, right);
  };
  return height(root) !== -1;
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**用 -1 作为"不平衡"的哨兵值。** 一旦发现不平衡就提前返回 -1，避免无意义的计算——这是自底向上的剪枝策略。

---

## 27. 二叉树的最小深度 (LC 111)

> **Easy** | 核心考点：BFS更优 | ⭐⭐⭐

### 题目

给定一个二叉树，找出其最小深度（根节点到最近叶子节点的最短路径上的节点数量）。

### 实现

```javascript
function minDepth(root) {
  if (!root) return 0;
  // BFS：第一个遇到的叶子节点就是最小深度
  const queue = [[root, 1]];
  while (queue.length) {
    const [node, depth] = queue.shift();
    if (!node.left && !node.right) return depth; // 叶子节点
    if (node.left) queue.push([node.left, depth + 1]);
    if (node.right) queue.push([node.right, depth + 1]);
  }
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**最小深度用 BFS 比 DFS 更优。** BFS 逐层扫描，第一个叶子节点一定是最浅的——无需遍历整棵树。DFS 必须遍历全部才能确认最小值。

---

## 28. 求根节点到叶节点数字之和 (LC 129)

> **Medium** | 核心考点：DFS | ⭐⭐⭐

### 题目

给你一个二叉树的根节点 `root`，树中每个节点都存放有 0-9 的数字。每条根到叶子路径代表一个数字，返回所有数字之和。

```
输入：root = [1,2,3]
输出：25（12 + 13 = 25）
```

### 实现

```javascript
function sumNumbers(root) {
  const dfs = (node, num) => {
    if (!node) return 0;
    num = num * 10 + node.val;
    if (!node.left && !node.right) return num; // 叶子节点返回完整数字
    return dfs(node.left, num) + dfs(node.right, num);
  };
  return dfs(root, 0);
}
```

**复杂度：** 时间 O(n)，空间 O(h)

### 核心洞察

**`num * 10 + node.val` 是十进制数的递归构造公式。** 每往下一层，当前数字左移一位（×10）再加上新位。到叶子节点时自然形成完整数字。

---

## 29. 从中序与后序遍历构造二叉树 (LC 106)

> **Medium** | 核心考点：分治 | ⭐⭐⭐⭐

### 题目

给定两个整数数组 `inorder` 和 `postorder`，构造并返回二叉树。

```
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

### 实现

```javascript
function buildTree(inorder, postorder) {
  const inMap = new Map();
  inorder.forEach((val, idx) => inMap.set(val, idx));
  let postIdx = postorder.length - 1;

  const build = (inLeft, inRight) => {
    if (inLeft > inRight) return null;
    const rootVal = postorder[postIdx--]; // 后序的最后一个是根
    const root = new TreeNode(rootVal);
    const inIdx = inMap.get(rootVal);
    root.right = build(inIdx + 1, inRight); // 先右！（后序是左右根，逆序取是根右左）
    root.left = build(inLeft, inIdx - 1);
    return root;
  };

  return build(0, inorder.length - 1);
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**后序定根（最后一个），中序定界。** 与 LC 105 对称——唯一区别是逆序取后序数组，且必须**先构造右子树再构造左子树**（因为后序倒着取是根→右→左）。

---

## 30. 二叉搜索树迭代器 (LC 173)

> **Medium** | 核心考点：中序迭代 | ⭐⭐⭐

### 题目

实现一个二叉搜索树迭代器类 `BSTIterator`，表示一个按中序遍历顺序访问 BST 的迭代器。`next()` 返回下一个最小值，`hasNext()` 判断是否还有节点。

### 实现

```javascript
class BSTIterator {
  constructor(root) {
    this.stack = [];
    this._pushLeft(root); // 初始化：压入最左路径
  }

  next() {
    const node = this.stack.pop();
    this._pushLeft(node.right); // 转向右子树
    return node.val;
  }

  hasNext() {
    return this.stack.length > 0;
  }

  _pushLeft(node) {
    while (node) {
      this.stack.push(node);
      node = node.left;
    }
  }
}
```

**复杂度：** next() 均摊 O(1)，空间 O(h)

### 核心洞察

**把中序迭代遍历"拆散"成按需调用。** 每次 `next()` 只处理一个节点——弹出栈顶，压入右子树的最左路径。这就是中序迭代遍历的"暂停/恢复"版本。

---

## 31. 将有序数组转换为二叉搜索树 (LC 108)

> **Easy** | 核心考点：分治构造 | ⭐⭐⭐⭐

### 题目

给你一个按照**升序排列**的整数数组 `nums`，将其转换为一棵**高度平衡**的二叉搜索树。

```
输入：nums = [-10, -3, 0, 5, 9]
输出：[0, -3, 9, -10, null, 5]
```

### 实现

```javascript
function sortedArrayToBST(nums) {
  const build = (left, right) => {
    if (left > right) return null;
    const mid = (left + right) >> 1; // 取中间元素作为根
    const root = new TreeNode(nums[mid]);
    root.left = build(left, mid - 1); // 左半段构造左子树
    root.right = build(mid + 1, right); // 右半段构造右子树
    return root;
  };
  return build(0, nums.length - 1);
}
```

**复杂度：** 时间 O(n)，空间 O(log n)

### 核心洞察

**有序数组的中间元素天然是 BST 的根。** 二分取中点保证了左右子树大小尽可能相等——这就是"高度平衡"的来源。分治的每一层都在重复同一个决策：取中间值为根，左右递归。
