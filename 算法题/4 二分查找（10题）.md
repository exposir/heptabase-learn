<!--
- [INPUT]: LeetCode 二分查找高频题
- [OUTPUT]: 题目清单、难度分级、核心考点与完整题解
- [POS]: 算法题模块 - 二分查找
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 四、二分查找（10题）

| 序号 | 题目名称                                         | 难度   | 核心考点    | 优先级     |
| :--- | :----------------------------------------------- | :----- | :---------- | :--------- |
| 69   | **二分查找 (LC 704)**                            | Easy   | 基础模板    | ⭐⭐⭐⭐⭐ |
| 70   | **搜索旋转排序数组 (LC 33)**                     | Medium | 二分变形    | ⭐⭐⭐⭐⭐ |
| 71   | **寻找旋转排序数组中的最小值 (LC 153)**          | Medium | 二分边界    | ⭐⭐⭐⭐   |
| 72   | **在排序数组中查找第一个和最后一个位置 (LC 34)** | Medium | 左右边界    | ⭐⭐⭐⭐⭐ |
| 73   | **搜索二维矩阵 (LC 74)**                         | Medium | 展开二分    | ⭐⭐⭐⭐   |
| 74   | **搜索二维矩阵 II (LC 240)**                     | Medium | 右上角出发  | ⭐⭐⭐⭐   |
| 75   | **寻找两个正序数组的中位数 (LC 4)**              | Hard   | 二分 + 数学 | ⭐⭐⭐⭐⭐ |
| 76   | **搜索插入位置 (LC 35)**                         | Easy   | 左边界二分  | ⭐⭐⭐⭐   |
| 77   | **寻找峰值 (LC 162)**                            | Medium | 二分变形    | ⭐⭐⭐⭐   |
| 78   | **有效的完全平方数 (LC 367)**                    | Easy   | 二分        | ⭐⭐⭐     |

---

## 1. 二分查找 (LC 704)

### 题目

给定一个 `n` 个元素**有序（升序）**的整型数组 `nums` 和一个目标值 `target`，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

```
输入：nums = [-1, 0, 3, 5, 9, 12], target = 9
输出：4
解释：9 出现在 nums 中并且下标为 4

输入：nums = [-1, 0, 3, 5, 9, 12], target = 2
输出：-1
解释：2 不存在 nums 中因此返回 -1
```

**约束：** `1 ≤ nums.length ≤ 10⁴`，所有元素互不相同，`nums` 已按升序排列

### 思路

**经典闭区间二分模板 `[left, right]`**

1. 初始化 `left = 0, right = n - 1`（搜索区间为闭区间）
2. 循环条件 `left <= right`（搜索区间非空时继续）
3. 取中点 `mid = left + ((right - left) >> 1)`（防溢出）
4. `nums[mid] === target` → 找到，返回 `mid`
5. `nums[mid] < target` → 目标在右半段，`left = mid + 1`
6. `nums[mid] > target` → 目标在左半段，`right = mid - 1`
7. 循环结束仍未找到 → 返回 `-1`

**为什么用 `left + ((right - left) >> 1)` 而不是 `(left + right) / 2`？**

- 防止 `left + right` 整数溢出（JS 中安全整数范围大，但这是好习惯）
- 位运算 `>> 1` 比除法更快

### 实现

```javascript
function search(nums, target) {
  let left = 0,
    right = nums.length - 1;

  // 闭区间 [left, right]，区间非空时搜索
  while (left <= right) {
    // 防溢出的中点计算
    const mid = left + ((right - left) >> 1);

    if (nums[mid] === target) {
      return mid; // 找到目标
    } else if (nums[mid] < target) {
      left = mid + 1; // 目标在右半段，收缩左边界
    } else {
      right = mid - 1; // 目标在左半段，收缩右边界
    }
  }
  return -1; // 搜索区间为空，目标不存在
}
```

**复杂度：** 时间 O(log n)，空间 O(1)

### 核心洞察

**二分查找的本质是"每次排除一半搜索空间"。** 正确性的关键在于三个一致性：初始化、循环条件、边界更新必须匹配同一种区间定义（闭区间或左闭右开）。搞混区间定义是99%二分bug的来源。

---

## 2. 搜索旋转排序数组 (LC 33)

### 题目

整数数组 `nums` 按升序排列，其中的值**互不相同**。在传递给函数之前，`nums` 在预先未知的某个下标 `k` 处进行了旋转（例如 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]`）。给你旋转后的数组 `nums` 和一个整数 `target`，如果 `target` 存在返回下标，否则返回 `-1`。**必须 O(log n)**。

```
输入：nums = [4, 5, 6, 7, 0, 1, 2], target = 0
输出：4

输入：nums = [4, 5, 6, 7, 0, 1, 2], target = 3
输出：-1

输入：nums = [1], target = 0
输出：-1
```

**约束：** `1 ≤ nums.length ≤ 5000`，值互不相同

### 思路

**二分 + 判断有序半段**

旋转数组的核心性质：以 `mid` 为界，左半段 `[left, mid]` 和右半段 `[mid, right]` **至少有一段是有序的**。

1. 计算 `mid`，判断哪半段是有序的
2. **如果左半段有序** `nums[left] <= nums[mid]`：
   - `target` 在 `[nums[left], nums[mid])` 范围内 → 去左半段
   - 否则 → 去右半段
3. **如果右半段有序** `nums[mid] <= nums[right]`：
   - `target` 在 `(nums[mid], nums[right]]` 范围内 → 去右半段
   - 否则 → 去左半段
4. 每次都是在**有序的那一段**里判断 target 是否在范围内，这样判断条件是确定的

### 实现

```javascript
function search(nums, target) {
  let left = 0,
    right = nums.length - 1;

  while (left <= right) {
    const mid = left + ((right - left) >> 1);

    if (nums[mid] === target) return mid;

    // 判断哪半段是有序的
    if (nums[left] <= nums[mid]) {
      // 左半段 [left, mid] 有序
      if (target >= nums[left] && target < nums[mid]) {
        right = mid - 1; // target 在有序的左半段中
      } else {
        left = mid + 1; // target 在右半段（可能无序）
      }
    } else {
      // 右半段 [mid, right] 有序
      if (target > nums[mid] && target <= nums[right]) {
        left = mid + 1; // target 在有序的右半段中
      } else {
        right = mid - 1; // target 在左半段（可能无序）
      }
    }
  }
  return -1;
}
```

**复杂度：** 时间 O(log n)，空间 O(1)

### 核心洞察

**在混乱中寻找有序。** 旋转数组不完全有序，但每次二分至少有一半是有序的——在有序的那半段里精确判断 target 是否在其中，这是唯一可以确定做出的判断。**不要试图在无序段里推理，而是在有序段里排除。**

---

## 3. 寻找旋转排序数组中的最小值 (LC 153)

### 题目

已知一个长度为 `n` 的数组，预先按照升序排列，经由 1 到 n 次旋转后得到。给你一个元素值**互不相同**的数组 `nums`，返回其中的最小元素。**必须 O(log n)**。

```
输入：nums = [3, 4, 5, 1, 2]
输出：1

输入：nums = [4, 5, 6, 7, 0, 1, 2]
输出：0

输入：nums = [11, 13, 15, 17]
输出：11（未旋转，最小值在开头）
```

**约束：** `n == nums.length`，`1 ≤ n ≤ 5000`，值互不相同

### 思路

**二分查找旋转点**

最小值就是旋转点。用 `nums[mid]` 和 `nums[right]` 比较：

1. `nums[mid] > nums[right]` → 旋转点（最小值）在 `mid` 右边 → `left = mid + 1`
2. `nums[mid] < nums[right]` → `mid` 可能是最小值或最小值在左边 → `right = mid`（不能 `mid-1`，因为 `mid` 可能就是答案）
3. 循环条件 `left < right`（不是 `<=`，因为最终 `left === right` 就是答案）

**为什么和 `right` 比而不是和 `left` 比？**

- 和 `left` 比无法区分 `[1,2,3,4,5]`（未旋转）和 `[2,3,4,5,1]`（旋转了）这两种情况
- 和 `right` 比始终能正确判断最小值在哪一侧

### 实现

```javascript
function findMin(nums) {
  let left = 0,
    right = nums.length - 1;

  while (left < right) {
    const mid = left + ((right - left) >> 1);

    if (nums[mid] > nums[right]) {
      // mid 在旋转点左侧的大值区域，最小值在 mid 右边
      left = mid + 1;
    } else {
      // mid 在旋转点右侧的小值区域（或未旋转）
      // mid 本身可能是最小值，所以 right = mid 而不是 mid - 1
      right = mid;
    }
  }
  // left === right，指向最小值
  return nums[left];
}
```

**复杂度：** 时间 O(log n)，空间 O(1)

### 核心洞察

**选择正确的比较对象决定了二分的正确性。** 与 `nums[right]` 比较能始终区分"最小值在左还是右"，而与 `nums[left]` 比较则不能。另一个关键是 `right = mid` 而非 `right = mid - 1`——因为 `mid` 可能就是答案，不能排除它。

---

## 4. 在排序数组中查找第一个和最后一个位置 (LC 34)

### 题目

给你一个按照**非递减顺序**排列的整数数组 `nums` 和一个目标值 `target`。请你找出给定目标值在数组中的**开始位置**和**结束位置**。如果数组中不存在目标值，返回 `[-1, -1]`。**必须 O(log n)**。

```
输入：nums = [5, 7, 7, 8, 8, 10], target = 8
输出：[3, 4]

输入：nums = [5, 7, 7, 8, 8, 10], target = 6
输出：[-1, -1]

输入：nums = [], target = 0
输出：[-1, -1]
```

**约束：** `0 ≤ nums.length ≤ 10⁵`，`nums` 非递减排列

### 思路

**两次二分：分别找左边界和右边界**

1. **左边界**：找第一个 `>= target` 的位置。当 `nums[mid] >= target` 时，`right = mid`（mid 可能就是答案）；否则 `left = mid + 1`
2. **右边界**：找最后一个 `<= target` 的位置。当 `nums[mid] <= target` 时，`left = mid`（mid 可能就是答案）；否则 `right = mid - 1`
3. 最后验证找到的位置是否确实等于 `target`

**统一模板（推荐）：** 把两种边界都转化为"找第一个 >= target 的位置"：

- 左边界 = 第一个 `>= target` 的位置
- 右边界 = 第一个 `>= target + 1` 的位置 - 1

### 实现

```javascript
function searchRange(nums, target) {
  const left = lowerBound(nums, target);
  // 左边界越界或不等于 target → 不存在
  if (left === nums.length || nums[left] !== target) return [-1, -1];
  // 右边界 = 第一个 > target 的位置 - 1
  const right = lowerBound(nums, target + 1) - 1;
  return [left, right];
}

// 查找第一个 >= target 的位置（左闭右开区间）
function lowerBound(nums, target) {
  let left = 0,
    right = nums.length; // 注意：右开区间

  while (left < right) {
    const mid = left + ((right - left) >> 1);
    if (nums[mid] < target) {
      left = mid + 1; // mid 太小，左边界在 mid 右边
    } else {
      right = mid; // mid >= target，mid 可能是答案
    }
  }
  return left; // left === right，第一个 >= target 的位置
}
```

**复杂度：** 时间 O(log n)，空间 O(1)

### 核心洞察

**所有二分边界问题都可以归结为 `lowerBound`（第一个 >= target 的位置）。** 左边界 = `lowerBound(target)`，右边界 = `lowerBound(target + 1) - 1`。掌握一个模板，解决所有边界问题——这就是"一法通，万法通"。

---

## 5. 搜索二维矩阵 (LC 74)

### 题目

给你一个满足下述两条属性的 `m × n` 整数矩阵：每行中的整数从左到右按非递减顺序排列；每行的第一个整数大于前一行的最后一个整数。给定整数 `target`，判断 `target` 是否在矩阵中。

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true

输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

**约束：** `1 ≤ m, n ≤ 100`，`-10⁴ ≤ matrix[i][j], target ≤ 10⁴`

### 思路

**展开为一维数组做二分**

矩阵的两个性质保证了把它"拉平"成一维数组后仍然是有序的。

1. 将矩阵视为长度为 `m × n` 的一维有序数组
2. 一维下标 `idx` 映射到二维：`row = Math.floor(idx / n)`, `col = idx % n`
3. 在这个"虚拟一维数组"上做标准二分

### 实现

```javascript
function searchMatrix(matrix, target) {
  const m = matrix.length,
    n = matrix[0].length;
  let left = 0,
    right = m * n - 1; // 将矩阵看作一维数组

  while (left <= right) {
    const mid = left + ((right - left) >> 1);
    // 一维下标 → 二维坐标
    const val = matrix[Math.floor(mid / n)][mid % n];

    if (val === target) {
      return true;
    } else if (val < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return false;
}
```

**复杂度：** 时间 O(log(m×n))，空间 O(1)

### 核心洞察

**维度是可以折叠和展开的。** 二维矩阵本质是一维数组的另一种视图。通过 `idx / n` 和 `idx % n` 的映射，你可以在不真正创建一维数组的情况下，用二分搜索"虚拟地"遍历它。**不要被维度吓到，降维是最强大的思维工具。**

---

## 6. 搜索二维矩阵 II (LC 240)

### 题目

编写一个高效的算法来搜索 `m × n` 矩阵 `matrix` 中的一个目标值 `target`。该矩阵具有以下特性：每行的元素从左到右升序排列；每列的元素从上到下升序排列。

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

**约束：** `1 ≤ m, n ≤ 300`，`-10⁹ ≤ matrix[i][j] ≤ 10⁹`

### 思路

**从右上角出发（阶梯搜索）**

这道题和 LC 74 不同：行和列各自有序，但**上一行末尾不一定小于下一行开头**，所以不能展开成一维数组。

1. 从**右上角** `(0, n-1)` 出发（或左下角 `(m-1, 0)`）
2. 当前值 `== target` → 找到
3. 当前值 `> target` → 当前列所有值都大于 target → 左移 `col--`
4. 当前值 `< target` → 当前行所有值都小于 target → 下移 `row++`
5. 越界则 target 不存在

**为什么选右上角？** 因为右上角可以做出明确的方向决策：向左变小，向下变大。而左上角两个方向都变大，无法排除。

### 实现

```javascript
function searchMatrix(matrix, target) {
  const m = matrix.length,
    n = matrix[0].length;
  let row = 0,
    col = n - 1; // 从右上角出发

  while (row < m && col >= 0) {
    const val = matrix[row][col];

    if (val === target) {
      return true;
    } else if (val > target) {
      col--; // 当前值太大，排除当前列，左移
    } else {
      row++; // 当前值太小，排除当前行，下移
    }
  }
  return false; // 越界，target 不存在
}
```

**复杂度：** 时间 O(m + n)，空间 O(1)

### 核心洞察

**选择正确的起点，让每一步都能排除一行或一列。** 右上角（或左下角）是唯一能做出明确方向决策的位置——向左变小，向下变大，形成类似二叉搜索树的结构。**起点的选择决定了算法的优雅性。**

---

## 7. 寻找两个正序数组的中位数 (LC 4)

### 题目

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的**中位数**。算法的时间复杂度应该为 `O(log(m+n))`。

```
输入：nums1 = [1, 3], nums2 = [2]
输出：2.0
解释：合并数组 = [1, 2, 3]，中位数 2

输入：nums1 = [1, 2], nums2 = [3, 4]
输出：2.5
解释：合并数组 = [1, 2, 3, 4]，中位数 (2 + 3) / 2 = 2.5
```

**约束：** `0 ≤ m, n ≤ 1000`，`1 ≤ m + n ≤ 2000`

### 思路

**在较短数组上二分，找到正确的分割位置**

1. 中位数将合并后的数组分成**等长的左右两半**
2. 设在 `nums1` 中取前 `i` 个，在 `nums2` 中取前 `j` 个，组成左半部分
3. 约束：`i + j = (m + n + 1) / 2`（向上取整保证左半可能多一个）
4. **正确分割条件**：`nums1[i-1] <= nums2[j]` 且 `nums2[j-1] <= nums1[i]`（左半最大值 <= 右半最小值）
5. 在较短的数组上二分 `i`，`j` 由 `i` 唯一确定

### 实现

```javascript
function findMedianSortedArrays(nums1, nums2) {
  // 确保 nums1 是较短的数组（在短数组上二分更快）
  if (nums1.length > nums2.length) {
    [nums1, nums2] = [nums2, nums1];
  }

  const m = nums1.length,
    n = nums2.length;
  const halfLen = (m + n + 1) >> 1; // 左半部分元素总数
  let left = 0,
    right = m; // 在 nums1 中二分

  while (left <= right) {
    const i = left + ((right - left) >> 1); // nums1 中取前 i 个
    const j = halfLen - i; // nums2 中取前 j 个

    // 边界处理：-Infinity / Infinity 表示取 0 个或全取
    const nums1Left = i === 0 ? -Infinity : nums1[i - 1];
    const nums1Right = i === m ? Infinity : nums1[i];
    const nums2Left = j === 0 ? -Infinity : nums2[j - 1];
    const nums2Right = j === n ? Infinity : nums2[j];

    if (nums1Left <= nums2Right && nums2Left <= nums1Right) {
      // 找到正确分割位置
      if ((m + n) % 2 === 1) {
        return Math.max(nums1Left, nums2Left); // 奇数：左半最大值
      } else {
        return (
          (Math.max(nums1Left, nums2Left) + Math.min(nums1Right, nums2Right)) /
          2
        ); // 偶数：两中值平均
      }
    } else if (nums1Left > nums2Right) {
      right = i - 1; // nums1 取多了，左移
    } else {
      left = i + 1; // nums1 取少了，右移
    }
  }
}
```

**复杂度：** 时间 O(log(min(m,n)))，空间 O(1)

### 核心洞察

**中位数问题的本质是"分割问题"。** 不需要真正合并两个数组，只要找到一个分割，使左半最大值 <= 右半最小值。在较短数组上二分分割位置，另一个数组的分割位置由总长度约束唯一确定。**从"找值"转换为"找分割"是解题的关键思维跳跃。**

---

## 8. 搜索插入位置 (LC 35)

### 题目

给定一个排序数组和一个目标值，在数组中找到目标值并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。**必须 O(log n)**。

```
输入：nums = [1, 3, 5, 6], target = 5
输出：2

输入：nums = [1, 3, 5, 6], target = 2
输出：1（应插入到下标 1）

输入：nums = [1, 3, 5, 6], target = 7
输出：4（应插入到末尾）
```

**约束：** `1 ≤ nums.length ≤ 10⁴`，`nums` 为无重复元素的升序排列数组

### 思路

**本质就是 `lowerBound`：找第一个 >= target 的位置**

- 如果 `target` 存在 → 返回它的位置
- 如果 `target` 不存在 → 返回它应该插入的位置（即第一个大于它的位置）
- 这两种情况恰好是 `lowerBound` 的语义

### 实现

```javascript
function searchInsert(nums, target) {
  let left = 0,
    right = nums.length; // 左闭右开

  while (left < right) {
    const mid = left + ((right - left) >> 1);

    if (nums[mid] < target) {
      left = mid + 1; // mid 太小，不可能是答案
    } else {
      right = mid; // mid >= target，可能是答案
    }
  }
  return left; // 第一个 >= target 的位置
}
```

**复杂度：** 时间 O(log n)，空间 O(1)

### 核心洞察

**"搜索插入位置"就是 `lowerBound` 的另一个名字。** 很多看似不同的二分问题本质上都是在问同一个问题：第一个满足某个条件的位置在哪？认出这个本质，代码就只有一个模板。

---

## 9. 寻找峰值 (LC 162)

### 题目

峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，返回**任何一个**即可。假设 `nums[-1] = nums[n] = -∞`。**必须 O(log n)**。

```
输入：nums = [1, 2, 3, 1]
输出：2
解释：3 是峰值元素，返回其索引 2

输入：nums = [1, 2, 1, 3, 5, 6, 4]
输出：5
解释：返回 1 或 5 均可（2 或 6 都是峰值）
```

**约束：** `1 ≤ nums.length ≤ 1000`，`nums[i] ≠ nums[i + 1]`（相邻元素不等）

### 思路

**二分 + 爬坡策略**

1. 关键观察：`nums[-1] = nums[n] = -∞`，所以数组从两端看一定是"上升"的 → **至少存在一个峰值**
2. 如果 `nums[mid] < nums[mid + 1]`：`mid` 右侧是上升趋势，右边一定有峰值 → `left = mid + 1`
3. 如果 `nums[mid] > nums[mid + 1]`：`mid` 可能是峰值或左边有峰值 → `right = mid`
4. 最终 `left === right` 就是峰值

**为什么可以二分？** 虽然数组不是全局有序的，但"存在性"保证了每次都可以向有峰值的一侧收缩。这是基于**存在性推理**的二分，而非基于有序性。

### 实现

```javascript
function findPeakElement(nums) {
  let left = 0,
    right = nums.length - 1;

  while (left < right) {
    const mid = left + ((right - left) >> 1);

    if (nums[mid] < nums[mid + 1]) {
      // mid 到 mid+1 是上升趋势 → 右边一定有峰值
      left = mid + 1;
    } else {
      // mid 到 mid+1 是下降趋势 → mid 可能是峰值，或左边有峰值
      right = mid;
    }
  }
  return left; // left === right，即峰值位置
}
```

**复杂度：** 时间 O(log n)，空间 O(1)

### 核心洞察

**二分不需要数组整体有序，只需要每次能排除一半。** 峰值问题中"两端为负无穷"的条件保证了上升方向一定有峰值——这个"存在性保证"替代了"有序性"成为二分的基础。**二分的本质不是有序，而是可判定性：每次能确定答案在哪一半。**

---

## 10. 有效的完全平方数 (LC 367)

### 题目

给你一个正整数 `num`，如果 `num` 是一个完全平方数，则返回 `true`，否则返回 `false`。**不能使用任何内置函数**（如 `sqrt`）。

```
输入：num = 16
输出：true（4 × 4 = 16）

输入：num = 14
输出：false
```

**约束：** `1 ≤ num ≤ 2³¹ - 1`

### 思路

**二分搜索平方根**

1. 在 `[1, num]` 范围内二分查找 `mid`，使得 `mid * mid === num`
2. `mid * mid < num` → `left = mid + 1`
3. `mid * mid > num` → `right = mid - 1`
4. `mid * mid === num` → 找到，返回 `true`
5. 优化上界：`right = Math.min(num, 46340)`（因为 `46340² < 2³¹ - 1 < 46341²`），或直接用 `num` 即可

### 实现

```javascript
function isPerfectSquare(num) {
  let left = 1,
    right = num;

  while (left <= right) {
    const mid = left + ((right - left) >> 1);
    const square = mid * mid;

    if (square === num) {
      return true; // 找到完全平方根
    } else if (square < num) {
      left = mid + 1; // mid 太小
    } else {
      right = mid - 1; // mid 太大
    }
  }
  return false; // 不存在整数平方根
}
```

**复杂度：** 时间 O(log n)，空间 O(1)

### 核心洞察

**二分查找不只适用于数组——任何具有单调性的函数都可以二分。** `f(x) = x²` 是单调递增函数，所以可以在定义域 `[1, num]` 上二分搜索。这道题揭示了二分的真正本质：**在单调函数上查找目标值。** 数组二分只是其中一个特例。
