<!--
- [INPUT]: LeetCode 数组与双指针高频题
- [OUTPUT]: 题目清单、难度分级、核心考点与完整题解
- [POS]: 算法题模块 - 数组与双指针
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 一、数组与双指针（19题）

| 序号 | 题目名称                          | 难度   | 核心考点          | 优先级     |
| :--- | :-------------------------------- | :----- | :---------------- | :--------- |
| 1    | **两数之和 (LC 1)**               | Easy   | 哈希表优化        | ⭐⭐⭐⭐⭐ |
| 2    | **三数之和 (LC 15)**              | Medium | 排序 + 双指针去重 | ⭐⭐⭐⭐⭐ |
| 3    | **盛最多水的容器 (LC 11)**        | Medium | 贪心 + 双指针     | ⭐⭐⭐⭐⭐ |
| 4    | **接雨水 (LC 42)**                | Hard   | 双指针/单调栈/DP  | ⭐⭐⭐⭐⭐ |
| 5    | **合并区间 (LC 56)**              | Medium | 排序 + 区间合并   | ⭐⭐⭐⭐⭐ |
| 6    | **下一个排列 (LC 31)**            | Medium | 找规律、边界处理  | ⭐⭐⭐⭐   |
| 7    | **移动零 (LC 283)**               | Easy   | 双指针原地操作    | ⭐⭐⭐⭐⭐ |
| 8    | **轮转数组 (LC 189)**             | Medium | 三次反转/环形替换 | ⭐⭐⭐⭐   |
| 9    | **除自身以外数组的乘积 (LC 238)** | Medium | 前缀积 + 后缀积   | ⭐⭐⭐⭐⭐ |
| 10   | **缺失的第一个正数 (LC 41)**      | Hard   | 原地哈希          | ⭐⭐⭐⭐   |
| 11   | **螺旋矩阵 (LC 54)**              | Medium | 模拟边界          | ⭐⭐⭐⭐   |
| 12   | **矩阵置零 (LC 73)**              | Medium | 原地标记          | ⭐⭐⭐⭐   |
| 13   | **旋转图像 (LC 48)**              | Medium | 转置 + 翻转       | ⭐⭐⭐⭐⭐ |
| 14   | **颜色分类（荷兰国旗）(LC 75)**   | Medium | 三指针            | ⭐⭐⭐⭐   |
| 15   | **四数之和 (LC 18)**              | Medium | 多指针去重        | ⭐⭐⭐     |
| 16   | **最接近的三数之和 (LC 16)**      | Medium | 双指针            | ⭐⭐⭐     |
| 17   | **有序数组的平方 (LC 977)**       | Easy   | 双指针            | ⭐⭐⭐     |
| 18   | **比较含退格的字符串 (LC 844)**   | Easy   | 双指针/栈         | ⭐⭐⭐     |
| 19   | **长度最小的子数组 (LC 209)**     | Medium | 滑动窗口          | ⭐⭐⭐⭐   |

---

## 1. 两数之和 (LC 1)

### 题目

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出**和为目标值** `target` 的那**两个**整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，且同一个元素不能使用两遍。

```
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：nums[0] + nums[1] = 2 + 7 = 9

输入：nums = [3, 2, 4], target = 6
输出：[1, 2]
```

**约束：** `2 ≤ nums.length ≤ 10⁴`，`-10⁹ ≤ nums[i] ≤ 10⁹`，只存在一个有效答案。

### 思路

**暴力法 → 哈希表优化**

1. **暴力**：两层嵌套循环，对每个 `nums[i]`，遍历后续所有元素找 `target - nums[i]`。时间 O(n²)，空间 O(1)
2. **哈希表**：问题本质是"查找互补数"，查找速度决定了算法效率。用 Map 将查找从 O(n) 降到 O(1)
3. **一次遍历技巧**：边查边存——遍历到 `nums[i]` 时，先查表中是否有 `target - nums[i]`，有则直接返回；没有则将 `nums[i]` 存入表中等待后续匹配。这避免了两次遍历，也天然避免了"用自己匹配自己"的问题

### 实现

```javascript
function twoSum(nums, target) {
  // key: 数值, value: 下标
  const map = new Map();

  for (let i = 0; i < nums.length; i++) {
    // 计算当前元素的互补数
    const complement = target - nums[i];

    // 互补数已在表中 → 找到答案
    if (map.has(complement)) {
      return [map.get(complement), i];
    }

    // 互补数不在表中 → 存入当前元素，等待未来匹配
    map.set(nums[i], i);
  }
  // 题目保证有解，不会走到这里
}
```

**复杂度：** 时间 O(n)，空间 O(n)

### 核心洞察

**搜索问题的本质是数据结构的选择。** 暴力法用数组搜索 O(n)，哈希表搜索 O(1)——算法优化的第一课：不是写更快的循环，而是选更好的结构。"边查边存"的一次遍历模式，是哈希表类题目的通用范式。

---

## 2. 三数之和 (LC 15)

### 题目

给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i ≠ j`、`i ≠ k` 且 `j ≠ k`，同时还满足 `nums[i] + nums[j] + nums[k] == 0`。请你返回所有和为 `0` 且**不重复**的三元组。

```
输入：nums = [-1, 0, 1, 2, -1, -4]
输出：[[-1, -1, 2], [-1, 0, 1]]
解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0
      nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0
      nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0
      去重后得到 [[-1, -1, 2], [-1, 0, 1]]

输入：nums = [0, 0, 0]
输出：[[0, 0, 0]]
```

**约束：** `3 ≤ nums.length ≤ 3000`，`-10⁵ ≤ nums[i] ≤ 10⁵`

### 思路

**排序 + 固定一个数 + 双指针（降维思想）**

1. **排序**：先 `sort`，让数组有序。有序是双指针和去重的前提
2. **固定 `nums[i]`**：外层循环遍历，将三数之和降维为"在 `[i+1, n-1]` 中找两数之和 = `-nums[i]`"
3. **双指针夹逼**：`left = i+1`，`right = n-1`。`sum < 0` 说明太小，`left++`；`sum > 0` 说明太大，`right--`
4. **去重三处**：
   - 外层：`nums[i] === nums[i-1]` 时跳过（固定位去重）
   - 内层找到解后：连续跳过 `left` 和 `right` 的重复值
5. **剪枝**：`nums[i] > 0` 时直接 `break`（最小值已正，三数之和不可能为零）

### 实现

```javascript
function threeSum(nums) {
  nums.sort((a, b) => a - b); // 排序：O(n log n)
  const result = [];

  for (let i = 0; i < nums.length - 2; i++) {
    // 剪枝：最小值 > 0，后面不可能凑出零
    if (nums[i] > 0) break;

    // 去重：跳过固定位的重复值（i > 0 防越界）
    if (i > 0 && nums[i] === nums[i - 1]) continue;

    let left = i + 1,
      right = nums.length - 1;

    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];

      if (sum === 0) {
        result.push([nums[i], nums[left], nums[right]]);

        // 去重：跳过 left 和 right 的重复值
        while (left < right && nums[left] === nums[left + 1]) left++;
        while (left < right && nums[right] === nums[right - 1]) right--;

        // 双指针同时收缩
        left++;
        right--;
      } else if (sum < 0) {
        left++; // 和太小，左指针右移增大
      } else {
        right--; // 和太大，右指针左移减小
      }
    }
  }
  return result;
}
```

**复杂度：** 时间 O(n²)，空间 O(log n)（排序栈空间）

### 核心洞察

**排序是降维的利器。** 无序数组上的三数之和是 O(n³)，排序后双指针将内层从 O(n²) 压到 O(n)。去重不是事后用 Set 过滤，而是在遍历过程中**跳过重复值**——让非法状态不可达，比事后修补更优雅。

---

## 3. 盛最多水的容器 (LC 11)

### 题目

给定一个长度为 `n` 的整数数组 `height`，第 `i` 条线段的两个端点是 `(i, 0)` 和 `(i, height[i])`。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。

```
输入：height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
输出：49
解释：选择第 2 条（高度 8）和第 9 条（高度 7），宽度 = 7
      面积 = min(8, 7) × 7 = 49

输入：height = [1, 1]
输出：1
```

**约束：** `2 ≤ n ≤ 10⁵`，`0 ≤ height[i] ≤ 10⁴`

### 思路

**双指针 + 贪心（移动较短边）**

1. 两个指针 `left = 0`、`right = n-1`，从两端开始
2. 面积公式：`area = min(height[left], height[right]) × (right - left)`
3. **关键决策：移动哪个指针？** 移动较短的一边。数学证明：
   - 面积受限于短板（`min` 取较小值）
   - 无论移动哪边，宽度 `(right - left)` 都会减少 1
   - 移动较长边：短板不变或变更短，面积**必然缩小**
   - 移动较短边：短板**可能变高**，面积有机会更大
   - 因此移动较长边不可能产生更优解，可以安全**淘汰**
4. 每次计算面积并更新最大值，直到两指针相遇

### 实现

```javascript
function maxArea(height) {
  let left = 0,
    right = height.length - 1;
  let max = 0;

  while (left < right) {
    // 计算当前容器面积
    const h = Math.min(height[left], height[right]);
    const w = right - left;
    max = Math.max(max, h * w);

    // 贪心：移动较短边，保留较长边寻求更大面积
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  return max;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**贪心的正确性来自"移动较长边必不优"的严格证明。** 面积受限于木桶的短板，移动长边不可能突破短板限制，所以每次淘汰短边不会错过全局最优。这不是启发式猜测，而是对搜索空间的**安全剪枝**——每一步都排除了不可能包含最优解的候选。

---

## 4. 接雨水 (LC 42)

### 题目

给定 `n` 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```
输入：height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
输出：6
解释：柱状图中可以接 6 个单位的雨水（用 █ 表示柱子，用 ░ 表示水）
      3       █
      2   █ ░ ░ ░ █ █ ░ █
      1 █ ░ █ █ █ █ █ █ █ █
      0 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─

输入：height = [4, 2, 0, 3, 2, 5]
输出：9
```

**约束：** `n ≤ 2 × 10⁴`，`0 ≤ height[i] ≤ 10⁵`

### 思路

**双指针法（最优解）**

核心公式：位置 `i` 的存水量 = `min(leftMax, rightMax) - height[i]`

1. 维护 `leftMax`（左侧历史最高）和 `rightMax`（右侧历史最高）
2. 双指针 `left`、`right` 从两端收缩
3. **关键推理：** 当 `height[left] < height[right]` 时：
   - `rightMax ≥ height[right] > height[left]`，所以 `rightMax` 一定不是瓶颈
   - 当前位置的存水量完全由 `leftMax` 决定：`water += leftMax - height[left]`
   - 反之亦然
4. 每次处理 `min` 一侧的指针，因为那侧的水位上限已经确定

**其他解法对比：**

| 方法                                     | 时间     | 空间     | 特点     |
| :--------------------------------------- | :------- | :------- | :------- |
| 暴力（逐列求 leftMax/rightMax）          | O(n²)    | O(1)     | 直观但慢 |
| 动态规划（预计算 leftMax/rightMax 数组） | O(n)     | O(n)     | 好理解   |
| 单调栈（横向按层计算）                   | O(n)     | O(n)     | 思路独特 |
| **双指针**                               | **O(n)** | **O(1)** | **最优** |

### 实现

```javascript
function trap(height) {
  let left = 0,
    right = height.length - 1;
  let leftMax = 0,
    rightMax = 0;
  let water = 0;

  while (left < right) {
    if (height[left] < height[right]) {
      // 左侧是瓶颈：rightMax >= height[right] > height[left]
      // 所以 min(leftMax, rightMax) = leftMax
      leftMax = Math.max(leftMax, height[left]);
      water += leftMax - height[left]; // leftMax >= height[left]，差值 >= 0
      left++;
    } else {
      // 右侧是瓶颈：同理
      rightMax = Math.max(rightMax, height[right]);
      water += rightMax - height[right];
      right--;
    }
  }
  return water;
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**当一侧的约束已经确定，另一侧的具体值不影响结果。** `height[left] < height[right]` 这个条件蕴含了 `leftMax ≤ rightMax` 的数学保证，使得我们可以只用 `leftMax` 计算左侧水位，彻底消除了对右侧信息的依赖。这就是为什么双指针能把 O(n) 空间的 DP 解法优化到 O(1)。

---

## 5. 合并区间 (LC 56)

### 题目

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

```
输入：intervals = [[1,3], [2,6], [8,10], [15,18]]
输出：[[1,6], [8,10], [15,18]]
解释：区间 [1,3] 和 [2,6] 重叠，合并为 [1,6]

输入：intervals = [[1,4], [4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 视为重叠（端点相等也算）
```

**约束：** `1 ≤ intervals.length ≤ 10⁴`，`intervals[i].length == 2`，`0 ≤ starti ≤ endi ≤ 10⁴`

### 思路

**排序 + 线性扫描**

1. **按起点排序**：排序后，如果两个区间重叠，它们一定是相邻的（不可能跳过中间的区间）
2. **重叠判断简化**：排序后只需检查 `intervals[i][0] ≤ last[1]`（当前区间的起点 ≤ 上一个区间的终点）
3. **合并操作**：取两个区间终点的最大值 `last[1] = max(last[1], intervals[i][1])`
4. **非重叠**：直接将当前区间加入结果

**为什么排序后重叠判断变简单？** 未排序时，判断两区间关系需要考虑包含、交叉、相离等四种情况。排序后起点有序，只剩一个不等式。

### 实现

```javascript
function merge(intervals) {
  // 按区间起点升序排序
  intervals.sort((a, b) => a[0] - b[0]);

  // 用第一个区间初始化结果
  const merged = [intervals[0]];

  for (let i = 1; i < intervals.length; i++) {
    const last = merged[merged.length - 1]; // 结果中最后一个区间
    const curr = intervals[i]; // 当前正在处理的区间

    if (curr[0] <= last[1]) {
      // 重叠：扩展右边界（取 max 处理包含关系，如 [1,6] 和 [2,3]）
      last[1] = Math.max(last[1], curr[1]);
    } else {
      // 不重叠：直接加入结果
      merged.push(curr);
    }
  }
  return merged;
}
```

**复杂度：** 时间 O(n log n)（排序），空间 O(log n)（排序栈空间）

### 核心洞察

**排序将二维判断降为一维比较。** 未排序时判断重叠需要穷举多种位置关系，排序后只需一个不等式 `curr.start ≤ last.end`。好的预处理让后续的分支逻辑消失——让特殊情况在排序中自然融入常规。

---

## 6. 下一个排列 (LC 31)

### 题目

整数数组的一个**排列**就是将其所有成员以序列或线性顺序排列。实现获取下一个排列的函数，将数字重新排列成字典序中**下一个更大**的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须**原地**修改，只允许使用额外常数空间。

```
输入：nums = [1, 2, 3]
输出：[1, 3, 2]

输入：nums = [3, 2, 1]
输出：[1, 2, 3]（已是最大排列，变为最小）

输入：nums = [1, 1, 5]
输出：[1, 5, 1]

输入：nums = [1, 3, 5, 4, 2]  →  [1, 4, 2, 3, 5]
解释：
  Step 1: 从右往左找第一个 nums[i] < nums[i+1] → i=1 (nums[1]=3)
  Step 2: 从右往左找第一个 > 3 的数 → j=3 (nums[3]=4)，交换 → [1, 4, 5, 3, 2]
  Step 3: 反转 i+1 到末尾 → [1, 4, 2, 3, 5]
```

**约束：** `1 ≤ nums.length ≤ 100`，`0 ≤ nums[i] ≤ 100`

### 思路

**三步法（找规律 + 边界处理）**

1. **Step 1 — 找拐点**：从右往左找第一个 `nums[i] < nums[i+1]` 的位置。这个 `i` 就是需要"变大"的最低位。`i` 右边是**降序**（已是局部最大排列）
2. **Step 2 — 找替换**：从右往左找第一个 `nums[j] > nums[i]` 的数，交换它们。这保证了增量最小（取刚好大于 `nums[i]` 的值）
3. **Step 3 — 反转后缀**：将 `i+1` 到末尾反转（降序→升序），让后缀取最小值
4. **边界**：如果 Step 1 中 `i < 0`，说明整个数组是降序（最大排列），直接反转整体变成升序（最小排列）

### 实现

```javascript
function nextPermutation(nums) {
  let i = nums.length - 2;

  // Step 1: 从右往左找第一个"升序位置"（拐点）
  // 跳过所有 nums[i] >= nums[i+1] 的位置（降序区域）
  while (i >= 0 && nums[i] >= nums[i + 1]) i--;

  if (i >= 0) {
    // Step 2: 从右往左找第一个比 nums[i] 大的数
    let j = nums.length - 1;
    while (nums[j] <= nums[i]) j--;
    // 交换：让拐点位取到最小增量
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }

  // Step 3: 反转 i+1 到末尾（降序→升序，取后缀最小排列）
  let left = i + 1,
    right = nums.length - 1;
  while (left < right) {
    [nums[left], nums[right]] = [nums[right], nums[left]];
    left++;
    right--;
  }
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**字典序的本质是"尽可能少地改变高位"。** 从右向左找第一个可增大的位（最低有效位），用最小的增量替换，剩余部分取最小排列——这三步精确地实现了"下一个"的语义。核心在于交换后右侧仍然是降序（因为交换不改变有序性），所以反转就能得到升序。

---

## 7. 移动零 (LC 283)

### 题目

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。必须在**不复制数组**的情况下原地操作。

```
输入：nums = [0, 1, 0, 3, 12]
输出：[1, 3, 12, 0, 0]

输入：nums = [0]
输出：[0]
```

**约束：** `1 ≤ nums.length ≤ 10⁴`，`-2³¹ ≤ nums[i] ≤ 2³¹ - 1`

### 思路

**快慢双指针（分区思想）**

1. `slow` 指针：维护"下一个非零元素应该放的位置"
2. `fast` 指针：扫描整个数组
3. 当 `nums[fast] ≠ 0` 时，交换 `nums[slow]` 和 `nums[fast]`，然后 `slow++`
4. **不变量**：`[0, slow)` 全是非零元素，`[slow, fast)` 全是零
5. 交换而非赋值：保证零被自然推到后面，无需单独填充

**为什么不用赋值？** 如果用 `nums[slow] = nums[fast]` 再手动填零，需要两趟。交换只需一趟，且天然维护了"零在后面"的性质。

### 实现

```javascript
function moveZeroes(nums) {
  let slow = 0; // 下一个非零元素的目标位置

  for (let fast = 0; fast < nums.length; fast++) {
    if (nums[fast] !== 0) {
      // 将非零元素交换到 slow 位置
      // 当 slow === fast 时交换自己，无副作用
      [nums[slow], nums[fast]] = [nums[fast], nums[slow]];
      slow++;
    }
    // nums[fast] === 0 时跳过，零留在原地等待被交换到后面
  }
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**双指针的哲学是"分区"。** `slow` 左边全是非零，`slow` 到 `fast` 之间全是零——数组被隐式地分成了两个区域，无需额外空间。这和快排的 partition 是同一思想。简单到不可能出错的代码，才是最好的代码。

---

## 8. 轮转数组 (LC 189)

### 题目

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

```
输入：nums = [1, 2, 3, 4, 5, 6, 7], k = 3
输出：[5, 6, 7, 1, 2, 3, 4]
解释：
  向右轮转 1 步: [7, 1, 2, 3, 4, 5, 6]
  向右轮转 2 步: [6, 7, 1, 2, 3, 4, 5]
  向右轮转 3 步: [5, 6, 7, 1, 2, 3, 4]

输入：nums = [-1, -100, 3, 99], k = 2
输出：[3, 99, -1, -100]
```

**约束：** `1 ≤ nums.length ≤ 10⁵`，`-2³¹ ≤ nums[i] ≤ 2³¹ - 1`，`0 ≤ k ≤ 10⁵`

### 思路

**三次反转法**

右移 `k` 步的本质：把末尾 `k` 个元素搬到开头。三次反转巧妙实现了"块交换"：

```
原数组:      [1, 2, 3, 4, | 5, 6, 7]    k=3
Step 1 整体反转: [7, 6, 5, 4, 3, 2, 1]
Step 2 前k个反转: [5, 6, 7, | 4, 3, 2, 1]
Step 3 后n-k反转: [5, 6, 7, | 1, 2, 3, 4]  ✓
```

**为什么这能工作？** 全局反转把所有元素的相对位置颠倒，但前后两个块的内部顺序也被颠倒了。局部反转恢复各自块的内部顺序。

**注意：** `k` 可能大于数组长度，需要 `k %= n`。

### 实现

```javascript
function rotate(nums, k) {
  const n = nums.length;
  k %= n; // k = 10, n = 7 → 实际只需轮转 3 步

  if (k === 0) return; // 优化：无需轮转

  reverse(nums, 0, n - 1); // 整体反转
  reverse(nums, 0, k - 1); // 前 k 个反转
  reverse(nums, k, n - 1); // 后 n-k 个反转
}

// 反转数组 [start, end] 区间（原地、双指针）
function reverse(arr, start, end) {
  while (start < end) {
    [arr[start], arr[end]] = [arr[end], arr[start]];
    start++;
    end--;
  }
}
```

**复杂度：** 时间 O(n)，空间 O(1)

### 核心洞察

**反转是数组的"时间倒流"操作。** 三次反转的数学本质：全局反转把整体颠倒，局部反转在各自范围内恢复正确顺序。O(1) 空间、O(n) 时间——优雅到无法再简化。这里的关键直觉是：**反转两次 = 恢复原序**，三次反转 = 全局颠倒 + 两个局部恢复 = 块交换。

---

## 9. 除自身以外数组的乘积 (LC 238)

### 题目

给你一个整数数组 `nums`，返回数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。题目保证答案在 32 位整数范围内。**不能使用除法**，且要求 O(n) 时间。

```
输入：nums = [1, 2, 3, 4]
输出：[24, 12, 8, 6]
解释：answer[0] = 2×3×4 = 24
      answer[1] = 1×3×4 = 12
      answer[2] = 1×2×4 = 8
      answer[3] = 1×2×3 = 6

输入：nums = [-1, 1, 0, -3, 3]
输出：[0, 0, 9, 0, 0]
```

**约束：** `2 ≤ nums.length ≤ 10⁵`，`-30 ≤ nums[i] ≤ 30`，保证任意前缀或后缀乘积在 32 位整数内

### 思路

**前缀积 + 后缀积（两次遍历）**

1. `answer[i] = 左边所有数的乘积 × 右边所有数的乘积`
2. **第一遍（左→右）**：计算前缀积，`answer[i] = nums[0] × nums[1] × ... × nums[i-1]`
3. **第二遍（右→左）**：用一个变量 `suffix` 累积后缀积，`answer[i] *= suffix`
4. 两个方向的遍历共享 `answer` 数组，不需要额外的前缀/后缀数组

**为什么不用除法？**

- 除法遇到零会出错（除以零）
- 前缀积 × 后缀积的方法对零值完全免疫

### 实现

```javascript
function productExceptSelf(nums) {
  const n = nums.length;
  const answer = new Array(n);

  // 第一遍：从左到右，计算前缀积
  // answer[i] = nums[0] * nums[1] * ... * nums[i-1]
  answer[0] = 1; // 第 0 个元素左边没有数，前缀积为 1
  for (let i = 1; i < n; i++) {
    answer[i] = answer[i - 1] * nums[i - 1];
  }

  // 第二遍：从右到左，累乘后缀积
  // suffix 记录 nums[i+1] * nums[i+2] * ... * nums[n-1]
  let suffix = 1;
  for (let i = n - 2; i >= 0; i--) {
    suffix *= nums[i + 1]; // 更新后缀积
    answer[i] *= suffix; // 前缀积 × 后缀积 = 最终结果
  }

  return answer;
}
```

**复杂度：** 时间 O(n)，空间 O(1)（answer 数组不算额外空间）

### 核心洞察

**"不能用除法"的约束迫使你发现乘法的对称结构。** 每个位置的结果由左右两片独立乘积组成——这种"分而治之"的视角比除法更本质，也更通用（对零值免疫）。两次遍历共享输出数组的技巧，是"空间优化"的经典范式。

---

## 10. 缺失的第一个正数 (LC 41)

### 题目

给你一个未排序的整数数组 `nums`，请你找出其中没有出现的**最小的正整数**。请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

```
输入：nums = [1, 2, 0]
输出：3
解释：1 和 2 都在，缺少 3

输入：nums = [3, 4, -1, 1]
输出：2
解释：1 在，但 2 不在

输入：nums = [7, 8, 9, 11, 12]
输出：1
解释：最小正数 1 不在数组中
```

**约束：** `1 ≤ nums.length ≤ 5 × 10⁵`，`-2³¹ ≤ nums[i] ≤ 2³¹ - 1`

### 思路

**原地哈希（把数组当哈希表）**

1. **核心观察**：长度为 `n` 的数组，答案一定在 `[1, n+1]` 内。因为最多只有 `n` 个位置，即使 `1~n` 全存在，答案也只是 `n+1`
2. **哈希映射规则**：让数字 `k` 放在下标 `k-1` 处，即 `nums[i]` 应该等于 `i+1`
3. **遍历归位**：对每个 `nums[i]`，如果它在 `[1, n]` 范围内且不在正确位置，就不断交换到正确位置
4. **找缺失**：再遍历一次，第一个 `nums[i] ≠ i+1` 的位置就是答案
5. **防死循环**：如果目标位置已经有正确的值（重复数字），停止交换

### 实现

```javascript
function firstMissingPositive(nums) {
  const n = nums.length;

  // 第一遍：原地归位（哈希）
  for (let i = 0; i < n; i++) {
    // 当 nums[i] 在有效范围 [1, n] 内，且还没在正确位置时
    while (
      nums[i] > 0 && // 正数才需要归位
      nums[i] <= n && // 超出范围的忽略
      nums[nums[i] - 1] !== nums[i] // 目标位已正确则停止（防死循环/重复）
    ) {
      // 将 nums[i] 交换到下标 nums[i]-1 的位置
      const targetIdx = nums[i] - 1;
      [nums[targetIdx], nums[i]] = [nums[i], nums[targetIdx]];
    }
  }

  // 第二遍：找第一个不在位的数
  for (let i = 0; i < n; i++) {
    if (nums[i] !== i + 1) return i + 1;
  }

  // 1~n 全在，答案是 n+1
  return n + 1;
}
```

**复杂度：** 时间 O(n)（每个元素最多被交换一次到正确位置），空间 O(1)

### 核心洞察

**数组下标本身就是一个天然的哈希函数。** 当空间约束为 O(1) 时，你不能创建辅助结构，但你可以**重新定义数组的语义**——让数组从"存储数据"变成"记录存在性"。关键约束 `答案 ∈ [1, n+1]` 保证了数组有足够的位置做这件事。这是原地算法的终极哲学：不是没有空间，而是你已经有了。

---

## 11. 螺旋矩阵 (LC 54)

### 题目

给你一个 `m` 行 `n` 列的矩阵 `matrix`，请按照**顺时针螺旋顺序**，返回矩阵中的所有元素。

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
解释：→ → → ↓ ↓ ← ← ↑ 中心

输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**约束：** `1 ≤ m, n ≤ 10`，`-100 ≤ matrix[i][j] ≤ 100`

### 思路

**四边界收缩法**

1. 维护四个边界：`top`、`bottom`、`left`、`right`
2. 每轮按 → ↓ ← ↑ 四个方向遍历一圈，每走完一条边就**收缩对应边界**
3. **关键细节**：走完 → 和 ↓ 后，需要检查 `top <= bottom` 和 `left <= right`，否则 ← 和 ↑ 会重复遍历（非方阵时出现单行/单列）
4. 循环终止条件：`top > bottom || left > right`

### 实现

```javascript
function spiralOrder(matrix) {
  const result = [];
  let top = 0,
    bottom = matrix.length - 1;
  let left = 0,
    right = matrix[0].length - 1;

  while (top <= bottom && left <= right) {
    // → 向右：遍历上边界
    for (let i = left; i <= right; i++) result.push(matrix[top][i]);
    top++; // 上边界下移

    // ↓ 向下：遍历右边界
    for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);
    right--; // 右边界左移

    // ← 向左：遍历下边界（需检查是否还有下边界）
    if (top <= bottom) {
      for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);
      bottom--; // 下边界上移
    }

    // ↑ 向上：遍历左边界（需检查是否还有左边界）
    if (left <= right) {
      for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);
      left++; // 左边界右移
    }
  }
  return result;
}
```

**复杂度：** 时间 O(m×n)，空间 O(1)

### 核心洞察

**边界收缩将"螺旋"这个看似复杂的路径变成了四段直线的重复。** 关键在于内侧两段（←和↑）需要额外的边界检查——因为外侧收缩后可能已经没有内侧了（如单行或单列矩阵）。模拟题的核心不是算法，而是**正确建模**和处理边界。

---

## 12. 矩阵置零 (LC 73)

### 题目

给定一个 `m × n` 的矩阵，如果一个元素为 `0`，则将其所在行和列的所有元素都设为 `0`。请使用**原地**算法。

```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]

输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

**约束：** `1 ≤ m, n ≤ 200`，`-2³¹ ≤ matrix[i][j] ≤ 2³¹ - 1`

**进阶：** 能否用 O(1) 额外空间？

### 思路

**原地标记法（用第一行/第一列做标记）**

1. **朴素思路**：用额外的行集合和列集合记录哪些行/列需要清零 → O(m+n) 空间
2. **O(1) 优化**：用矩阵**自身的第一行和第一列**作为标记数组
   - `matrix[i][0] = 0` 表示第 `i` 行需要清零
   - `matrix[0][j] = 0` 表示第 `j` 列需要清零
   - 额外用一个布尔变量 `firstColZero` 记录第一列本身是否需要清零（避免歧义）
3. **遍历顺序很重要**：清零时必须**从后往前**，否则第一行/第一列的标记会被提前覆盖

### 实现

```javascript
function setZeroes(matrix) {
  const m = matrix.length,
    n = matrix[0].length;
  let firstColZero = false; // 第一列是否需要清零

  // 阶段一：扫描并标记
  for (let i = 0; i < m; i++) {
    if (matrix[i][0] === 0) firstColZero = true; // 第一列有零
    for (let j = 1; j < n; j++) {
      // 注意 j 从 1 开始（第一列单独处理）
      if (matrix[i][j] === 0) {
        matrix[i][0] = 0; // 标记：第 i 行需要清零
        matrix[0][j] = 0; // 标记：第 j 列需要清零
      }
    }
  }

  // 阶段二：根据标记清零（从后往前，保护标记不被提前覆盖）
  for (let i = m - 1; i >= 0; i--) {
    for (let j = n - 1; j >= 1; j--) {
      if (matrix[i][0] === 0 || matrix[0][j] === 0) {
        matrix[i][j] = 0;
      }
    }
    // 最后处理第一列
    if (firstColZero) matrix[i][0] = 0;
  }
}
```

**复杂度：** 时间 O(m×n)，空间 O(1)

### 核心洞察

**矩阵的边缘是天然的元数据存储区。** 第一行/第一列本来就是矩阵的一部分，用它们存储标记信息实现了 O(1) 额外空间。清零时从后往前遍历——避免标记信息被提前覆盖。这种"自引用"技巧在原地算法中反复出现：**用数据本身记录关于数据的信息**。

---

## 13. 旋转图像 (LC 48)

### 题目

给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像，请你将图像顺时针旋转 90 度。你必须在**原地**旋转图像。

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]

输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**约束：** `n == matrix.length == matrix[i].length`，`1 ≤ n ≤ 20`

### 思路

**转置 + 水平翻转（分解复杂变换为简单操作）**

顺时针旋转 90° 可以分解为两步：

```
原矩阵           转置(行列互换)      水平翻转(左右镜像)
1 2 3       →     1 4 7       →      7 4 1
4 5 6             2 5 8              8 5 2
7 8 9             3 6 9              9 6 3
```

1. **转置**：沿主对角线交换，`matrix[i][j] ↔ matrix[j][i]`（只遍历上三角，`j > i`）
2. **水平翻转**：每行左右对称交换，`matrix[i][j] ↔ matrix[i][n-1-j]`（只遍历前半列）

**其他旋转方向：**

- 逆时针 90° = 转置 + 上下翻转
- 180° = 上下翻转 + 左右翻转

### 实现

```javascript
function rotate(matrix) {
  const n = matrix.length;

  // Step 1: 转置——沿主对角线交换（只遍历上三角）
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    }
  }

  // Step 2: 水平翻转——每行左右对称交换
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n >> 1; j++) {
      // n >> 1 = Math.floor(n/2)
      [matrix[i][j], matrix[i][n - 1 - j]] = [
        matrix[i][n - 1 - j],
        matrix[i][j],
      ];
    }
  }
}
```

**复杂度：** 时间 O(n²)，空间 O(1)

### 核心洞察

**复杂变换可以分解为简单变换的组合。** 旋转看似需要四点循环的复杂下标计算，但转置+翻转两步操作各自简单到不可能出错。分解的关键在于发现旋转的数学本质：旋转 = 转置 × 镜像。分解问题比直接解决问题更重要。

---

## 14. 颜色分类 / 荷兰国旗 (LC 75)

### 题目

给定一个包含红色、白色和蓝色（分别用 `0`、`1`、`2` 表示）的数组 `nums`，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。不能使用库内置的 `sort` 函数。

```
输入：nums = [2, 0, 2, 1, 1, 0]
输出：[0, 0, 1, 1, 2, 2]

输入：nums = [2, 0, 1]
输出：[0, 1, 2]
```

**约束：** `1 ≤ n ≤ 300`，`nums[i]` 为 `0`、`1` 或 `2`

**进阶：** 能否仅用一趟扫描完成？

### 思路

**三指针分区（荷兰国旗问题，Dijkstra 提出）**

1. 维护三个指针：`p0`（0区右边界）、`curr`（当前扫描位）、`p2`（2区左边界）
2. **不变量**：
   - `[0, p0)`：全是 0
   - `[p0, curr)`：全是 1
   - `(p2, end]`：全是 2
   - `[curr, p2]`：未处理
3. `curr` 遇到 0 → 与 `p0` 交换，`p0++`、`curr++`（从 p0 换来的一定是 1，已处理）
4. `curr` 遇到 2 → 与 `p2` 交换，`p2--`，**`curr` 不动**（从 p2 换来的值未检查，可能是 0）
5. `curr` 遇到 1 → 跳过，`curr++`

### 实现

```javascript
function sortColors(nums) {
  let p0 = 0; // 下一个 0 应放的位置
  let curr = 0; // 当前扫描位置
  let p2 = nums.length - 1; // 下一个 2 应放的位置

  while (curr <= p2) {
    if (nums[curr] === 0) {
      // 当前是 0：换到前面的 0 区
      [nums[p0], nums[curr]] = [nums[curr], nums[p0]];
      p0++; // 0 区扩展
      curr++; // p0 换来的一定是 1（已正确），可以前进
    } else if (nums[curr] === 2) {
      // 当前是 2：换到后面的 2 区
      [nums[p2], nums[curr]] = [nums[curr], nums[p2]];
      p2--; // 2 区扩展
      // curr 不动！从 p2 换来的可能是 0 或 2，还需要检查
    } else {
      // 当前是 1：已在正确区域，跳过
      curr++;
    }
  }
}
```

**复杂度：** 时间 O(n)（一趟扫描），空间 O(1)

### 核心洞察

**三分区的不变量是正确性的锚。** `curr` 遇到 2 交换后不前进——因为从 `p2` 换来的可能是 0，还需要继续处理。而遇到 0 交换后可以前进——因为 `p0 <= curr`，从 `p0` 换来的只可能是 1（已经过 `curr` 检查）。理解"何时前进，何时不前进"是这道题的核心。

---

## 15. 四数之和 (LC 18)

### 题目

给你一个由 `n` 个整数组成的数组 `nums` 和一个目标值 `target`，请你找出并返回满足条件的所有**不重复**的四元组。

```
输入：nums = [1, 0, -1, 0, -2, 2], target = 0
输出：[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]

输入：nums = [2, 2, 2, 2, 2], target = 8
输出：[[2, 2, 2, 2]]
```

**约束：** `1 ≤ nums.length ≤ 200`，`-10⁹ ≤ nums[i] ≤ 10⁹`，`-10⁹ ≤ target ≤ 10⁹`

### 思路

**排序 + 双层固定 + 双指针（三数之和的推广）**

1. 排序后，外层两个循环固定 `nums[i]` 和 `nums[j]`
2. 内层用双指针在 `[j+1, n-1]` 中找两数之和 = `target - nums[i] - nums[j]`
3. **去重**：每层循环跳过相邻重复值，找到解后也跳过重复的 left/right
4. **剪枝优化**（可选）：
   - 如果当前四个最小值之和 > target → `break`
   - 如果当前两个 + 两个最大值之和 < target → `continue`

### 实现

```javascript
function fourSum(nums, target) {
  nums.sort((a, b) => a - b);
  const result = [];
  const n = nums.length;

  for (let i = 0; i < n - 3; i++) {
    // 第一层去重
    if (i > 0 && nums[i] === nums[i - 1]) continue;

    for (let j = i + 1; j < n - 2; j++) {
      // 第二层去重
      if (j > i + 1 && nums[j] === nums[j - 1]) continue;

      let left = j + 1,
        right = n - 1;
      const remain = target - nums[i] - nums[j]; // 剩余两数之和目标

      while (left < right) {
        const sum = nums[left] + nums[right];
        if (sum === remain) {
          result.push([nums[i], nums[j], nums[left], nums[right]]);
          // 去重：跳过重复的 left 和 right
          while (left < right && nums[left] === nums[left + 1]) left++;
          while (left < right && nums[right] === nums[right - 1]) right--;
          left++;
          right--;
        } else if (sum < remain) {
          left++;
        } else {
          right--;
        }
      }
    }
  }
  return result;
}
```

**复杂度：** 时间 O(n³)，空间 O(log n)（排序）

### 核心洞察

**k-Sum 问题有统一的递归结构：排序 + 固定一个数 + 递归到 (k-1)-Sum。** 基础情况是 2-Sum 用双指针。这种"降维递归"模式可以推广到任意 k——5Sum、6Sum 只是多套一层循环而已。

---

## 16. 最接近的三数之和 (LC 16)

> 找出数组中三个数的和最接近 `target` 的值。

### 思路

与三数之和框架相同，区别在于不找精确解，而是维护一个 `closest` 记录当前最接近的和。

### 实现

```javascript
function threeSumClosest(nums, target) {
  nums.sort((a, b) => a - b);
  let closest = nums[0] + nums[1] + nums[2];

  for (let i = 0; i < nums.length - 2; i++) {
    let left = i + 1,
      right = nums.length - 1;
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      if (Math.abs(sum - target) < Math.abs(closest - target)) {
        closest = sum;
      }
      if (sum < target) left++;
      else if (sum > target) right--;
      else return target; // 差为 0，不可能更近
    }
  }
  return closest;
}
```

### 核心洞察

**"最接近"是"精确匹配"的泛化。** 精确匹配是差值为 0 的特殊情况，最接近则是在整个搜索过程中维护最小差值。同一框架通过改变比较条件就能解不同问题——这是抽象的力量。

---

## 17. 有序数组的平方 (LC 977)

> 给定非递减排序的数组，返回每个元素的平方组成的新数组，也要非递减排序。

### 思路

平方后最大值一定在数组两端（负数的绝对值可能很大）。双指针从两端比较绝对值，取大的放入结果数组**末尾**，逆向填充。

### 实现

```javascript
function sortedSquares(nums) {
  const n = nums.length;
  const result = new Array(n);
  let left = 0,
    right = n - 1,
    pos = n - 1;

  while (left <= right) {
    const leftSq = nums[left] * nums[left];
    const rightSq = nums[right] * nums[right];
    if (leftSq > rightSq) {
      result[pos] = leftSq;
      left++;
    } else {
      result[pos] = rightSq;
      right--;
    }
    pos--;
  }
  return result;
}
```

### 核心洞察

**有序性是宝贵的信息，不要丢弃它。** 先平方再排序是 O(n log n)，但利用输入的有序性，双指针可以 O(n) 合并。逆向填充是关键技巧——从最大值往最小值放，避免了正向填充的复杂分流。

---

## 18. 比较含退格的字符串 (LC 844)

> 给定两个字符串，`#` 代表退格，判断处理后两字符串是否相等。

### 思路（双指针，O(1) 空间）

从右往左遍历两个字符串。遇到 `#` 时计数器加 1（表示要跳过的字符数），遇到普通字符时如果计数器 > 0 就跳过，否则比较两个指针指向的字符。

### 实现

```javascript
function backspaceCompare(s, t) {
  let i = s.length - 1,
    j = t.length - 1;

  while (i >= 0 || j >= 0) {
    i = getNextValid(s, i);
    j = getNextValid(t, j);

    const charS = i >= 0 ? s[i] : "";
    const charT = j >= 0 ? t[j] : "";
    if (charS !== charT) return false;
    i--;
    j--;
  }
  return true;
}

function getNextValid(str, index) {
  let skip = 0;
  while (index >= 0) {
    if (str[index] === "#") {
      skip++;
      index--;
    } else if (skip > 0) {
      skip--;
      index--;
    } else {
      break;
    }
  }
  return index;
}
```

### 核心洞察

**退格操作是"反向"的，所以从右往左处理最自然。** 从左到右处理退格需要栈（O(n) 空间），但从右到左只需一个计数器——选择正确的遍历方向可以消除辅助数据结构。

---

## 19. 长度最小的子数组 (LC 209)

> 找出数组中满足和 ≥ target 的最短连续子数组长度。

### 思路（滑动窗口）

维护窗口 `[left, right]`，右边界扩展累加，当窗口内的和 ≥ target 时，记录长度并收缩左边界——寻找更短的满足条件的窗口。

### 实现

```javascript
function minSubArrayLen(target, nums) {
  let left = 0,
    sum = 0,
    minLen = Infinity;

  for (let right = 0; right < nums.length; right++) {
    sum += nums[right];
    while (sum >= target) {
      minLen = Math.min(minLen, right - left + 1);
      sum -= nums[left];
      left++;
    }
  }
  return minLen === Infinity ? 0 : minLen;
}
```

### 核心洞察

**滑动窗口的本质是"单调性剪枝"。** 因为数组元素全为正数，窗口右扩和必增，左缩和必减——这种单调性保证了 `left` 只需前进不需后退，每个元素最多进出窗口各一次，总复杂度 O(n)。没有单调性就没有滑动窗口。
