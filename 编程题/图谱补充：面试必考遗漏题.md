<!--
- [INPUT]: 依赖 编程题/前端工程师场景题与编程题完整图谱.md 的能力模型与分层体系
- [OUTPUT]: 图谱遗漏的 13 道面试必考编程题，按重要性排序，含完整实现
- [POS]: 编程题模块的 补充文档，与完整图谱互为补充
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 图谱补充：面试必考遗漏题

> 以下 13 题是「前端工程师场景题与编程题完整图谱」中缺失的面试必考项，按重要性降序排列。

---

## 1. 事件循环输出题 ⭐⭐⭐⭐⭐

> 几乎每场面试都考。不是让你背规则，是给你一段混合代码让你说出输出顺序。

### 设计哲学

JavaScript 是单线程的，但它面对的世界是异步的。事件循环是 JS 给出的答案：**用一根执行线程服务无穷多的异步事件**。

本质矛盾是：你需要异步，但只有一个线程。解法不是多线程，而是**任务队列 + 优先级调度**。

微任务（Promise.then）比宏任务（setTimeout）优先级更高，这不是偶然设计。微任务代表「当前这件事刚刚完成，产生的连锁反应」，应该立即处理；宏任务代表「放到将来某个时刻再做的事」。清空微任务队列再取下一个宏任务，就是在维护「一致性优先于吞吐量」的设计原则。

**为什么要出这道题？** 面试官考察的不是你记住了规则，而是你在看到混合异步代码时，能否在脑海中模拟出一台「虚拟 JS 引擎」的运行过程——这是调试复杂并发 bug 的核心能力。

### 核心规则

```
调用栈（同步） → 微任务队列（Promise.then / queueMicrotask / MutationObserver）→ 宏任务队列（setTimeout / setInterval / I/O）
```

每个宏任务执行完后，清空所有微任务，再取下一个宏任务。async/await 本质是 Promise 语法糖，`await` 后面的代码等价于 `.then` 回调。

### 经典题型

```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
  Promise.resolve().then(() => console.log("3"));
}, 0);

Promise.resolve().then(() => {
  console.log("4");
  setTimeout(() => console.log("5"), 0);
});

console.log("6");
```

**输出**：`1 → 6 → 4 → 2 → 3 → 5`

**解析**：

1. 同步执行：打印 `1`，注册 setTimeout（宏任务），注册 Promise.then（微任务），打印 `6`
2. 清空微任务：执行 Promise.then，打印 `4`，注册 setTimeout（宏任务）
3. 取宏任务：执行第一个 setTimeout，打印 `2`，注册 Promise.then（微任务）
4. 清空微任务：打印 `3`
5. 取宏任务：执行第二个 setTimeout，打印 `5`

### async/await 变体

```javascript
async function async1() {
  console.log("a");
  await async2();
  console.log("b");
}

async function async2() {
  console.log("c");
}

console.log("d");
async1();
Promise.resolve().then(() => console.log("e"));
console.log("f");
```

**输出**：`d → a → c → f → b → e`

**关键点**：`await async2()` 中 `async2()` 同步执行，`await` 之后的 `console.log('b')` 进入微任务队列。`b` 和 `e` 的顺序取决于引擎实现，V8 当前行为是 `b` 先于 `e`（await 直接复用 Promise 而非多包一层）。

---

## 2. LRU 缓存 ⭐⭐⭐⭐⭐

> 附录 Top 30 第 17 名，图谱正文无归属。手写频率极高。

### 设计哲学

缓存的本质矛盾：**容量有限，请求无限**。需要一个策略来决定「遗忘谁」。

LRU（Least Recently Used）背后的哲学假设是**时间局部性原理**：刚被访问过的数据，在短期内大概率还会再被访问。这个假设不完美，但在大多数现实场景中（CPU Cache、浏览器缓存、Vue KeepAlive）都足够有效。

这道题真正考察的是**数据结构的组合设计能力**：单一数据结构无法同时满足「O(1) 查找 + 有序排列」两个约束，必须把哈希表和有序结构拼在一起。这种「约束驱动选型」的思维模式，才是中高级工程师的核心能力。

用 JS Map 是一种「品味」——不是取巧，而是洞察了 Map 的插入顺序特性本质上就是一个 LRU 的天然实现基础，减少了不必要的抽象层。

### 场景

缓存空间有限，需要决定「淘汰谁」。常见场景：

- **Vue KeepAlive**：`max` 超限时淘汰最久未激活的组件
- **接口缓存**：相同请求缓存结果，容量满时淘汰最久未使用的
- **浏览器 HTTP 缓存**：内存缓存也遵循 LRU 策略

### 考察本质

**不是在考算法本身，而是在考数据结构的组合设计**：如何同时保证 `get/put` 都是 `O(1)`。

- 朴素方案（数组）：查找 O(n)，不符合要求
- 正确方案：**哈希表**（O(1) 查找）+ **顺序记录**（知道谁最久未用）
- JS 中的 Map 天然具备「有序 + O(1) 查找」，是最优解

### 核心思路

利用 Map 的插入顺序特性：get/put 时删除再重新插入，保证最近使用的在末尾，淘汰时删第一个。

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return -1;
    const val = this.cache.get(key);
    // 刷新顺序：删除再插入
    this.cache.delete(key);
    this.cache.set(key, val);
    return val;
  }

  put(key, value) {
    // 已存在则先删除（刷新顺序）
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 淘汰最久未使用：Map 迭代器第一个
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    this.cache.set(key, value);
  }
}
```

### 面试追问

- **不用 Map 怎么实现？** → 哈希表 + 双向链表，O(1) get/put
- **LRU 和 LFU 的区别？** → LRU 淘汰最久未使用，LFU 淘汰使用频率最低
- **Vue KeepAlive 用的什么策略？** → LRU，max 属性控制缓存上限

---

## 3. Token 无感刷新 ⭐⭐⭐⭐⭐

> 几乎所有有登录体系的中大厂都考。图谱请求层六个场景完全没有。

### 设计哲学

这道题考察的核心不是「怎么刷新 token」，而是**如何在分布式状态下保证并发请求的一致性**。

access_token 短期有效是一种安全取舍：长期有效的 token 一旦泄露，损失不可控；短期有效则把损失窗口压缩到分钟级。但这把「定期续命」的复杂性转移给了前端。

真正的难点是并发场景：当 10 个请求同时遇到 401，如果全部去刷新 token，会引发「惊群效应」（thundering herd）——这是分布式系统中的经典问题，前端小版本。解法也是经典的：**加锁（isRefreshing）+ 队列挂起（pendingQueue）**，让第一个请求去做「刷新」这件事，其余人排队等结果。

这种「第一个做，其余等」的模式在工程中极其常见：HTTP 请求合并、数据库连接池、React 18 的并发特性都有它的影子。

### 场景

用户正在操作，access_token 过期返回 401，需要静默刷新 token 并重放失败请求，用户无感知。

### 核心实现

```javascript
let isRefreshing = false;
let pendingQueue = []; // 挂起的请求队列

axios.interceptors.response.use(
  (res) => res,
  async (error) => {
    const { config, response } = error;

    if (response?.status !== 401 || config._retried) {
      return Promise.reject(error);
    }

    // 正在刷新 → 挂起当前请求
    if (isRefreshing) {
      return new Promise((resolve, reject) => {
        pendingQueue.push({ config, resolve, reject });
      });
    }

    isRefreshing = true;
    config._retried = true;

    try {
      const { data } = await axios.post("/auth/refresh", {
        refreshToken: getRefreshToken(),
      });
      setToken(data.accessToken);

      // 重放队列中所有挂起的请求
      pendingQueue.forEach(({ config: cfg, resolve }) => {
        cfg.headers.Authorization = `Bearer ${data.accessToken}`;
        resolve(axios(cfg));
      });

      // 重放当前请求
      config.headers.Authorization = `Bearer ${data.accessToken}`;
      return axios(config);
    } catch (refreshError) {
      // 刷新失败 → 全部拒绝 → 跳登录
      pendingQueue.forEach(({ reject }) => reject(refreshError));
      logout();
      return Promise.reject(refreshError);
    } finally {
      isRefreshing = false;
      pendingQueue = [];
    }
  },
);
```

### 关键设计点

| 问题                 | 解决                            |
| -------------------- | ------------------------------- |
| 并发请求同时 401     | `isRefreshing` 锁 + 队列挂起    |
| 刷新成功后重放       | 遍历队列 resolve(axios(config)) |
| 刷新也失败           | 队列全部 reject + 跳登录页      |
| 防止无限重试         | `config._retried` 标记          |
| refresh_token 也过期 | 直接登出，不再重试              |

---

## 4. Vue 响应式手写 ⭐⭐⭐⭐

> 附录 Top 30 第 23 名，图谱 4.2 只有表格一行。P6 必考手写题。

### 设计哲学

响应式系统要解决的核心问题：**如何让数据变化自动传播到所有依赖它的地方，而不需要手动维护依赖关系**。

命令式的解法是手动订阅：数据变了，你去调 update()。这很脆弱——任何地方忘记调用都会导致 UI 不同步。响应式的解法是**把依赖关系的收集权交给系统**：数据被读取时，系统自动记录「谁在读我」；数据被修改时，系统自动通知「所有读过我的人」。

`activeEffect` 是这套机制的灵魂——它是一根「当前正在执行的副作用函数」的全局指针。读数据时（get），把 activeEffect 指向的函数存进依赖集合；写数据时（set），把依赖集合里所有函数重新执行一遍。整个系统的复杂性都在「如何在正确的时机维护这根指针」。

Vue 2 用 Object.defineProperty，Vue 3 用 Proxy。本质差异是：**defineProperty 是对属性的拦截，Proxy 是对对象的代理**。前者无法感知属性的新增/删除，后者可以。这就是为什么 Vue 2 需要 `$set`，Vue 3 不需要。

### 场景

`state.count = 1` 之后，为什么界面会自动更新？这就是响应式系统的核心问题。理解它是理解所有现代前端框架的基础。

### 考察本质

面试考的是**依赖收集的时机和触发机制**，而不是 Proxy 的语法：

- `get` 时**收集依赖**（谁读了这个属性，就把谁记下来）
- `set` 时**触发依赖**（通知所有记录在案的「读者」重新执行）
- `activeEffect` 是全局变量，是依赖收集的「当前上下文」

### 数据结构

```
targetMap (WeakMap)
  └── target (对象)
        └── depsMap (Map)
              └── key (属性名)
                    └── deps (Set<副作用函数>)
```

### 核心实现（Proxy 版）

```javascript
// ---- 依赖收集系统 ----
let activeEffect = null;
const targetMap = new WeakMap();

function track(target, key) {
  if (!activeEffect) return;
  let depsMap = targetMap.get(target);
  if (!depsMap) targetMap.set(target, (depsMap = new Map()));
  let deps = depsMap.get(key);
  if (!deps) depsMap.set(key, (deps = new Set()));
  deps.add(activeEffect);
}

function trigger(target, key) {
  const deps = targetMap.get(target)?.get(key);
  if (deps) deps.forEach((fn) => fn());
}

// ---- 响应式代理 ----
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key, receiver) {
      track(target, key);
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver);
      trigger(target, key);
      return result;
    },
  });
}

// ---- 副作用函数 ----
function effect(fn) {
  activeEffect = fn;
  fn(); // 首次执行，触发 get，收集依赖
  activeEffect = null;
}
```

### 验证

```javascript
const state = reactive({ count: 0 });
effect(() => console.log("count:", state.count));
// 输出: count: 0

state.count = 1;
// 自动输出: count: 1
```

### 面试追问

- **Vue2 和 Vue3 响应式区别？** → defineProperty vs Proxy，后者能拦截新增属性和数组索引
- **嵌套对象怎么处理？** → get 时递归 reactive
- **effect 嵌套怎么办？** → effectStack 栈结构

---

## 5. 前端路由实现 ⭐⭐⭐⭐

> 图谱完全没有。手写频率高，要求两种模式都能实现。

### 设计哲学

SPA 的核心矛盾：**URL 要变，但页面不能刷新**。传统多页应用中，URL 变过就加载新页面，这对用户体验是截断。SPA 的路由需要「隐式欺骗」浏览器——让它认为 URL 变了，但实际不发起页面请求。

Hash 模式的精髓在于：浏览器规定，`#` 后的内容不会发送给服务器，因此刷新页面不会 404。History 模式 URL 更漂亮，但它是在「欺骗」服务器——用 `pushState` 成功改变了地址条，但如果用户直接访问这个地址，服务器没有配置 fallback 就会返回真实的 404。

**`pushState` 不触发 `popstate`** 是最大的陷阱：这个 API 设计只负责历史记录的推送，不考虑代码主动干预的场景。手动调用 `handle` 是必要的逻辑对齐。

### 场景

SPA（单页应用）的核心机制：URL 变化时不刷新页面，只切换组件。React Router、Vue Router 都建立在这两种模式之上。

### 考察本质

- **Hash 模式**：监听 `hashchange` 事件，`#` 后的内容不会发送到服务器，服务端无需配置
- **History 模式**：监听 `popstate` 事件，但 `pushState` **不触发** `popstate`，需手动调用 handle
- **核心陷阱**：History 模式需要服务端配置 fallback，否则直接访问子路由会 404

### Hash 模式

```javascript
class HashRouter {
  constructor() {
    this.routes = {};
    window.addEventListener("hashchange", () => this.handle());
    window.addEventListener("load", () => this.handle());
  }

  route(path, callback) {
    this.routes[path] = callback;
  }

  handle() {
    const path = location.hash.slice(1) || "/";
    this.routes[path]?.();
  }

  push(path) {
    location.hash = path;
  }
}
```

### History 模式

```javascript
class HistoryRouter {
  constructor() {
    this.routes = {};
    window.addEventListener("popstate", () => this.handle());
  }

  route(path, callback) {
    this.routes[path] = callback;
  }

  handle() {
    const path = location.pathname;
    this.routes[path]?.();
  }

  push(path) {
    history.pushState(null, "", path);
    this.handle(); // pushState 不触发 popstate，手动调用
  }
}
```

### 核心区别

| 维度                 | Hash       | History                     |
| -------------------- | ---------- | --------------------------- |
| URL 形态             | `/#/path`  | `/path`                     |
| 监听事件             | hashchange | popstate                    |
| pushState 触发事件？ | —          | 不触发，需手动              |
| 服务端配置           | 不需要     | 需要 fallback 到 index.html |
| SEO                  | 差         | 好                          |

---

## 6. 实现 useState ⭐⭐⭐⭐

> 附录 Top 30 第 24 名，图谱只有表格一行。

### 设计哲学

React Hooks 解决的核心问题：**如何让无类组件拥有状态和生命周期，同时避免 Class 组件的无限嵌套和 this 绑定问题**。

Hooks 的底层是一个按调用顺序索引的数组。这个设计看起来很「直白」，但它有一个深刻的哲学基础：**实现的简单性和规则的明确性之间的取舍**。

为什么不用对象、映射等更「灵活」的方式识别每个 Hook？因为那些方式需要额外的 key 或识别器，增加了使用成本 and 概念负担。数组 + 顺序索引的方式最简单，使用者只需要遵守一个规则（不要在条件语句中调用）就能获得所有能力。这是 React 团队为简单性而做的「安全负债」——把复杂性从实现转到使用约定。

**闭包陷阱的本质**：`setState` 在每次渲染时都绑定了当时的 `hookIndex`。如果你在异步流中调用旧版本的 `setState`，它操作的是旧的快照而非当前状态。这就是「闭包陷阱」的底层原因。

### 场景

`useState` 是 React Hooks 的基石，理解它的实现等于理解：

1. 为什么 Hooks 不能在 `if/for` 里调用
2. 为什么同一个组件的多个 `useState` 互不干扰
3. `setState` 函数式更新和直接赋值的区别

### 考察本质

**Hooks 本质是一个按顺序访问的数组**。每次渲染时按固定顺序读取 `hooks[0]`、`hooks[1]`... 如果顺序因条件分支改变，就会读错格子——这就是「不能在条件语句中调用 Hooks」规则的底层原因。

```
第一次渲染: useState(0) → hooks[0]  useState('') → hooks[1]
第二次渲染: useState(0) → hooks[0]  useState('') → hooks[1]  ← 顺序必须一致
```

### 简易实现

```javascript
const hooks = [];
let hookIndex = 0;

function useState(initialValue) {
  const currentIndex = hookIndex;

  if (hooks[currentIndex] === undefined) {
    hooks[currentIndex] = initialValue;
  }

  const setState = (newValue) => {
    if (typeof newValue === "function") {
      hooks[currentIndex] = newValue(hooks[currentIndex]);
    } else {
      hooks[currentIndex] = newValue;
    }
    render(); // 触发重新渲染
  };

  hookIndex++;
  return [hooks[currentIndex], setState];
}

// 每次渲染前重置 index
function render() {
  hookIndex = 0;
  // 调用组件函数...
}
```

### 面试追问

- **为什么 Hooks 不能在条件语句中调用？** → 依赖 hookIndex 顺序，条件分支会打乱索引
- **闭包陷阱怎么解决？** → useRef 或函数式 setState
- **批量更新原理？** → React 18 自动批处理，多次 setState 合并为一次渲染

---

## 7. 实现 useEffect ⭐⭐⭐⭐

> 和 useState 同量级，Hooks 系列必考的另一半。考察依赖比较和副作用清理机制。

### 设计哲学

useEffect 的核心思想源于函数式编程：**符合 React 的「渲染即输入 + 输出」哲学，但对外部世界（网络、DOM）的操作就是「副作用」，需要一个专门的「副作用边界」来掌管**。

清理函数的设计尤为精妙——它解决了「原局1定阅了某个事件，局62的时候怎么知道这个订阅还在」的问题。这是典型的 RAII 思想（Resource Acquisition Is Initialization）的 React 实现：**谁创建了订阅，谁就负责清除它**。effect 函数返回自己的清理函数，让资源的开辟与回收在代码结构上自然地配对。

`deps` 展开比较而非深比较，这是 React 的全局设计坚持：**不触发重算是使用者的责任**。如果你传入的依赖是每次渲染都新建的对象，那它每次都不展向相等——这是开发者的错误，不是 React 的设计缺陷。useMemo/useCallback 就是为了解决这个问题而生。

### 场景

当状态发生改变时，我们需要引发除了渲染之外的「副作用」，比如发送网络请求、订阅事件、操作 DOM 等。这就需要一个能感知状态变化并执行额外逻辑的机制。

### 考察本质

面试考的是 `useEffect` 的三大核心机制：

1. **执行时机**：每次渲染完成后执行（这里简化为同步执行，React 源码是异步调度的）。
2. **依赖收集与比对**：通过存储上一次的 `deps`，与当次的 `deps` 进行浅比较（`!==`），决定是否重新执行 `effect`。
3. **清理机制**：下一次 `effect` 执行之前，必须先调用上一次 `effect` 返回的清理函数 `cleanup`。

### 核心思路

基于 `hookIndex` 数组存储上次 deps，每次渲染时浅比较，变化才执行 fn。

```javascript
const hooks = [];
let hookIndex = 0;

function useEffect(fn, deps) {
  const currentIndex = hookIndex;
  const prevHook = hooks[currentIndex];

  const hasChanged = prevHook
    ? deps === undefined || deps.some((dep, i) => dep !== prevHook.deps[i])
    : true; // 首次渲染

  if (hasChanged) {
    prevHook?.cleanup?.(); // 执行上次的清理函数
    const cleanup = fn();
    hooks[currentIndex] = { deps, cleanup };
  }

  hookIndex++;
}
```

### 面试追问

- **`deps` 为 `[]` 和不传的区别？** → `[]` 只执行一次，不传每次渲染都执行
- **清理函数什么时候执行？** → 下次 effect 重新执行前 + 组件卸载时
- **为什么 fn 只能返回函数或 undefined？** → 返回值作为 cleanup，其他类型无意义
- **deps 浅比较还是深比较？** → 浅比较（`===`），所以对象/数组每次渲染是新引用

---

## 8. TypeScript 工具类型手写 ⭐⭐⭐⭐

> 有 TypeScript 项目的大厂几乎必考。图谱 4.1.1 只列了名字，需要能手写实现。

### 设计哲学

TypeScript 的类型系统本质上是一门**元编程语言**——你可以对「类型」进行编程，就像写运行时代码一样写类型转换逻辑。

**为什么要手写工具类型？** 因为工具类型是 TS 类型元程序的试验场：承载、映射、条件、推断四大核心功能在几道题里全面覆盖。理解它们的实现，就考察了你是否把 TS 类型系统理解为一个完整的计算体系。

映射类型 (`[K in keyof T]`) 等价于运行时的 `for...in`；条件类型 (`T extends U ? A : B`) 等价于 `if/else`；`infer` 等价于在模式匹配中提取局部变量。最强大的地方在于 **分发**：对联合类型应用条件类型会自动逐个分发计算——这是 TS 类型系统最充满了那种味道的地方。

### 场景

随着项目复杂度增加，我们不能一直手动定义冗余的类型，需要通过对现有类型进行「变换」来生成新类型（例如把一个接口的所有属性变成可选，用于更新操作）。

### 考察本质

面试考的是你是否理解 TypeScript 类型系统的「图灵完备性」特征——**类型元编程能力**：

- 映射类型（Mapped Types）：遍历类型的键并生成新类型
- 条件类型（Conditional Types）：基于条件判断做类型分发
- 推断（`infer`）：在条件类型中提取类型局部变量

### 核心实现

```typescript
// Partial：所有属性变可选
type MyPartial<T> = { [K in keyof T]?: T[K] };

// Required：移除可选（-? 操作符）
type MyRequired<T> = { [K in keyof T]-?: T[K] };

// Readonly：所有属性变只读
type MyReadonly<T> = { readonly [K in keyof T]: T[K] };

// Pick：提取指定属性
type MyPick<T, K extends keyof T> = { [P in K]: T[P] };

// Omit：排除指定属性
type MyOmit<T, K extends keyof T> = { [P in Exclude<keyof T, K>]: T[P] };

// Exclude：从联合类型中排除
type MyExclude<T, U> = T extends U ? never : T;

// ReturnType：提取函数返回类型
type MyReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : never;

// Parameters：提取函数参数类型
type MyParameters<T extends (...args: any) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never;
```

### 关键语法

| 语法                  | 含义                 |
| --------------------- | -------------------- |
| `K in keyof T`        | 遍历 T 的所有键      |
| `?:`                  | 变为可选             |
| `-?:`                 | 移除可选（变为必填） |
| `T extends U ? A : B` | 条件类型             |
| `infer R`             | 类型推断占位符       |

### 面试追问

- **DeepPartial 怎么实现？** → 条件类型递归，对象类型继续 DeepPartial，否则直接 T
- **`Exclude` 和 `Omit` 的区别？** → Exclude 操作联合类型，Omit 操作对象类型的键
- **`infer` 只能在哪里用？** → 只能在 `extends` 条件类型的右侧

---

## 9. Array.prototype 方法实现 ⭐⭐⭐

> 基础轮高频，图谱 1.1 完全没有。

### 设计哲学

这组题考的不是应该如何写循环，而是**你是否对 JavaScript 的「内核」有知觉**。

三个核心考点在工程中非常实用：

- **稀疏数组** (`i in this`)：`new Array(3)` 创建的是带洞的稀疏数组，原生 `map` 会跳过它。不用 `in` 检查直接遍历，就会引入 `undefined` 到输出。
- **`thisArg`**：模拟 React 组件或面向对象的场景中，回调内的 `this` 绑定至关重要。
- **`reduce` 无初始值**：当数组为空时报错而不是返回 `undefined` ——这是对「尽早暴露错误」的设计讲究，让问题在最开始的地方寿终。

`i in this` 等价于 `Object.hasOwn(this, i)`，它的重要性在于不提升数组原型链——只看对象自身所有的索引是否存在。

### 场景

`map`, `filter`, `reduce` 是日常开发处理数据的三板斧。虽然它们是原生 API，但手写能暴露出扎实的语言功底。

### 考察本质

这不是考你怎么循环一个数组，重点全在**边界情况**处理：

1. **稀疏数组陷阱**：像 `[1, , 3]` 这种数组，原生的 `map` 是会跳过空位的（索引 1 不存在）。
2. **`thisArg` 绑定**：`map` 和 `filter` 的第二个参数支持绑定回忆函数里的 `this`。
3. **参数归一化**：`reduce` 有没有传初始值，逻辑是完全不同的。

### map

```javascript
Array.prototype.myMap = function (fn, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (i in this) {
      result[i] = fn.call(thisArg, this[i], i, this);
    }
  }
  return result;
};
```

### filter

```javascript
Array.prototype.myFilter = function (fn, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (i in this && fn.call(thisArg, this[i], i, this)) {
      result.push(this[i]);
    }
  }
  return result;
};
```

### reduce

```javascript
Array.prototype.myReduce = function (fn, initialValue) {
  let acc = initialValue;
  let startIndex = 0;

  if (acc === undefined) {
    if (this.length === 0) throw new TypeError("Reduce of empty array");
    acc = this[0];
    startIndex = 1;
  }

  for (let i = startIndex; i < this.length; i++) {
    if (i in this) {
      acc = fn(acc, this[i], i, this);
    }
  }
  return acc;
};
```

### 关键细节

- `i in this` 处理稀疏数组（`[1, , 3]` 中索引 1 不存在）
- `thisArg` 参数（reduce 没有）
- reduce 无初始值时用第一个元素，空数组抛 TypeError

---

## 10. Object.assign 实现 ⭐⭐⭐

> 浅拷贝经典手写题，图谱 1.1.3 有深拷贝但没有这个。

### 设计哲学

`Object.assign` 把「对象属性合并」这件「简单」的事怎么就考得这么复杂？因为它要考虑 JS 属性体系：

- **枚举性**：并非所有属性都应拷贝——不可枚举的属性应被忽略，它们被设计为内部实现细节。
- **Symbol 属性**：`Object.keys` 的设计先于 Symbol，无法获取到它们。`Reflect.ownKeys` 是符合顺序的正确 API。
- **`setter` 调用**：`assign` 会触发目标对象上存在的 setter，展开运算符 `...` 则不会——展开是纯属性直接赋值，不经过 setter 拦截。

理解这些层次，意味着你对 JS 对象属性系统有完整认知，而不是只知道表面的 `key-value` 。

### 场景

把多个对象的属性合并到一个目标对象上。在没有展开运算符 `...` 之前，它是状态合并的主要手段。

### 考察本质

重点考察你对 JavaScript 对象属性体系的完整理解。很多人的手写代码过不了这几个边界：

1. **基本类型包装**：如果 target 是原始类型（如 `1`），需要转成包装对象 `Object(target)`。
2. **不可枚举属性**：默认的 `for...in` 或 `Object.keys` 不能正确区分哪些是可以拷贝的（不可枚举的不拷贝）。
3. **Symbol 属性**：`Object.keys` 无法获取 Symbol 类型的属性。

```javascript
function myAssign(target, ...sources) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }

  const to = Object(target);

  for (const source of sources) {
    if (source == null) continue;

    // 可枚举自有属性（包括 Symbol）
    for (const key of Reflect.ownKeys(Object(source))) {
      if (Object.prototype.propertyIsEnumerable.call(source, key)) {
        to[key] = source[key];
      }
    }
  }

  return to;
}
```

### 面试追问

- **和展开运算符的区别？** → 基本等价，但 assign 会触发 setter，展开不会
- **能拷贝 Symbol 属性吗？** → 能，Reflect.ownKeys 包含 Symbol
- **不可枚举属性？** → 不拷贝，需要 propertyIsEnumerable 检查

---

## 11. Promise 值穿透 ⭐⭐⭐

> 图谱 Promise 系列没有提这个经典考点。

### 设计哲学

值穿透是 Promise A+ 规范中一个小而紧要的细节——它考察你是否真正读过规范，而不是只会用 Promise。

其存在的设计原因：**Promise 链中的中间节点应该透明——不应该因为中间有一个无效的非函数参数就打断整个链**。这是对「容错性」的设计讲究——如同 HTTP 协议中不认识的头部字段被静默忽略而不是报错，这就是在向前兼容，先完成正常工作，再处理细节。

**实现这个细节是对 Promise A+ 规范的忠实度考核**。手写 Promise 能写到这个等级的人，就不只是在「背」 Promise API，而是在理解它的设计文化。

### 场景

有时候我们会为了对齐某种模式，连续写多个 `.then`，甚至在里面意外传入了非函数参数。

### 考察本质

这是 Promise A+ 规范中关于忽略非函数参数的规定。面试考的是你是否深入阅读过规范，或者是否在实现 `Promise.prototype.then` 时处理了这个细节。

### 现象

```javascript
Promise.resolve(1).then().then(2).then(Promise.resolve(3)).then(console.log);
// 输出: 1
```

### 原因

`.then()` 的参数如果不是函数，会被忽略，值会"穿透"到下一个有效的 `.then`。

### 实现要点

在 Promise 实现中，then 方法需要处理参数不是函数的情况：

```javascript
then(onFulfilled, onRejected) {
  // 值穿透的关键：非函数参数替换为透传函数
  onFulfilled = typeof onFulfilled === 'function'
    ? onFulfilled
    : (value) => value;

  onRejected = typeof onRejected === 'function'
    ? onRejected
    : (reason) => { throw reason; };

  // ... 返回新 Promise
}
```

### 面试追问

- **为什么 `.then(2)` 不生效？** → 2 不是函数，被替换为 `v => v`
- **`.then(Promise.resolve(3))` 呢？** → Promise.resolve(3) 是一个 Promise 对象，不是函数，同样被忽略
- **reject 也会穿透吗？** → 会，onRejected 非函数时替换为 `r => { throw r }`

---

## 12. JSON.stringify 优先级修正 ⭐⭐⭐

> 图谱 1.3.3 标了"了解"，实际面试频率应为"掌握"。

### 设计哲学

`JSON.stringify` 的隐藏规则就是前端的「暗雷区」。生产中那些「字段无缘无故丢失」的 bug，十有八九就是 `undefined`、`function`、`Symbol` 被静默删除了。

**为什么这些类型会被删除？** 因为 JSON 是跨语言的通用格式，`undefined`、`function`、`Symbol` 是 JS 的"本地方言"，在其他语言中无对应概念。序列化这些类型无意义，静默剔除是比报错更好的选择（防止串行出错误的 JSON）。

`NaN/Infinity → null`：同理，这两个是 JS「特有」的数字状态，JSON 规范中没有它们的位置，所以退化为 null。理解这套规则背后的逻辑，就不会在面对序列化异常时手足无措。

### 场景

前后台数据交互时最常用的序列化方法。很多诡异的 bug（比如字段无缘无故丢失）都和它的内部规则有关。

### 考察本质

这里考察的不是一个简单的递归，而是**JavaScript 类型系统在序列化时的特殊规则**。你不仅要处理正常类型，还要知道哪些类型会被抛弃，哪些会被转换。

### 基础版实现

```javascript
function jsonStringify(value) {
  // null
  if (value === null) return "null";

  // undefined / function / symbol → undefined（顶层）
  if (
    value === undefined ||
    typeof value === "function" ||
    typeof value === "symbol"
  ) {
    return undefined;
  }

  // boolean
  if (typeof value === "boolean") return String(value);

  // number
  if (typeof value === "number") {
    return isFinite(value) ? String(value) : "null"; // NaN/Infinity → null
  }

  // string
  if (typeof value === "string") return `"${value}"`;

  // array
  if (Array.isArray(value)) {
    const items = value.map(
      (item) => jsonStringify(item) ?? "null", // undefined 在数组中变 null
    );
    return `[${items.join(",")}]`;
  }

  // object
  if (typeof value === "object") {
    // toJSON 方法
    if (typeof value.toJSON === "function") {
      return jsonStringify(value.toJSON());
    }

    const pairs = [];
    for (const key of Object.keys(value)) {
      const val = jsonStringify(value[key]);
      if (val !== undefined) {
        // undefined/function/symbol 在对象中跳过
        pairs.push(`"${key}":${val}`);
      }
    }
    return `{${pairs.join(",")}}`;
  }
}
```

### 必须处理的边界

| 输入               | 输出                      | 说明                        |
| ------------------ | ------------------------- | --------------------------- |
| `undefined`        | `undefined`（顶层不输出） | 对象中跳过，数组中变 `null` |
| `NaN` / `Infinity` | `"null"`                  |                             |
| `function`         | 同 undefined              |                             |
| `Symbol`           | 同 undefined              |                             |
| `Date`             | 调用 toJSON → ISO 字符串  |                             |
| 循环引用           | 应抛 TypeError            | 基础版可不处理              |

---

## 13. 图片懒加载 ⭐⭐⭐

> Top 30 第 29 名，图谱 1.5 DOM 章节完全缺席。IntersectionObserver 是现代标准方案。

### 设计哲学

懒加载考察的是你对「性能优化怎么做」的系统性思维，而不是一个特定 API 的使用。

早期的 `scroll + getBoundingClientRect` 方案有一个根本缺陷：**它在主线程上同步计算元素位置**。`getBoundingClientRect` 会强制触发回流（reflow），在 scroll 事件高频触发的场景下，就算加了节流，也会成为性能璶颈。

`IntersectionObserver` 的设计哲学：**把位置计算从主线程移到浏览器内核**。你只需说「当这个元素进入视口时告诉我」，浏览器内核自己去监测，等有事再经主线程回调。这是「申户势」思想：不是主动轮询（polling），而是事件驱动（event-driven）。

这道题也指向了更大的能力维度：`ResizeObserver`、`MutationObserver`、`PerformanceObserver`——浏览器正在用一组异步观察者 API 将第三方代码应上项幣网层锁定。

### 场景

信息流或者超长商品列表页，里面有几百张图片。如果一次性加载所有图片，一方面会占用大量带宽，导致首屏极慢；另一方面大部分图片在视口之外，用户可能根本滑不到，属于资源浪费。

### 考察本质

早期主要考察性能优化（节流 debounce + getBoundingClientRect 获取位置），现在重点考察现代 API `IntersectionObserver` 的使用。它可以脱离主线程做视口交叉计算，性能远高于 `scroll` 事件。

### IntersectionObserver 版（推荐）

```javascript
function lazyLoad() {
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;
          img.removeAttribute("data-src");
          observer.unobserve(img); // 加载后停止观察
        }
      });
    },
    { threshold: 0.1 }, // 10% 进入视口时触发
  );

  document.querySelectorAll("img[data-src]").forEach((img) => {
    observer.observe(img);
  });
}
```

### 降级方案（scroll 事件）

```javascript
function isInViewport(el) {
  const rect = el.getBoundingClientRect();
  return rect.top < window.innerHeight && rect.bottom >= 0;
}

window.addEventListener(
  "scroll",
  throttle(() => {
    document.querySelectorAll("img[data-src]").forEach((img) => {
      if (isInViewport(img)) {
        img.src = img.dataset.src;
        img.removeAttribute("data-src");
      }
    });
  }, 200),
);
```

### 面试追问

- **IO 和 scroll 方案的区别？** → IO 异步、性能好、无需手动计算位置；scroll 需节流 + getBoundingClientRect
- **`threshold: 0.1` 是什么？** → 目标元素 10% 进入视口时触发回调
- **原生 `loading="lazy"` 和手写的区别？** → 原生无法控制触发时机，手写更灵活
- **为什么加载后要 unobserve？** → 避免已加载图片重复触发回调

---

## 优先级总览

| 排名 | 题目                 | 图谱应归属章节          | 优先级 |
| ---- | -------------------- | ----------------------- | ------ |
| 1    | 事件循环输出题       | 4.3 浏览器原理应用      | 必会   |
| 2    | LRU 缓存             | 1.3 数据处理与工具函数  | 必会   |
| 3    | Token 无感刷新       | 2.1 请求层复杂场景      | 必会   |
| 4    | Vue 响应式手写       | 4.2 框架原理深度        | 必会   |
| 5    | 前端路由实现         | 4.2 框架原理深度        | 必会   |
| 6    | 实现 useState        | 4.2 框架原理深度        | 必会   |
| 7    | 实现 useEffect       | 4.2 框架原理深度        | 必会   |
| 8    | TS 工具类型手写      | 4.1 TypeScript 类型编程 | 必会   |
| 9    | Array.prototype 方法 | 1.1 JavaScript 核心手写 | 必会   |
| 10   | Object.assign        | 1.1 JavaScript 核心手写 | 掌握   |
| 11   | Promise 值穿透       | 1.2 异步编窋专题        | 掌握   |
| 12   | JSON.stringify 提级  | 1.3 数据处理与工具函数  | 掌握   |
| 13   | 图片懒加载           | 1.5 DOM 与事件          | 掌握   |

---

## 认知跳跃：这 13 题背后的统一模式

读完这 13 题，你会发现它们背后隐藏着几个反复出现的“核心受力”：

### 模式一：单一约束 + 组合设计

LRU = 哈希表 + 有序结构。单一数据结构无法同时满足两个约束，就必须组合。这种思维通用于所有需要权衪取舍的数据结构设计场景。

### 模式二：第一个干，其余等

Token 刷新的并发销“锁+队列”、HTTP 请求合并、React 18 并发渲染——本质都是同一模式。腑到这个模式，你就不是在组识题目，而是在识别原子结构。

### 模式三：拦截 + 收集 / 触发

响应式系统的 get/set 拦截和依赖收集、`useEffect` 的副作用划分、`IntersectionObserver` 的观察者模式——本质都是「不主动轮询，而是被动监听」的事件驱动思想。

### 模式四：顺序就是合同

useState / useEffect 的调用顺序就是它们的身份证。打破顺序 = 打破合同。这个模式在数据库多事务、协议设计中层出不穷。

---

> 这 13 道题不是孤立的知识点，而是让你运用同一套思维模式应对不同题目的瀏焕示例。真正的复习不是把 13 个题合并被，而是抽取上面 4 个模式，然后在每道题中识别它们的身影。
