<!--
- [INPUT]: Canvas API, WebGL, Geometry Algorithms, Rendering Performance Optimization
- [OUTPUT]: 图形渲染系统设计、编辑器交互及高性能可视化策略要求
- [POS]: 编程题/ 复杂场景专题，聚焦图形学、渲染管线与数据可视化
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.4 可视化与图形

可视化不仅仅是图表展示，更是对大数据量下的图形渲染效率与复杂空间交互的严苛挑战。

---

### 3.4.1 Canvas 性能优化 ⭐⭐⭐

**要求：** 针对大规模图形渲染场景，建立一套性能评估与优化方案。

- **技术挑战：**
  - **脏矩形渲染 (Dirty Rectangle)**：实现局部刷新，避免全量重绘。
  - **离屏 Canvas (OffscreenCanvas)**：预渲染复杂静态图形。
  - **图形拾取 (Hit Testing)**：空间剖分算法（Quad-Tree）实现高精度点击判定。
  - **分层渲染策略**：动静分离。

#### 1. 脏矩形渲染核心逻辑

脏矩形的本质是 **"局部重绘优于全局刷新"**。

```javascript
// ─────────────────────────────────────────────────
//  DirtyRectangleManager — 脏矩形渲染器
// ─────────────────────────────────────────────────

class DirtyRectRenderer {
  constructor(canvas) {
    this.ctx = canvas.getContext("2d");
    this.elements = []; // 图形对象列表
    this.dirtyRects = []; // 待更新区域
  }

  // 1. 标记脏区域
  markDirty(rect) {
    this.dirtyRects.push(rect);
  }

  // 2. 局部渲染流程
  flush() {
    if (this.dirtyRects.length === 0) return;

    // A. 合并多个脏矩形（优化：求并集或外接矩形）
    const totalDirty = this._collapseRects(this.dirtyRects);

    // B. 限制绘制范围
    this.ctx.save();
    this.ctx.beginPath();
    this.ctx.rect(totalDirty.x, totalDirty.y, totalDirty.w, totalDirty.h);
    this.ctx.clip(); // 裁剪，后续绘制只会出现在脏区

    // C. 只重绘与脏区相交的元素
    this._clear(totalDirty);
    this.elements.forEach((el) => {
      if (this._intersects(el.bounds, totalDirty)) {
        el.draw(this.ctx);
      }
    });

    this.ctx.restore();
    this.dirtyRects = [];
  }
}
```

> **本质洞察**：脏矩形是 **"贪心算法"** 的体现。在 WebGL 时代，虽然 GPU 全量刷新极快，但在 CPU 密集的 Canvas 2D 场景，脏矩形能显著降低 `drawImage` 和路径计算的指令开销。

#### 2. 空间剖分：四叉树 (Quad-Tree) 拾取

当有 10,000 个物体时，线性遍历判断点击位置是 $O(N)$，四叉树将其降低到 $O(\log N)$。

```javascript
// ─────────────────────────────────────────────────
//  QuadTree — 空间索引算法
// ─────────────────────────────────────────────────

class QuadTreeNode {
  constructor(bounds, capacity) {
    this.bounds = bounds; // {x, y, w, h}
    this.capacity = capacity;
    this.points = [];
    this.divided = false;
  }

  subdivide() {
    const { x, y, w, h } = this.bounds;
    const halfW = w / 2;
    const halfH = h / 2;

    this.nw = new QuadTreeNode({ x, y, w: halfW, h: halfH }, this.capacity);
    this.ne = new QuadTreeNode(
      { x: x + halfW, y, w: halfW, h: halfH },
      this.capacity,
    );
    this.sw = new QuadTreeNode(
      { x, y: y + halfH, w: halfW, h: halfH },
      this.capacity,
    );
    this.se = new QuadTreeNode(
      { x: x + halfW, y: y + halfH, w: halfW, h: halfH },
      this.capacity,
    );
    this.divided = true;
  }

  insert(point) {
    if (!this._contains(this.bounds, point)) return false;

    if (this.points.length < this.capacity) {
      this.points.push(point);
      return true;
    }

    if (!this.divided) this.subdivide();
    return (
      this.nw.insert(point) ||
      this.ne.insert(point) ||
      this.sw.insert(point) ||
      this.se.insert(point)
    );
  }
}
```

---

### 3.4.2 图形编辑器 ⭐⭐⭐⭐

**要求：** 实现一个支持元素拖拽、缩放及连线的图形编辑系统。

- **核心功能：**
  - **坐标系转换**：屏幕坐标与画布坐标的映射。
  - **缩放平移 (Zoom/Pan)**：变换矩阵。
  - **撤销重做**：Memento 模式。

#### 1. 坐标系转换逻辑

编辑器的点击点必须转换到画布内部的坐标系，特别是存在 Zoom 和 Pan 时。

```javascript
// ─────────────────────────────────────────────────
//  CoordinateTransform — 坐标投影
// ─────────────────────────────────────────────────

class TransformManager {
  constructor() {
    this.zoom = 1;
    this.offsetX = 0;
    this.offsetY = 0;
  }

  // 屏幕点 -> 画布点
  screenToCanvas(screenX, screenY) {
    return {
      x: (screenX - this.offsetX) / this.zoom,
      y: (screenY - this.offsetY) / this.zoom,
    };
  }

  // 画布点 -> 屏幕点
  canvasToScreen(canvasX, canvasY) {
    return {
      x: canvasX * this.zoom + this.offsetX,
      y: canvasY * this.zoom + this.offsetY,
    };
  }

  apply(ctx) {
    ctx.setTransform(this.zoom, 0, 0, this.zoom, this.offsetX, this.offsetY);
  }
}
```

> **本质洞察**：图形编辑器的交互本质是 **"线性代数"**。所有缩放 (Scale)、位移 (Translate) 都可以表示为一个 $3 \times 3$ 的矩阵。Canvas 的 `setTransform` 是对该矩阵的直接操作。撤销重做则是对该矩阵或图形树 (Scene Graph) 状态的快照保存。

---

### 3.4.3 大数据可视化 ⭐⭐⭐⭐

**要求：** 解决单页面处理海量数据点（10w+）时的性能问题。

- **关键技术：**
  - **数据降采样 (Downsampling)**：LTTB 算法。
  - **WebGL 渲染**：利用 GPU。
  - **渐进式渲染**：分批注入。

#### 1. LTTB 降采样算法 (保持趋势)

```javascript
// ─────────────────────────────────────────────────
//  LTTB (Largest Triangle Three Buckets) — 高保真降采样
// ─────────────────────────────────────────────────

function LTTB(data, threshold) {
  const dataLength = data.length;
  if (threshold >= dataLength || threshold === 0) return data;

  const sampled = [];
  let sampledIndex = 0;

  // 简单桶划分逻辑...
  // 核心思想：找到三个连续桶中面积最大的三角形顶点
  // 相比于"隔点取样"，LTTB 能够完美保留极值点（峰值/谷值）
  return sampled;
}
```

---

## 质量指标

- **渲染帧率**：交互过程中是否维持 60fps。
- **内存占用**：图形对象频发创建与销毁时的 GC 管理。
- **计算精度**：大规模缩放下的浮点数精度丢失处理。
