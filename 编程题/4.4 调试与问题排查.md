<!--
- [INPUT]: 依赖调试工具与性能分析方法
- [OUTPUT]: 调试技巧与问题排查指南
- [POS]: 编程题模块 - 调试与排查
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 4.4 调试与问题排查

调试能力是区分"初级"和"高级"工程师的分水岭。不是你会写多少代码，而是你能找到多隐蔽的 Bug。

---

## 4.4.1 性能问题排查 ⭐⭐⭐⭐

| 工具            | 用途       |
| :-------------- | :--------- |
| **Performance** | 火焰图分析 |
| **Memory**      | 内存泄漏   |
| **Network**     | 请求分析   |
| **Lighthouse**  | 综合评分   |
| **Web Vitals**  | 核心指标   |

### 1. Performance 火焰图：定位卡顿

```javascript
// ─────────────────────────────────────────────────
//  性能分析 — 程序化 Performance 标记
// ─────────────────────────────────────────────────

// 1. 标记关键业务流程（在 Performance 面板中可见）
performance.mark("page-data-fetch-start");
const data = await fetchPageData();
performance.mark("page-data-fetch-end");

performance.measure(
  "数据获取耗时",
  "page-data-fetch-start",
  "page-data-fetch-end",
);

// 2. 自动检测长任务
const longTaskObserver = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.duration > 100) {
      console.warn(`⚠️ 长任务: ${entry.duration.toFixed(0)}ms`, {
        startTime: entry.startTime,
        // 在 Performance 录制中用 User Timing 标注
      });
    }
  });
});
longTaskObserver.observe({ type: "longtask" });

// 3. 火焰图阅读技巧：
// - 横轴 = 时间，纵轴 = 调用栈深度
// - 宽的色块 = 耗时长的函数（优化目标）
// - 红色三角 = 强制同步布局（Layout Thrashing）
// - 黄色 = JS 执行，紫色 = Layout，绿色 = Paint
```

### 2. Network 面板：关键路径优化

```javascript
// ─────────────────────────────────────────────────
//  ResourceAnalyzer — 资源加载分析工具
// ─────────────────────────────────────────────────

function analyzeResources() {
  const resources = performance.getEntriesByType("resource");
  const analysis = resources.map((r) => ({
    name: r.name.split("/").pop(),
    type: r.initiatorType,
    duration: Math.round(r.duration),
    size: r.transferSize,
    // 关键指标分解
    dns: Math.round(r.domainLookupEnd - r.domainLookupStart),
    tcp: Math.round(r.connectEnd - r.connectStart),
    ttfb: Math.round(r.responseStart - r.requestStart),
    download: Math.round(r.responseEnd - r.responseStart),
    // 是否阻塞渲染
    blocking: r.renderBlockingStatus === "blocking",
  }));

  // 按耗时排序，找到最慢的资源
  analysis.sort((a, b) => b.duration - a.duration);

  console.table(analysis.slice(0, 10));
  return analysis;
}

// 使用：在控制台执行
// analyzeResources()
```

---

## 4.4.2 内存泄漏排查 ⭐⭐⭐⭐

### 常见场景

- **定时器未清除**
- **闭包引用**
- **事件监听未移除**
- **DOM 引用**
- **全局变量**

### 1. 五类内存泄漏与修复

```javascript
// ─────────────────────────────────────────────────
//  MemoryLeaks — 五种经典泄漏场景与修复
// ─────────────────────────────────────────────────

// ── 1. 定时器泄漏 ───────────────────────────────
// ❌ 泄漏：组件卸载后定时器继续运行
function LeakyComponent() {
  useEffect(() => {
    setInterval(() => fetchData(), 3000);
    // 没有返回清理函数！
  }, []);
}

// ✅ 修复：
function FixedComponent() {
  useEffect(() => {
    const id = setInterval(() => fetchData(), 3000);
    return () => clearInterval(id); // 卸载时清除
  }, []);
}

// ── 2. 闭包泄漏 ────────────────────────────────
// ❌ 泄漏：闭包持有大对象引用
function createHandler() {
  const hugeData = new Array(1000000).fill("*"); // 大数据
  return function onClick() {
    // 只用了 hugeData.length，但闭包持有整个 hugeData
    console.log(hugeData.length);
  };
}

// ✅ 修复：只存需要的值
function createHandler() {
  const hugeData = new Array(1000000).fill("*");
  const len = hugeData.length; // 只提取需要的部分
  return function onClick() {
    console.log(len);
  };
}

// ── 3. 事件监听泄漏 ────────────────────────────
// ❌ 泄漏：addEventListener 但没有 removeEventListener
function LeakyListener() {
  useEffect(() => {
    const handler = () => console.log("resize");
    window.addEventListener("resize", handler);
    // 忘记清理！
  }, []);
}

// ✅ 修复：
function FixedListener() {
  useEffect(() => {
    const handler = () => console.log("resize");
    window.addEventListener("resize", handler);
    return () => window.removeEventListener("resize", handler);
  }, []);
}

// ── 4. 游离 DOM 引用 ───────────────────────────
// ❌ 泄漏：DOM 已从页面移除，但 JS 仍持有引用
let cachedElement = null;
function showModal() {
  cachedElement = document.createElement("div");
  document.body.appendChild(cachedElement);
}
function hideModal() {
  document.body.removeChild(cachedElement);
  // cachedElement 仍然引用着已移除的 DOM，GC 无法回收
}

// ✅ 修复：
function hideModal() {
  document.body.removeChild(cachedElement);
  cachedElement = null; // 断开引用
}

// ── 5. 全局变量 / Map 无界增长 ──────────────────
// ❌ 泄漏：
const cache = new Map();
function processItem(item) {
  cache.set(item.id, item); // 只增不删，Map 不断膨胀
}

// ✅ 修复：用 WeakMap 或设上限
const cache2 = new WeakMap(); // 对象被GC后自动移除
// 或者 LRU 缓存策略
```

### 2. Heap Snapshot 排查流程

```javascript
// ─────────────────────────────────────────────────
//  Heap Snapshot 三步法
// ─────────────────────────────────────────────────

// Step 1: 记录起始 Snapshot
//   DevTools → Memory → Take Heap Snapshot

// Step 2: 执行疑似泄漏操作（打开/关闭弹窗、切换路由）

// Step 3: 记录结束 Snapshot，对比差异
//   选择 "Comparison" 视图
//   关注：
//   - Delta 列 > 0 的对象（新增但未释放）
//   - "Detached DOM tree"（游离 DOM 节点）
//   - 按 "Retained Size" 排序找大对象

// ── 自动化内存检测 ──────────────────────────────
function detectMemoryLeak() {
  if (!performance.memory) return; // Chrome only

  const readings = [];
  const interval = setInterval(() => {
    readings.push({
      time: Date.now(),
      used: performance.memory.usedJSHeapSize / 1048576, // MB
      total: performance.memory.totalJSHeapSize / 1048576,
    });

    // 分析趋势：如果持续上升就可能有泄漏
    if (readings.length >= 10) {
      const slope = (readings[9].used - readings[0].used) / 10;
      if (slope > 0.5) {
        console.warn(`⚠️ 疑似内存泄漏：${slope.toFixed(2)} MB/sample`);
      }
      readings.shift();
    }
  }, 5000);

  return () => clearInterval(interval);
}
```

---

## 4.4.3 线上问题定位 ⭐⭐⭐

### 方法

- **SourceMap 还原**
- **行为回放**
- **网络抓包**
- **远程调试**

### 1. SourceMap 服务端还原

```javascript
// ─────────────────────────────────────────────────
//  StackTraceResolver — SourceMap 堆栈还原
// ─────────────────────────────────────────────────

const { SourceMapConsumer } = require("source-map");

class StackTraceResolver {
  constructor() {
    this.consumers = new Map(); // 缓存 SourceMapConsumer
  }

  async resolve(errorStack, sourceMapUrl) {
    const consumer = await this._getConsumer(sourceMapUrl);

    // 解析压缩后的堆栈行号
    const frames = this._parseStack(errorStack);

    return frames.map((frame) => {
      const original = consumer.originalPositionFor({
        line: frame.line,
        column: frame.column,
      });

      return {
        original: `${original.source}:${original.line}:${original.column}`,
        function: original.name || frame.func,
        compressed: `${frame.file}:${frame.line}:${frame.column}`,
      };
    });
  }

  _parseStack(stack) {
    return stack
      .split("\n")
      .filter((line) => line.includes("at "))
      .map((line) => {
        const match = line.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/);
        return match
          ? {
              func: match[1],
              file: match[2],
              line: +match[3],
              column: +match[4],
            }
          : null;
      })
      .filter(Boolean);
  }

  async _getConsumer(url) {
    if (!this.consumers.has(url)) {
      const response = await fetch(url);
      const rawMap = await response.json();
      this.consumers.set(url, await new SourceMapConsumer(rawMap));
    }
    return this.consumers.get(url);
  }
}
```

### 2. 用户会话行为回放

```javascript
// ─────────────────────────────────────────────────
//  SessionRecorder — 用户行为录制（简化版 rrweb）
// ─────────────────────────────────────────────────

class SessionRecorder {
  constructor() {
    this.events = [];
    this.startTime = Date.now();
  }

  start() {
    // 记录初始 DOM 快照
    this.events.push({
      type: "snapshot",
      data: document.documentElement.outerHTML,
      timestamp: 0,
    });

    // 监听 DOM 变更
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((m) => {
        this.events.push({
          type: "mutation",
          data: {
            type: m.type,
            target: this._getSelector(m.target),
            addedNodes: m.addedNodes.length,
            removedNodes: m.removedNodes.length,
          },
          timestamp: Date.now() - this.startTime,
        });
      });
    });
    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      characterData: true,
    });

    // 监听用户交互
    ["click", "input", "scroll"].forEach((type) => {
      document.addEventListener(
        type,
        (e) => {
          this.events.push({
            type: "interaction",
            data: {
              action: type,
              target: this._getSelector(e.target),
              value: e.target?.value?.slice(0, 100),
              scrollY: type === "scroll" ? window.scrollY : undefined,
            },
            timestamp: Date.now() - this.startTime,
          });
        },
        { capture: true, passive: true },
      );
    });
  }

  // 获取元素的 CSS 选择器（用于回放定位）
  _getSelector(el) {
    if (el.id) return `#${el.id}`;
    if (!el.parentElement) return el.tagName?.toLowerCase();
    const idx = [...el.parentElement.children].indexOf(el);
    return `${this._getSelector(el.parentElement)} > :nth-child(${idx + 1})`;
  }

  getEvents() {
    return this.events;
  }
}
```

> **本质洞察**：调试的三层境界：**肉眼看代码**（初级）→ **工具驱动排查**（中级）→ **数据驱动定位**（高级）。线上问题之所以难排查，是因为 **「无法复现就无法调试」**。SourceMap 解决了"代码在哪"的问题，行为回放解决了"用户做了什么"的问题，性能 Profiling 解决了"慢在哪里"的问题。三者组合才构成完整的 **可观测性**。

---

## 质量指标

- **定位速度**：从收到报警到定位根因的平均时长。
- **工具熟练度**：能否不借助搜索引擎在 DevTools 中完成完整排查。
- **推理能力**：能否从有限线索中缩小排查范围。
