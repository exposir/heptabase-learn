<!--
- [INPUT]: 依赖常见算法与数据结构
- [OUTPUT]: 算法在前端核心场景的实际应用
- [POS]: 编程题模块 - 算法应用
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 4.8 算法在前端的实际应用

前端不需要刷 LeetCode Hard，但需要理解常见算法如何解决真实的工程问题。每个算法背后都有一个业务场景。

---

| 场景            | 算法                  |
| :-------------- | :-------------------- |
| **虚拟列表**    | 二分查找              |
| **DOM diff**    | 最长递增子序列        |
| **大文件 hash** | 分块 + Worker         |
| **模糊搜索**    | 字符串匹配 / 编辑距离 |
| **依赖分析**    | 拓扑排序              |
| **弹幕防碰撞**  | 贪心算法              |
| **自动布局**    | 力导向图              |
| **撤销重做**    | 命令模式 + 栈         |
| **路径规划**    | A\* / Dijkstra        |

---

### 1. 虚拟列表：二分查找定位

```javascript
// ─────────────────────────────────────────────────
//  VirtualList — 二分查找在不定高虚拟列表中的应用
// ─────────────────────────────────────────────────

// 问题：10 万条不等高列表，滚到第 50000 条时快速定位
// 解决：维护前缀和数组，用二分查找定位 scrollTop 对应的起始索引

class VirtualList {
  constructor(items, estimatedHeight = 50) {
    // 预估高度初始化位置缓存
    this.positions = items.map((_, i) => ({
      index: i,
      top: i * estimatedHeight,
      bottom: (i + 1) * estimatedHeight,
      height: estimatedHeight,
    }));
  }

  // 二分查找：scrollTop → startIndex
  getStartIndex(scrollTop) {
    let lo = 0;
    let hi = this.positions.length - 1;

    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const bottom = this.positions[mid].bottom;

      if (bottom === scrollTop) return mid + 1;
      if (bottom < scrollTop) lo = mid + 1;
      else hi = mid - 1;
    }
    return lo;
  }

  // 实际渲染后更新真实高度
  updateHeight(index, realHeight) {
    const delta = realHeight - this.positions[index].height;
    this.positions[index].height = realHeight;
    this.positions[index].bottom += delta;

    // 联动更新后续所有元素位置
    for (let i = index + 1; i < this.positions.length; i++) {
      this.positions[i].top = this.positions[i - 1].bottom;
      this.positions[i].bottom =
        this.positions[i].top + this.positions[i].height;
    }
  }
}
```

### 2. 大文件分片 Hash

```javascript
// ─────────────────────────────────────────────────
//  FileHasher — 大文件分片 + Worker 计算 Hash
// ─────────────────────────────────────────────────

async function hashLargeFile(file, chunkSize = 2 * 1024 * 1024) {
  const chunks = Math.ceil(file.size / chunkSize);
  const spark = new SparkMD5.ArrayBuffer();

  for (let i = 0; i < chunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);

    // 分片读取，避免内存爆炸
    const buffer = await chunk.arrayBuffer();
    spark.append(buffer);

    // 上报进度
    const progress = (((i + 1) / chunks) * 100).toFixed(1);
    postMessage({ type: "progress", progress });
  }

  return spark.end(); // 最终 MD5
}

// ── Worker 版本（不阻塞主线程） ─────────────────
// main.js
function hashFileInWorker(file) {
  return new Promise((resolve) => {
    const worker = new Worker("hash-worker.js");
    worker.postMessage({ file });
    worker.onmessage = (e) => {
      if (e.data.type === "done") {
        resolve(e.data.hash);
        worker.terminate();
      }
    };
  });
}
```

### 3. 模糊搜索：编辑距离

```javascript
// ─────────────────────────────────────────────────
//  FuzzySearch — 编辑距离 (Levenshtein Distance)
// ─────────────────────────────────────────────────

function levenshtein(a, b) {
  const m = a.length,
    n = b.length;
  const dp = Array.from({ length: m + 1 }, (_, i) =>
    Array.from({ length: n + 1 }, (_, j) => (i === 0 ? j : j === 0 ? i : 0)),
  );

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (a[i - 1] === b[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j] + 1, // 删除
          dp[i][j - 1] + 1, // 插入
          dp[i - 1][j - 1] + 1, // 替换
        );
      }
    }
  }
  return dp[m][n];
}

// 基于编辑距离的模糊搜索
function fuzzySearch(query, candidates, maxDistance = 2) {
  return candidates
    .map((item) => ({
      item,
      distance: levenshtein(query.toLowerCase(), item.toLowerCase()),
    }))
    .filter((r) => r.distance <= maxDistance)
    .sort((a, b) => a.distance - b.distance)
    .map((r) => r.item);
}

// fuzzySearch("recat", ["react", "vue", "angular", "redux"])
// → ["react"]  (编辑距离 = 2，交换 c 和 a)
```

### 4. 依赖分析：拓扑排序

```javascript
// ─────────────────────────────────────────────────
//  TopoSort — 模块依赖的构建顺序决定
// ─────────────────────────────────────────────────

function topologicalSort(graph) {
  // graph: { a: ["b", "c"], b: ["c"], c: [] }
  // 表示 a 依赖 b 和 c，b 依赖 c

  const inDegree = {};
  const result = [];
  const queue = [];

  // 初始化入度
  for (const node of Object.keys(graph)) {
    if (!(node in inDegree)) inDegree[node] = 0;
    for (const dep of graph[node]) {
      inDegree[dep] = (inDegree[dep] || 0) + 1;
    }
  }

  // 入度为 0 的节点入队
  for (const node of Object.keys(inDegree)) {
    if (inDegree[node] === 0) queue.push(node);
  }

  while (queue.length > 0) {
    const node = queue.shift();
    result.push(node);

    for (const dep of graph[node] || []) {
      inDegree[dep]--;
      if (inDegree[dep] === 0) queue.push(dep);
    }
  }

  // 检测循环依赖
  if (result.length !== Object.keys(inDegree).length) {
    throw new Error("存在循环依赖!");
  }

  return result.reverse(); // 被依赖的先构建
}

// topologicalSort({ app: ["utils", "api"], api: ["utils"], utils: [] })
// → ["utils", "api", "app"]
```

### 5. 弹幕防碰撞：贪心算法

```javascript
// ─────────────────────────────────────────────────
//  DanmakuEngine — 弹幕防碰撞（贪心选轨道）
// ─────────────────────────────────────────────────

class DanmakuEngine {
  constructor(trackCount, containerWidth) {
    this.containerWidth = containerWidth;
    // 每条轨道记录最后一条弹幕的"结束时间"
    this.tracks = new Array(trackCount).fill(0);
  }

  // 贪心：为新弹幕选择最早空闲的轨道
  getTrack(danmaku) {
    const now = performance.now();
    let bestTrack = -1;
    let earliestEnd = Infinity;

    for (let i = 0; i < this.tracks.length; i++) {
      if (this.tracks[i] <= now) {
        // 此轨道已空闲，直接选择
        bestTrack = i;
        break;
      }
      if (this.tracks[i] < earliestEnd) {
        earliestEnd = this.tracks[i];
        bestTrack = i;
      }
    }

    if (bestTrack === -1) return -1; // 全满，丢弃

    // 更新轨道占用时间
    const speed = 100; // px/s
    const duration = ((this.containerWidth + danmaku.width) / speed) * 1000;
    this.tracks[bestTrack] = now + duration;

    return bestTrack;
  }
}
```

### 6. 撤销重做：命令模式

```javascript
// ─────────────────────────────────────────────────
//  UndoRedoStack — 编辑器撤销重做
// ─────────────────────────────────────────────────

class UndoRedoStack {
  constructor() {
    this.undoStack = []; // 已执行的命令
    this.redoStack = []; // 被撤销的命令
  }

  execute(command) {
    command.execute();
    this.undoStack.push(command);
    this.redoStack = []; // 新操作清空 redo
  }

  undo() {
    const cmd = this.undoStack.pop();
    if (!cmd) return;
    cmd.undo();
    this.redoStack.push(cmd);
  }

  redo() {
    const cmd = this.redoStack.pop();
    if (!cmd) return;
    cmd.execute();
    this.undoStack.push(cmd);
  }
}

// 文本编辑命令
class InsertTextCommand {
  constructor(editor, position, text) {
    this.editor = editor;
    this.position = position;
    this.text = text;
  }
  execute() {
    this.editor.insertAt(this.position, this.text);
  }
  undo() {
    this.editor.deleteAt(this.position, this.text.length);
  }
}
```

> **本质洞察**：算法在前端的应用不是"为了用算法而用"，而是 **"业务规模逼出来的"**。10 条数据线性遍历够了，10 万条就必须二分查找；5 个依赖随便装，50 个互相依赖就必须拓扑排序。**算法是 O(n²) 到 O(n log n) 的跨越**，是"能用"到"好用"的分水岭。前端面试考算法不是刁难，而是在测试你 **能否在数据规模增长时做出正确的工程决策**。

---

## 质量指标

- **时间复杂度意识**：能否识别代码中隐藏的 O(n²) 并优化。
- **场景匹配度**：能否为具体业务问题选择最合适的算法。
- **实现正确性**：边界情况（空数组、极大输入、重复元素）是否处理完备。
