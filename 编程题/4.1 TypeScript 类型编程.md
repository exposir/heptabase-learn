<!--
- [INPUT]: 依赖 TypeScript 语言基础
- [OUTPUT]: TypeScript 类型编程实战与面试题
- [POS]: 编程题模块 - TypeScript 专项
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 4.1 TypeScript 类型编程

类型编程是 TypeScript 的"第二语言"——一个运行在编译期的纯函数式语言，输入是类型，输出是类型。

---

## 4.1.1 工具类型实现 ⭐⭐⭐

| 类型                              | 难度     |
| :-------------------------------- | :------- |
| **Partial / Required / Readonly** | ⭐⭐     |
| **Pick / Omit**                   | ⭐⭐     |
| **ReturnType / Parameters**       | ⭐⭐⭐   |
| **DeepPartial**                   | ⭐⭐⭐   |
| **路径类型 Path\<T\>**            | ⭐⭐⭐⭐ |
| **元组转联合**                    | ⭐⭐⭐   |

### 1. 基础工具类型

```typescript
// ─────────────────────────────────────────────────
//  基础工具类型 — 从零实现标准库
// ─────────────────────────────────────────────────

// Partial: 所有属性变可选
type MyPartial<T> = {
  [K in keyof T]?: T[K];
};

// Required: 所有属性变必填（-? 移除可选标记）
type MyRequired<T> = {
  [K in keyof T]-?: T[K];
};

// Readonly: 所有属性变只读
type MyReadonly<T> = {
  readonly [K in keyof T]: T[K];
};

// Pick: 从 T 中选取 K 指定的属性
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// Omit: 从 T 中排除 K 指定的属性
type MyOmit<T, K extends keyof T> = {
  [P in keyof T as P extends K ? never : P]: T[P];
};

// ReturnType: 提取函数返回类型
type MyReturnType<T extends (...args: any[]) => any> = T extends (
  ...args: any[]
) => infer R
  ? R
  : never;

// Parameters: 提取函数参数类型（元组）
type MyParameters<T extends (...args: any[]) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never;
```

### 2. 进阶：DeepPartial（递归类型）

```typescript
// ─────────────────────────────────────────────────
//  DeepPartial — 递归地将所有嵌套属性变为可选
// ─────────────────────────────────────────────────

type DeepPartial<T> = T extends object
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : T;

// 验证
interface Config {
  db: { host: string; port: number; auth: { user: string; pass: string } };
  log: { level: string };
}

type PartialConfig = DeepPartial<Config>;
// 结果：db?.host?, db?.auth?.user? 全部可选
```

### 3. 高阶：Path\<T\> 路径类型

```typescript
// ─────────────────────────────────────────────────
//  Path<T> — 对象的所有合法路径的联合类型
// ─────────────────────────────────────────────────
// 用途：实现类型安全的 lodash.get(obj, "a.b.c")

type Path<T> = T extends object
  ? {
      [K in keyof T & string]: T[K] extends object
        ? K | `${K}.${Path<T[K]>}`
        : K;
    }[keyof T & string]
  : never;

// PathValue: 根据路径获取对应类型
type PathValue<T, P extends string> = P extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? PathValue<T[K], Rest>
    : never
  : P extends keyof T
    ? T[P]
    : never;

// 类型安全的 get 函数
function get<T, P extends Path<T>>(obj: T, path: P): PathValue<T, P> {
  return path.split(".").reduce((o: any, k) => o?.[k], obj);
}

// 验证
interface User {
  name: string;
  address: { city: string; geo: { lat: number; lng: number } };
}

const city = get(user, "address.city"); // string ✅
const lat = get(user, "address.geo.lat"); // number ✅
// get(user, "address.foo");                  // 编译错误 ✅
```

### 4. 元组转联合

```typescript
// ─────────────────────────────────────────────────
//  TupleToUnion — 元组类型转联合类型
// ─────────────────────────────────────────────────

type TupleToUnion<T extends readonly any[]> = T[number];

// 验证
const STATUS = ["idle", "loading", "success", "error"] as const;
type Status = TupleToUnion<typeof STATUS>; // "idle" | "loading" | "success" | "error"
```

> **本质洞察**：TypeScript 类型系统是一个 **图灵完备的函数式语言**。`extends ? :` 是 if-else，递归类型是循环，`infer` 是模式匹配。理解这一点后，所有"类型体操"不过是在编译期写一段小程序。`keyof` 是反射，`in` 是遍历，`as` 是映射变换 —— 它们共同构成了类型层面的 **Map/Filter/Reduce**。

---

## 4.1.2 类型体操实战 ⭐⭐⭐⭐

### 1. API 响应类型推导

```typescript
// ─────────────────────────────────────────────────
//  API 响应类型 — 从请求定义自动推导响应类型
// ─────────────────────────────────────────────────

interface ApiDefinition {
  "/api/user": {
    params: { id: string };
    response: { name: string; age: number };
  };
  "/api/posts": { params: { page: number }; response: { title: string }[] };
}

// 类型安全的请求函数
async function request<T extends keyof ApiDefinition>(
  url: T,
  params: ApiDefinition[T]["params"],
): Promise<ApiDefinition[T]["response"]> {
  const queryStr = new URLSearchParams(params as any).toString();
  const res = await fetch(`${url}?${queryStr}`);
  return res.json();
}

// 使用：参数和返回值全自动推导
const user = await request("/api/user", { id: "123" }); // { name, age }
const posts = await request("/api/posts", { page: 1 }); // { title }[]
```

### 2. 表单字段类型关联

```typescript
// ─────────────────────────────────────────────────
//  FormSchema — 字段名与值类型的强关联
// ─────────────────────────────────────────────────

interface FormSchema {
  username: string;
  age: number;
  isAdmin: boolean;
  tags: string[];
}

// 类型安全的表单操作
class TypedForm<T extends Record<string, any>> {
  private data: Partial<T> = {};

  // 设值：字段名约束对应的值类型
  set<K extends keyof T>(key: K, value: T[K]): void {
    this.data[key] = value;
  }

  // 取值：自动推导返回类型
  get<K extends keyof T>(key: K): T[K] | undefined {
    return this.data[key];
  }

  // 监听：回调参数类型自动匹配
  onChange<K extends keyof T>(key: K, cb: (val: T[K]) => void): void {
    // ...
  }
}

const form = new TypedForm<FormSchema>();
form.set("age", 25); // ✅
// form.set("age", "25");  // ❌ 类型错误
form.onChange("tags", (val) => {
  // val 自动推导为 string[]
});
```

### 3. 路由参数类型提取

```typescript
// ─────────────────────────────────────────────────
//  ExtractRouteParams — 从路由模板提取参数类型
// ─────────────────────────────────────────────────

// 从 "/user/:id/post/:postId" 提取 { id: string; postId: string }
type ExtractRouteParams<T extends string> =
  T extends `${infer _}:${infer Param}/${infer Rest}`
    ? { [K in Param]: string } & ExtractRouteParams<Rest>
    : T extends `${infer _}:${infer Param}`
      ? { [K in Param]: string }
      : {};

// 类型安全的路由导航
function navigate<T extends string>(
  path: T,
  params: ExtractRouteParams<T>,
): void {
  let url: string = path;
  Object.entries(params).forEach(([key, value]) => {
    url = url.replace(`:${key}`, value as string);
  });
  history.pushState(null, "", url);
}

navigate("/user/:id/post/:postId", { id: "1", postId: "42" }); // ✅
// navigate("/user/:id", {});  // ❌ 缺少 id
```

### 4. 事件名与回调类型

```typescript
// ─────────────────────────────────────────────────
//  TypedEventEmitter — 事件名与处理器类型绑定
// ─────────────────────────────────────────────────

interface EventMap {
  click: { x: number; y: number };
  change: { value: string; prevValue: string };
  submit: { formData: Record<string, any> };
}

class TypedEmitter<T extends Record<string, any>> {
  private handlers = new Map<keyof T, Set<Function>>();

  on<K extends keyof T>(event: K, handler: (payload: T[K]) => void): void {
    if (!this.handlers.has(event)) this.handlers.set(event, new Set());
    this.handlers.get(event)!.add(handler);
  }

  emit<K extends keyof T>(event: K, payload: T[K]): void {
    this.handlers.get(event)?.forEach((fn) => fn(payload));
  }
}

const emitter = new TypedEmitter<EventMap>();
emitter.on("click", (e) => console.log(e.x, e.y)); // e 自动推导
emitter.on("change", (e) => console.log(e.value)); // ✅
// emitter.emit("click", { value: "" });             // ❌ 类型不匹配
```

### 5. 递归类型：树形结构操作

```typescript
// ─────────────────────────────────────────────────
//  TreeNode — 递归类型定义与操作
// ─────────────────────────────────────────────────

interface TreeNode<T> {
  value: T;
  children: TreeNode<T>[];
}

// 获取树中所有值的类型（展平）
type FlattenTree<T> =
  T extends TreeNode<infer V> ? V | FlattenTree<T["children"][number]> : never;

// 类型安全的树遍历
function traverse<T>(node: TreeNode<T>, visitor: (value: T) => void): void {
  visitor(node.value);
  node.children.forEach((child) => traverse(child, visitor));
}

// 类型安全的 JSON 序列化约束
type JSONValue =
  | string
  | number
  | boolean
  | null
  | JSONValue[]
  | { [key: string]: JSONValue };

// 只允许 JSON 安全的值传入
function safeStringify(value: JSONValue): string {
  return JSON.stringify(value);
}
```

> **本质洞察**：类型体操的终极目的不是炫技，而是 **将运行时错误前移到编译期**。每一个写对的类型定义，都意味着一个不会在凌晨三点被叫醒的 Bug。`infer` 是编译期的"正则匹配"，模板字面量类型是编译期的"字符串解析器"，条件类型是编译期的"模式匹配引擎"。掌握这些后，你就拥有了一套 **编译期 DSL**，能把复杂的业务约束编码成类型，让编译器替你看门。

---

## 质量指标

- **类型覆盖率**：核心函数的输入输出是否有准确的类型约束。
- **可读性**：复杂类型是否通过中间类型拆分，避免"类型套娃"。
- **推导友好度**：使用者是否能享受丝滑的自动补全，而非到处写 `as`。
