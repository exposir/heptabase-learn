<!--
- [INPUT]: Monorepo Tools, Component Library Design, CLI Frameworks, AST (Babel/ESLint)
- [OUTPUT]: 工程基础设施设计、工具链开发及代码自动化重构的要求
- [POS]: 编程题/ 复杂场景专题，聚焦提效工具与中大型项目架构
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.5 工程架构

工程架构专题考察开发者如何通过工具化与规范化，提升大规模团队的研发效率与系统稳定性。

---

### 3.5.1 Monorepo 管理与构建 ⭐⭐⭐

**要求：** 设计一个支撑多包 (Packages) 协作的工程化方案。

- **核心挑战：**
  - **依赖管理策略**：解决 Phantom dependencies（幽灵依赖）。
  - **版本发布流**：Changesets 自动化。
  - **增量构建 (Incremental Build)**：Turborepo 缓存机制。

#### 1. 增量构建的哈希基准算法

增量构建的核心是 **"输入哈希决定输出缓存"**。

```javascript
// ─────────────────────────────────────────────────
//  TaskHasher — 增量构建哈希计算逻辑
// ─────────────────────────────────────────────────

const crypto = require("crypto");
const fs = require("fs");

function calculateTaskHash(packagePath, taskName, envVars) {
  const hash = crypto.createHash("sha256");

  // 1. 源代码指纹
  const files = getAllSrcFiles(packagePath);
  files.forEach((file) => hash.update(fs.readFileSync(file)));

  // 2. 依赖项指纹 (lockfile)
  hash.update(fs.readFileSync("pnpm-lock.yaml"));

  // 3. 配置与环境变量
  hash.update(JSON.stringify(envVars));
  hash.update(taskName);

  return hash.digest("hex");
}
```

> **本质洞察**：Monorepo 的效率提升不在于"代码放在一起"，而在于 **"图论的应用"**。通过拓扑排序确定构建顺序，通过哈希指纹跳过未变更的节点。Turborepo 的核心就是这套 **Task Graph** 的管理。

---

### 3.5.2 企业级组件库设计 ⭐⭐⭐⭐

**要求：** 从零构建一套符合工业标准的基础组件系统。

- **关键要素：**
  - **API 设计原则**：受控 vs 非受控。
  - **主题系统 (Theming)**：Design Tokens。
  - **按需加载**：Tree-shaking。

#### 1. 受控与非受控的统一模式 (Inversion of Control)

```javascript
// ─────────────────────────────────────────────────
//  useControllableState — 组件库常用 Hook
// ─────────────────────────────────────────────────

function useControllableState({ value, defaultValue, onChange }) {
  const [uncontrolledValue, setUncontrolledValue] = useState(defaultValue);

  // 是否受控：外部传入了 value
  const isControlled = value !== undefined;
  const currentValue = isControlled ? value : uncontrolledValue;

  const handleChange = (newValue) => {
    if (!isControlled) {
      setUncontrolledValue(newValue);
    }
    onChange?.(newValue);
  };

  return [currentValue, handleChange];
}
```

#### 2. 主题系统：Design Tokens

```css
/* ─────────────────────────────────────────────────
   Theme System — CSS Variables & Tokens
   ───────────────────────────────────────────────── */
:root {
  --color-primary: #3b82f6;
  --spacing-md: 16px;
  --radius-sm: 4px;
}

[data-theme="dark"] {
  --color-primary: #60a5fa;
  --bg-base: #111827;
}

.btn {
  background: var(--color-primary);
  border-radius: var(--radius-sm);
}
```

---

### 3.5.3 CLI 脚手架工具开发 ⭐⭐⭐

**要求：** 开发一套代码生成与环境初始化的命令行工具。

- **技术栈要求：**
  - **指令解析**：Commander。
  - **插件机制**：Tapable (类似 Webpack)。

#### 1. 插件化脚手架架构 (Tapable 实践)

```javascript
// ─────────────────────────────────────────────────
//  CliEngine — 插件化架构实现
// ─────────────────────────────────────────────────

const { SyncHook, AsyncSeriesHook } = require("tapable");

class CliEngine {
  constructor() {
    this.hooks = {
      init: new SyncHook(["config"]),
      beforeGenerate: new AsyncSeriesHook(["context"]),
      afterGenerate: new SyncHook(["result"]),
    };
  }

  async run() {
    this.hooks.init.call(this.config);
    const context = { files: [] };

    // 执行插件：如添加 Git、安装依赖、生成自定义文件
    await this.hooks.beforeGenerate.promise(context);

    this._generateFiles(context);
    this.hooks.afterGenerate.call("Success");
  }
}

// 插件例子：一键初始化 Git
class GitPlugin {
  apply(compiler) {
    compiler.hooks.beforeGenerate.tapPromise("GitPlugin", async (ctx) => {
      await execa("git", ["init"]);
    });
  }
}
```

---

### 3.5.4 AST 应用与代码重构 ⭐⭐⭐⭐

**要求：** 利用抽象语法树 (AST) 进行代码的转换与自动修复。

- **实战场景：**
  - **Babel 插件**：埋点注入。
  - **ESLint 规则**：静态检测。
  - **Codemod**：自动迁移。

#### 1. 简易 Babel 插件：自动插入 `console.log` 追踪

```javascript
// ─────────────────────────────────────────────────
//  BabelPlugin — AST 转换示例
// ─────────────────────────────────────────────────

module.exports = function ({ types: t }) {
  return {
    visitor: {
      FunctionDeclaration(path) {
        const funcName = path.node.id.name;
        // 在函数体开头插入 console.log("Entering funcName")
        path
          .get("body")
          .unshiftContainer(
            "body",
            t.expressionStatement(
              t.callExpression(
                t.memberExpression(
                  t.identifier("console"),
                  t.identifier("log"),
                ),
                [t.stringLiteral(`Entering function: ${funcName}`)],
              ),
            ),
          );
      },
    },
  };
};
```

> **本质洞察**：AST 是 **"代码的解剖图"**。Babel 转换本质是 **"剪切与粘帖"** 节点。只要看透了 `Program -> Body -> Declaration -> Expression` 的层级结构，所有的自动化重构（Codemod）和静态分析都不过是树的深度优先遍历（DFS）。

---

## 质量指标

- **扩展性**：工具链是否采用了松耦合的插件化设计。
- **易用性**：CLI 报错是否具备明确的行动导向。
- **稳定性**：自动化工具是否通过了完备的边缘情况单测。
