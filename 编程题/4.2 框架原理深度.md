<!--
- [INPUT]: 依赖 React/Vue 框架原理
- [OUTPUT]: 框架原理深度解析与对比
- [POS]: 编程题模块 - 框架原理
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 4.2 框架原理深度

理解框架原理不是为了重造轮子，而是为了在框架行为异常时能"开颅"定位，在性能瓶颈时能精准施刀。

---

## 4.2.1 React 深度 ⭐⭐⭐⭐

| 主题                | 要点               |
| :------------------ | :----------------- |
| **Fiber 架构**      | 可中断、时间分片   |
| **Hooks 原理**      | 链表、规则限制原因 |
| **合成事件**        | 事件委托、池化     |
| **Concurrent Mode** | 优先级调度         |
| **Suspense**        | 数据获取、代码分割 |
| **Scheduler**       | 任务调度           |

### 1. Fiber 架构核心：可中断的递归

```javascript
// ─────────────────────────────────────────────────
//  SimplifiedFiber — Fiber 架构简化模型
// ─────────────────────────────────────────────────

// Fiber 节点：把递归树拆成链表
class FiberNode {
  constructor(element) {
    this.type = element.type; // 组件类型
    this.props = element.props; // 属性
    this.stateNode = null; // 真实 DOM
    this.child = null; // 第一个子节点
    this.sibling = null; // 下一个兄弟节点
    this.return = null; // 父节点
    this.alternate = null; // 旧 Fiber（双缓冲）
    this.effectTag = null; // 副作用标记
    this.hooks = []; // Hooks 链表
  }
}

// ── 工作循环：时间分片的核心 ────────────────────
let nextUnitOfWork = null;
let wipRoot = null; // Work In Progress Root

function workLoop(deadline) {
  let shouldYield = false;

  while (nextUnitOfWork && !shouldYield) {
    // 处理一个 Fiber 单元
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    // 检查剩余时间（关键：可中断点）
    shouldYield = deadline.timeRemaining() < 1;
  }

  if (!nextUnitOfWork && wipRoot) {
    // 所有 Fiber 处理完毕 → 一次性提交 DOM
    commitRoot();
  }

  requestIdleCallback(workLoop);
}

requestIdleCallback(workLoop);

// ── 单元工作：深度优先遍历 ──────────────────────
function performUnitOfWork(fiber) {
  // 1. 执行组件函数 / 创建 DOM
  if (typeof fiber.type === "function") {
    updateFunctionComponent(fiber);
  } else {
    updateHostComponent(fiber);
  }

  // 2. 返回下一个工作单元（深度优先）
  if (fiber.child) return fiber.child;

  let nextFiber = fiber;
  while (nextFiber) {
    if (nextFiber.sibling) return nextFiber.sibling;
    nextFiber = nextFiber.return;
  }
  return null;
}
```

### 2. Hooks 原理：链表 + 闭包

```javascript
// ─────────────────────────────────────────────────
//  Hooks 原理 — 为什么 Hooks 不能放在条件语句中
// ─────────────────────────────────────────────────

let wipFiber = null;
let hookIndex = null;

function updateFunctionComponent(fiber) {
  wipFiber = fiber;
  hookIndex = 0; // 每次渲染重置 Hook 索引
  wipFiber.hooks = [];
  // 执行函数组件
  const children = fiber.type(fiber.props);
  reconcileChildren(fiber, children);
}

// ── useState 简化实现 ───────────────────────────
function useState(initialValue) {
  // 从旧 Fiber 的 hooks 链表中按索引取旧状态
  const oldHook = wipFiber.alternate?.hooks?.[hookIndex];

  const hook = {
    state: oldHook ? oldHook.state : initialValue,
    queue: [], // 更新队列
  };

  // 执行所有排队的 setState
  (oldHook?.queue || []).forEach((action) => {
    hook.state = typeof action === "function" ? action(hook.state) : action;
  });

  const setState = (action) => {
    hook.queue.push(action);
    // 触发重新渲染
    wipRoot = { ...currentRoot, alternate: currentRoot };
    nextUnitOfWork = wipRoot;
  };

  wipFiber.hooks.push(hook);
  hookIndex++;
  return [hook.state, setState];
}

// ── 为什么不能放在条件语句中？ ──────────────────
// 因为 Hooks 用「数组索引」定位状态：
// 第 1 次调用 useState → hookIndex = 0
// 第 2 次调用 useState → hookIndex = 1
// 如果加了 if，第二次渲染可能跳过第 1 个 Hook，
// 导致 hookIndex=0 拿到了本应 hookIndex=1 的状态。
// 链表错位 → 整个状态系统崩溃。
```

### 3. React Scheduler：优先级调度

```javascript
// ─────────────────────────────────────────────────
//  SimpleScheduler — React 调度器原理
// ─────────────────────────────────────────────────

const PRIORITY = {
  IMMEDIATE: 1, // 同步（用户输入）
  USER_BLOCKING: 2, // 250ms（点击响应）
  NORMAL: 3, // 5s（数据更新）
  LOW: 4, // 10s（不太重要）
  IDLE: 5, // 永不过期（预加载）
};

const TIMEOUT_MAP = {
  1: -1, // 立即过期
  2: 250,
  3: 5000,
  4: 10000,
  5: Infinity,
};

class SimpleScheduler {
  constructor() {
    this.taskQueue = []; // 最小堆（按过期时间排序）
    this.isPerforming = false;
  }

  scheduleTask(priority, callback) {
    const task = {
      callback,
      priority,
      expirationTime: performance.now() + TIMEOUT_MAP[priority],
    };

    this.taskQueue.push(task);
    this.taskQueue.sort((a, b) => a.expirationTime - b.expirationTime);

    if (!this.isPerforming) {
      this.isPerforming = true;
      this._flushWork();
    }
  }

  _flushWork() {
    const channel = new MessageChannel();
    channel.port2.onmessage = () => {
      const startTime = performance.now();

      while (this.taskQueue.length > 0) {
        const task = this.taskQueue[0];
        // 时间片用完且未过期 → 让出主线程
        if (
          performance.now() - startTime > 5 &&
          task.expirationTime > performance.now()
        ) {
          break;
        }
        task.callback();
        this.taskQueue.shift();
      }

      if (this.taskQueue.length > 0) {
        channel.port2.postMessage(null); // 继续下一帧
      } else {
        this.isPerforming = false;
      }
    };
    channel.port2.postMessage(null);
  }
}
```

> **本质洞察**：React 的进化史就是 **「从同步到异步」** 的转型。Stack Reconciler 是递归的、同步的、不可中断的。Fiber 把它重写为链表的、异步的、可中断的。这个改造等价于把操作系统从 **协作式多任务** 升级为 **抢占式多任务**。Scheduler 是 React 自己写的"操作系统调度器"，用 `MessageChannel` 实现宏任务切换（比 `setTimeout(0)` 更精确，最小延迟约 1ms 而非 4ms）。

---

## 4.2.2 Vue 深度 ⭐⭐⭐⭐

| 主题          | 要点                         |
| :------------ | :--------------------------- |
| **响应式**    | effect / track / trigger     |
| **编译优化**  | 静态提升 / patchFlag / Block |
| **diff 算法** | 最长递增子序列               |
| **KeepAlive** | 缓存管理                     |
| **Teleport**  | Portal 实现                  |

### 1. Vue 3 响应式核心

```javascript
// ─────────────────────────────────────────────────
//  Reactivity — Vue 3 响应式系统简化实现
// ─────────────────────────────────────────────────

let activeEffect = null;
const targetMap = new WeakMap(); // 全局依赖存储

// ── effect：副作用注册 ──────────────────────────
function effect(fn) {
  const effectFn = () => {
    activeEffect = effectFn;
    fn(); // 执行函数，触发 getter → track
    activeEffect = null;
  };
  effectFn();
}

// ── track：依赖收集 ─────────────────────────────
function track(target, key) {
  if (!activeEffect) return;

  let depsMap = targetMap.get(target);
  if (!depsMap) {
    depsMap = new Map();
    targetMap.set(target, depsMap);
  }

  let deps = depsMap.get(key);
  if (!deps) {
    deps = new Set();
    depsMap.set(key, deps);
  }
  deps.add(activeEffect);
  // target → key → Set<effect> 三层结构
}

// ── trigger：派发更新 ────────────────────────────
function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  const deps = depsMap.get(key);
  deps?.forEach((effect) => effect());
}

// ── reactive：创建响应式对象 ────────────────────
function reactive(target) {
  return new Proxy(target, {
    get(obj, key, receiver) {
      track(obj, key); // 读取时收集依赖
      const result = Reflect.get(obj, key, receiver);
      // 深度代理：嵌套对象懒代理
      return typeof result === "object" && result !== null
        ? reactive(result)
        : result;
    },
    set(obj, key, value, receiver) {
      const oldValue = obj[key];
      const result = Reflect.set(obj, key, value, receiver);
      if (oldValue !== value) {
        trigger(obj, key); // 写入时触发更新
      }
      return result;
    },
  });
}

// ── 验证 ────────────────────────────────────────
const state = reactive({ count: 0, text: "hello" });
effect(() => console.log("count:", state.count)); // 自动执行
state.count++; // 打印 "count: 1"
```

### 2. Vue diff：最长递增子序列 (LIS)

```javascript
// ─────────────────────────────────────────────────
//  LIS — Vue 3 diff 算法核心
// ─────────────────────────────────────────────────
// 目的：找出最少的 DOM 移动操作

// 贪心 + 二分：O(n log n)
function getSequence(arr) {
  const result = [0]; // 存储索引
  const predecessor = arr.slice(); // 前驱记录

  for (let i = 0; i < arr.length; i++) {
    const current = arr[i];
    if (current === 0) continue;

    const lastIdx = result[result.length - 1];
    // 如果比最后一个大，直接追加
    if (arr[lastIdx] < current) {
      predecessor[i] = result[result.length - 1];
      result.push(i);
      continue;
    }

    // 否则用二分查找替换第一个 >= current 的位置
    let lo = 0,
      hi = result.length - 1;
    while (lo < hi) {
      const mid = (lo + hi) >> 1;
      if (arr[result[mid]] < current) lo = mid + 1;
      else hi = mid;
    }

    if (current < arr[result[lo]]) {
      if (lo > 0) predecessor[i] = result[lo - 1];
      result[lo] = i;
    }
  }

  // 回溯得到正确序列
  let len = result.length;
  let last = result[len - 1];
  while (len-- > 0) {
    result[len] = last;
    last = predecessor[last];
  }
  return result;
}

// 作用：新列表 [c, a, b, d, e] 中 LIS = [a, b, d, e]
// 只需要移动 c，其余保持不动。移动次数 = 总数 - LIS 长度
```

> **本质洞察**：Vue 和 React 代表了两种哲学路线。React 是 **「运行时方案」** —— 通过 Fiber 架构在运行时做调度和 diff。Vue 是 **「编译期 + 运行时」** —— 通过模板编译在编译期标注 patchFlag（哪些是动态的）、做静态提升（不变内容直接跳过），让运行时的 diff 工作量骤降。LIS 算法在 diff 中的应用则说明了一个数学事实：**最少 DOM 移动次数 = 列表长度 - 最长递增子序列长度**。

---

## 4.2.3 通用框架原理 ⭐⭐⭐

### 1. 虚拟 DOM diff 对比

```javascript
// ─────────────────────────────────────────────────
//  SimplifiedDiff — 虚拟 DOM diff 基础算法
// ─────────────────────────────────────────────────

function diff(oldVNode, newVNode) {
  // 1. 类型不同 → 直接替换
  if (oldVNode.type !== newVNode.type) {
    return { type: "REPLACE", newVNode };
  }

  // 2. 文本节点
  if (typeof newVNode === "string") {
    if (oldVNode !== newVNode) {
      return { type: "TEXT", content: newVNode };
    }
    return null;
  }

  // 3. 属性 diff
  const propPatches = diffProps(oldVNode.props, newVNode.props);

  // 4. 子节点 diff（简化版：按索引对比）
  const childPatches = diffChildren(
    oldVNode.children || [],
    newVNode.children || [],
  );

  return { type: "UPDATE", propPatches, childPatches };
}

// ── 批量更新机制（React 原理） ──────────────────
class BatchUpdate {
  constructor() {
    this.isBatching = false;
    this.pendingStates = [];
  }

  // React 事件处理中自动开启批量
  batchedUpdates(fn) {
    this.isBatching = true;
    fn(); // 执行所有 setState，但不立即渲染
    this.isBatching = false;
    this._flush(); // 一次性渲染
  }

  enqueueState(component, partialState) {
    this.pendingStates.push({ component, partialState });
    if (!this.isBatching) {
      this._flush(); // 非批量模式立即更新
    }
  }

  _flush() {
    // 合并相同组件的多次 setState
    const updates = new Map();
    this.pendingStates.forEach(({ component, partialState }) => {
      const prev = updates.get(component) || component.state;
      updates.set(component, { ...prev, ...partialState });
    });

    updates.forEach((newState, component) => {
      component.state = newState;
      component.render(); // 每个组件只渲染一次
    });
    this.pendingStates = [];
  }
}
```

> **本质洞察**：所有现代前端框架都在回答同一个问题 —— **「如何高效地把状态映射到 UI？」**。Virtual DOM 的 diff 是一种 **"懒更新"**策略：先在内存中算出差异，再一次性批量操作真实 DOM。批量更新的本质是 **"合并写操作"** —— 和数据库的 WAL（Write-Ahead Log）异曲同工。理解了这个本质，你就明白为什么 `setState` 是"异步"的 —— 它不是真的异步，而是被"攒起来了"。

---

## 质量指标

- **原理深度**：能否从源码层面解释框架行为。
- **问题定位**：遇到框架异常时能否准确定位到内部机制。
- **性能优化**：能否基于框架原理做针对性的性能调优。
