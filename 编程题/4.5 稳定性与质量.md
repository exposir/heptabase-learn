<!--
- [INPUT]: 依赖前端工程化与运维知识
- [OUTPUT]: 稳定性保障与质量体系
- [POS]: 编程题模块 - 稳定性与质量
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 4.5 稳定性与质量

线上稳定性不是"0 Bug"，而是"出了 Bug 能兜住"。韧性 (Resilience) 比完美更重要。

---

## 4.5.1 前端容灾方案 ⭐⭐⭐

### 策略

- **CDN 多源容灾**
- **资源加载重试**
- **接口降级兜底**
- **核心链路保护**
- **Error Boundary**

### 1. 资源加载容灾系统

```javascript
// ─────────────────────────────────────────────────
//  ResourceFallback — 多源容灾 + 自动重试
// ─────────────────────────────────────────────────

class ResourceFallback {
  constructor(cdnList) {
    // 多 CDN 源，按优先级排序
    this.cdnList = cdnList; // ["https://cdn1.com", "https://cdn2.com", "https://backup.com"]
    this.maxRetry = 2;
  }

  // ── 加载 JS 资源（带容灾） ────────────────────
  async loadScript(path) {
    for (const cdn of this.cdnList) {
      for (let retry = 0; retry <= this.maxRetry; retry++) {
        try {
          await this._injectScript(`${cdn}${path}`);
          return; // 成功则立即返回
        } catch (e) {
          console.warn(`加载失败 (${cdn}, 重试 ${retry}):`, e.message);
        }
      }
    }
    // 所有 CDN 全部失败 → 展示降级 UI
    this._showFallbackUI();
  }

  _injectScript(src) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  _showFallbackUI() {
    document.body.innerHTML = `
      <div style="text-align:center;padding:40px;">
        <h2>页面加载异常</h2>
        <p>请检查网络连接后刷新重试</p>
        <button onclick="location.reload()">刷新页面</button>
      </div>
    `;
  }
}

// ── 全局资源失败监听 ────────────────────────────
window.addEventListener(
  "error",
  (e) => {
    const target = e.target;
    if (target.tagName === "SCRIPT" || target.tagName === "LINK") {
      // 自动切换备用 CDN
      const fallback = new ResourceFallback(["https://cdn-backup.example.com"]);
      fallback.loadScript(new URL(target.src || target.href).pathname);
    }
  },
  true,
);
```

### 2. React Error Boundary 与降级

```javascript
// ─────────────────────────────────────────────────
//  ErrorBoundary — 组件级错误隔离
// ─────────────────────────────────────────────────

class ErrorBoundary extends React.Component {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // 上报错误（不影响 UI 降级）
    reportError({
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
    });
  }

  render() {
    if (this.state.hasError) {
      // 渲染降级 UI 而不是白屏
      return (
        this.props.fallback || (
          <div className="error-fallback">
            <h3>此模块暂时不可用</h3>
            <button onClick={() => this.setState({ hasError: false })}>
              重试
            </button>
          </div>
        )
      );
    }
    return this.props.children;
  }
}

// ── 使用：关键模块分区隔离 ──────────────────────
function App() {
  return (
    <div>
      <Header /> {/* 头部挂了不影响内容 */}
      <ErrorBoundary fallback={<div>推荐加载失败</div>}>
        <RecommendationModule />
      </ErrorBoundary>
      <ErrorBoundary fallback={<div>评论加载失败</div>}>
        <CommentSection />
      </ErrorBoundary>
    </div>
  );
}
```

> **本质洞察**：容灾的哲学是 **「隔舱设计」** —— 泰坦尼克号的教训。一个模块沉没不能拖垮整艘船。Error Boundary 是 React 的"水密舱门"，CDN 多源是"备用引擎"，接口降级是"救生艇"。系统设计的最高境界不是"永不出错"，而是 **"出了错还能体面地活着"**。

---

## 4.5.2 前端测试策略 ⭐⭐⭐

| 类型         | 工具               | 覆盖范围  |
| :----------- | :----------------- | :-------- |
| **单元测试** | Jest               | 函数/组件 |
| **集成测试** | Testing Library    | 模块交互  |
| **E2E**      | Cypress/Playwright | 完整流程  |
| **视觉测试** | Chromatic          | UI 回归   |

### 1. 测试金字塔实践

```javascript
// ─────────────────────────────────────────────────
//  Testing Pyramid — 三层测试实战
// ─────────────────────────────────────────────────

// ── Layer 1: 单元测试（底层，最多） ─────────────
// 纯函数测试：快、稳、多
describe("formatPrice", () => {
  test("正常格式化", () => {
    expect(formatPrice(1234.5)).toBe("¥1,234.50");
  });
  test("处理零值", () => {
    expect(formatPrice(0)).toBe("¥0.00");
  });
  test("处理负数", () => {
    expect(formatPrice(-99)).toBe("-¥99.00");
  });
});

// 自定义 Hook 测试
import { renderHook, act } from "@testing-library/react";

describe("useDebounce", () => {
  test("延迟更新值", () => {
    jest.useFakeTimers();
    const { result } = renderHook(() => useDebounce("hello", 300));

    expect(result.current).toBe("hello");

    act(() => jest.advanceTimersByTime(300));
    expect(result.current).toBe("hello");
  });
});

// ── Layer 2: 集成测试（中层） ───────────────────
// 测试组件间的交互，不 mock 子组件
import { render, screen, fireEvent } from "@testing-library/react";

describe("LoginForm", () => {
  test("用户名为空时禁用提交按钮", () => {
    render(<LoginForm />);
    const submitBtn = screen.getByRole("button", { name: "登录" });
    expect(submitBtn).toBeDisabled();

    fireEvent.change(screen.getByLabelText("用户名"), {
      target: { value: "admin" },
    });
    fireEvent.change(screen.getByLabelText("密码"), {
      target: { value: "123456" },
    });

    expect(submitBtn).toBeEnabled();
  });

  test("提交后显示加载状态", async () => {
    render(<LoginForm />);
    // 填写表单...
    fireEvent.click(screen.getByRole("button", { name: "登录" }));
    expect(await screen.findByText("登录中...")).toBeInTheDocument();
  });
});

// ── Layer 3: E2E 测试（顶层，最少） ─────────────
// Playwright 示例
import { test, expect } from "@playwright/test";

test("完整购物流程", async ({ page }) => {
  await page.goto("/products");
  await page.click('[data-testid="product-1"]');
  await page.click("text=加入购物车");
  await page.goto("/cart");
  await expect(page.locator(".cart-count")).toHaveText("1");
  await page.click("text=去结算");
  await expect(page).toHaveURL(/checkout/);
});
```

> **本质洞察**：测试金字塔的三层对应三种信心层次：单元测试验证 **"每块砖是好的"**，集成测试验证 **"砖和砖粘得住"**，E2E 测试验证 **"房子能住人"**。测试策略的核心决策是 **ROI（投入产出比）**：单元测试写得快跑得快但覆盖面窄，E2E 测试覆盖面广但维护成本高且脆弱。正确的比例应该是 70:20:10。

---

## 4.5.3 灰度与 A/B 测试 ⭐⭐⭐

### 设计

- **Feature Flag 系统**
- **用户分桶算法**
- **数据采集**
- **紧急关闭开关**

### 1. Feature Flag 与灰度发布

```javascript
// ─────────────────────────────────────────────────
//  FeatureFlag — 灰度发布系统
// ─────────────────────────────────────────────────

class FeatureFlagSDK {
  constructor(config) {
    this.flags = {}; // 特性开关配置
    this.userId = config.userId;
    this.pollInterval = config.pollInterval || 60_000;
    this._startPolling(config.endpoint);
  }

  // ── 判断特性是否开启 ──────────────────────────
  isEnabled(flagName) {
    const flag = this.flags[flagName];
    if (!flag) return false;

    // 全局关闭（紧急开关）
    if (flag.killed) return false;

    // 白名单用户
    if (flag.whitelist?.includes(this.userId)) return true;

    // 灰度百分比
    if (flag.percentage !== undefined) {
      return this._hashUser(this.userId, flagName) < flag.percentage;
    }

    return flag.enabled;
  }

  // ── 哈希分桶：确保同一用户始终在同一桶 ────────
  _hashUser(userId, flagName) {
    const str = `${userId}:${flagName}`;
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = ((hash << 5) - hash + str.charCodeAt(i)) | 0;
    }
    return Math.abs(hash) % 100; // 0-99
  }

  // ── 定时拉取最新配置 ──────────────────────────
  _startPolling(endpoint) {
    const fetchFlags = async () => {
      try {
        const res = await fetch(endpoint);
        this.flags = await res.json();
      } catch (e) {
        // 拉取失败保持旧配置
      }
    };
    fetchFlags();
    setInterval(fetchFlags, this.pollInterval);
  }
}

// ── 使用 ────────────────────────────────────────
const ff = new FeatureFlagSDK({
  userId: "user-123",
  endpoint: "/api/feature-flags",
});

if (ff.isEnabled("new_checkout_flow")) {
  renderNewCheckout();
} else {
  renderOldCheckout();
}
```

> **本质洞察**：灰度发布解决的是 **「如何安全地改变飞行中的飞机引擎」** 的问题。`_hashUser` 的哈希分桶保证了确定性——同一用户不会在新旧版本之间反复横跳。`killed` 字段是最重要的设计：当新功能出问题时，一个 API 调用就能全局关闭，比回滚代码快一百倍。**Feature Flag 不是技术奢侈品，而是安全网**。

---

## 质量指标

- **容灾覆盖率**：核心链路是否都有降级方案。
- **测试 ROI**：测试维护成本与捕获 Bug 数量的比值。
- **灰度粒度**：能否做到按用户/地区/设备精准灰度。
