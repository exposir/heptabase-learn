<!--
- [INPUT]: WebAssembly (Wasm), PWA Manifest, Service Workers, Web Components API
- [OUTPUT]: 新技术方向题目大纲，涵盖 Wasm 计算、PWA 离线能力及 Web Components 组件化要求
- [POS]: 编程题/ 复杂场景专题，聚焦 Web 技术的前沿演进与落地实践
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.10 新技术方向

Web 技术在性能上限（Wasm）、用户体验深度（PWA）以及组件原生化（Web Components）等方面不断突破，拓展了浏览器的边界。

---

### 3.10.1 WebAssembly (Wasm) ⭐⭐⭐

**要求：** 理解 Wasm 的适用场景，并能够设计与 JS 的通信层方案。

- **实战场景：**
  - **计算密集型任务**：利用 C++/Rust 等高性能语言编译出的 Wasm 模块，提升加密、复杂算法或图形处理的效率。
  - **现有原生库复用**：探讨将成熟的 C 库（如 ffmpeg, sqlite）引入 Web 环境的技术路径。
  - **JS/Wasm 通信开销**：理解内存分配、数据交换的最佳内存布局。

#### 1. Wasm 模块加载与 JS 通信

```javascript
// ─────────────────────────────────────────────────
//  WasmBridge — JS 与 Wasm 通信层
// ─────────────────────────────────────────────────

class WasmBridge {
  constructor() {
    this.instance = null;
    this.memory = null;
  }

  // ── 加载 Wasm 模块 ────────────────────────────
  async load(wasmUrl) {
    // 流式编译：边下载边编译，比先下载再编译快
    const response = await fetch(wasmUrl);
    const { instance } = await WebAssembly.instantiateStreaming(response, {
      env: {
        // 注入 JS 函数供 Wasm 调用
        log: (ptr, len) => {
          const str = this._readString(ptr, len);
          console.log("[Wasm]:", str);
        },
        now: () => performance.now(),
      },
    });

    this.instance = instance;
    this.memory = instance.exports.memory;
    return this;
  }

  // ── 调用 Wasm 导出函数 ────────────────────────
  call(funcName, ...args) {
    const fn = this.instance.exports[funcName];
    if (!fn) throw new Error(`Wasm 函数不存在: ${funcName}`);
    return fn(...args);
  }

  // ── 复杂数据传递：共享内存方案 ────────────────
  // Wasm 只能传递数字，复杂数据通过线性内存共享
  writeArrayToMemory(array) {
    const ptr = this.instance.exports.malloc(array.length * 4);
    const view = new Float32Array(this.memory.buffer, ptr, array.length);
    view.set(array);
    return ptr; // 返回内存指针给 Wasm
  }

  readArrayFromMemory(ptr, length) {
    return new Float32Array(this.memory.buffer, ptr, length).slice();
  }

  _readString(ptr, len) {
    const bytes = new Uint8Array(this.memory.buffer, ptr, len);
    return new TextDecoder().decode(bytes);
  }
}

// ── 使用示例：图像处理 ──────────────────────────
const wasm = await new WasmBridge().load("/image_processor.wasm");

// 将像素数据写入共享内存
const pixels = new Float32Array(imageData.data);
const ptr = wasm.writeArrayToMemory(pixels);

// 调用 Wasm 处理（速度是纯 JS 的 10-50 倍）
wasm.call("apply_blur", ptr, imageData.width, imageData.height, 5);

// 读回处理结果
const result = wasm.readArrayFromMemory(ptr, pixels.length);
```

#### 2. Wasm + Worker：不阻塞主线程

```javascript
// ─────────────────────────────────────────────────
//  WasmWorker — Wasm 运行在 Web Worker 中
// ─────────────────────────────────────────────────

// worker.js
self.onmessage = async (e) => {
  const { type, wasmUrl, func, data } = e.data;

  if (type === "init") {
    const response = await fetch(wasmUrl);
    self.wasmInstance = await WebAssembly.instantiateStreaming(response, {});
    self.postMessage({ type: "ready" });
  }

  if (type === "compute") {
    const exports = self.wasmInstance.instance.exports;
    const result = exports[func](...data);
    self.postMessage({ type: "result", result });
  }
};

// main.js — 主线程调用
class WasmWorkerPool {
  constructor(wasmUrl, poolSize = navigator.hardwareConcurrency || 4) {
    this.workers = [];
    this.queue = [];
    this.idle = [];

    for (let i = 0; i < poolSize; i++) {
      const worker = new Worker("worker.js");
      worker.postMessage({ type: "init", wasmUrl });
      this.workers.push(worker);
      this.idle.push(worker);
    }
  }

  async compute(func, data) {
    const worker = await this._getIdleWorker();

    return new Promise((resolve) => {
      worker.onmessage = (e) => {
        if (e.data.type === "result") {
          this.idle.push(worker);
          this._processQueue();
          resolve(e.data.result);
        }
      };
      worker.postMessage({ type: "compute", func, data });
    });
  }

  async _getIdleWorker() {
    if (this.idle.length > 0) return this.idle.pop();
    return new Promise((resolve) => this.queue.push(resolve));
  }

  _processQueue() {
    if (this.queue.length > 0 && this.idle.length > 0) {
      const resolve = this.queue.shift();
      resolve(this.idle.pop());
    }
  }
}
```

> **本质洞察**：Wasm 不是来替代 JS 的，而是来 **补齐 JS 的短板** 的。JS 擅长 DOM 操作和胶水逻辑，但在纯计算场景（加密、图像处理、物理引擎）性能受制于动态类型和 GC。Wasm 的本质是 **「浏览器里的第二 CPU 指令集」** —— 静态类型、无 GC、接近原生速度。JS 和 Wasm 之间的通信开销（跨越内存边界）决定了最佳实践是 **「大块数据一次传入，密集计算在 Wasm 侧完成，结果一次返回」**，频繁的小粒度跨界调用会丧失所有性能优势。

---

### 3.10.2 PWA (Progressive Web Apps) ⭐⭐⭐

**要求：** 构建一个具备离线能力与原生化体验的 Web 应用。

- **核心功能：**
  - **Service Worker**：实现多场景的离线缓存策略（Cache First, Network First, Stale-While-Revalidate）。
  - **App Manifest 配置**：优化安装体验，实现全屏启动与主题配色适配。
  - **离线页面处理**：设计网络断开后的优雅降级反馈。
  - **推送通知 (Web Push)**：理解与后台服务的长连接通信与用户授权流程。

#### 1. Service Worker 多策略缓存

```javascript
// ─────────────────────────────────────────────────
//  ServiceWorker — 多场景缓存策略引擎
// ─────────────────────────────────────────────────

const CACHE_NAME = "app-v1";
const STATIC_ASSETS = ["/", "/index.html", "/app.js", "/style.css"];

// ── 安装：预缓存核心资源 ────────────────────────
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(STATIC_ASSETS);
    }),
  );
  self.skipWaiting(); // 立即激活，不等旧 SW 退出
});

// ── 激活：清理旧缓存 ────────────────────────────
self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches
      .keys()
      .then((keys) =>
        Promise.all(
          keys
            .filter((key) => key !== CACHE_NAME)
            .map((key) => caches.delete(key)),
        ),
      ),
  );
  self.clients.claim(); // 立即接管所有页面
});

// ── 请求拦截：分策略处理 ────────────────────────
self.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);

  // 静态资源 → Cache First（缓存优先）
  if (STATIC_ASSETS.some((asset) => url.pathname.endsWith(asset))) {
    event.respondWith(cacheFirst(event.request));
    return;
  }

  // API 请求 → Network First（网络优先）
  if (url.pathname.startsWith("/api/")) {
    event.respondWith(networkFirst(event.request));
    return;
  }

  // 其他资源 → Stale While Revalidate（先返回缓存，后台更新）
  event.respondWith(staleWhileRevalidate(event.request));
});

// ── 策略 1: Cache First ─────────────────────────
async function cacheFirst(request) {
  const cached = await caches.match(request);
  if (cached) return cached;

  try {
    const response = await fetch(request);
    const cache = await caches.open(CACHE_NAME);
    cache.put(request, response.clone());
    return response;
  } catch {
    return new Response("离线不可用", { status: 503 });
  }
}

// ── 策略 2: Network First ───────────────────────
async function networkFirst(request) {
  try {
    const response = await fetch(request);
    const cache = await caches.open(CACHE_NAME);
    cache.put(request, response.clone());
    return response;
  } catch {
    const cached = await caches.match(request);
    return cached || offlineFallback();
  }
}

// ── 策略 3: Stale While Revalidate ──────────────
async function staleWhileRevalidate(request) {
  const cache = await caches.open(CACHE_NAME);
  const cached = await cache.match(request);

  // 后台更新（不阻塞响应）
  const networkPromise = fetch(request)
    .then((response) => {
      cache.put(request, response.clone());
      return response;
    })
    .catch(() => null);

  // 有缓存就先返回缓存，没有就等网络
  return cached || networkPromise;
}

// ── 离线降级页面 ────────────────────────────────
function offlineFallback() {
  return caches.match("/offline.html");
}
```

#### 2. Web Push 推送通知

```javascript
// ─────────────────────────────────────────────────
//  WebPush — 推送通知实现
// ─────────────────────────────────────────────────

// 客户端：订阅推送
async function subscribePush() {
  const registration = await navigator.serviceWorker.ready;

  // 请求通知权限
  const permission = await Notification.requestPermission();
  if (permission !== "granted") return null;

  // 创建推送订阅
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true, // 必须展示通知
    applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY),
  });

  // 发送订阅信息到服务端
  await fetch("/api/push/subscribe", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(subscription),
  });

  return subscription;
}

// Service Worker 中接收推送
self.addEventListener("push", (event) => {
  const data = event.data?.json() || {};
  event.waitUntil(
    self.registration.showNotification(data.title || "通知", {
      body: data.body,
      icon: data.icon || "/icon-192.png",
      badge: "/badge.png",
      data: { url: data.url }, // 点击跳转的 URL
    }),
  );
});

// 点击通知处理
self.addEventListener("notificationclick", (event) => {
  event.notification.close();
  const url = event.notification.data?.url || "/";
  event.waitUntil(clients.openWindow(url));
});
```

> **本质洞察**：PWA 的核心理念是 **「渐进增强」** —— 在支持的环境中提供原生体验，在不支持的环境中优雅降级为普通网页。Service Worker 是 PWA 的灵魂，它本质是一个 **「可编程的网络代理」**，位于浏览器和网络之间，拦截所有 HTTP 请求。三种缓存策略对应三种业务场景：**Cache First** 适合不变的静态资源，**Network First** 适合需要最新数据的 API，**Stale While Revalidate** 是体验和新鲜度的平衡术 —— 先给用户看"旧的"，同时在后台偷偷更新。

---

### 3.10.3 Web Components ⭐⭐

**要求：** 掌握原生组件技术，实现在无框架环境下的组件化开发。

- **核心技术：**
  - **Custom Elements**：定义原生标签的生命周期与属性监听。
  - **Shadow DOM**：实现严格的样式与逻辑隔离，探索内联样式的封装。
  - **HTML Templates**：利用 `<template>` 实现结构的复用。
  - **框架集成**：如何在 React/Vue 等现代框架中无缝消费原生 Web Components。

#### 1. 完整的 Web Component 实现

```javascript
// ─────────────────────────────────────────────────
//  CustomElement — 原生 Web Component 实现
// ─────────────────────────────────────────────────

class AppDialog extends HTMLElement {
  // ── 声明要监听的属性 ──────────────────────────
  static get observedAttributes() {
    return ["open", "title"];
  }

  constructor() {
    super();
    // 创建 Shadow DOM（样式与外界完全隔离）
    this.shadow = this.attachShadow({ mode: "open" });

    // 使用 template 定义结构
    const template = document.createElement("template");
    template.innerHTML = `
      <style>
        :host {
          /* :host 选择器选中组件自身 */
          display: block;
          position: fixed;
          inset: 0;
          z-index: 1000;
        }

        :host([hidden]) { display: none; }

        .overlay {
          position: fixed;
          inset: 0;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .dialog {
          background: white;
          border-radius: 12px;
          padding: 24px;
          min-width: 320px;
          max-width: 90vw;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .title {
          font-size: 18px;
          font-weight: 600;
          margin-bottom: 16px;
        }

        /* ::slotted 用来样式化外部插入的内容 */
        ::slotted(*) {
          margin: 8px 0;
        }

        .actions {
          display: flex;
          justify-content: flex-end;
          gap: 8px;
          margin-top: 24px;
        }
      </style>

      <div class="overlay" part="overlay">
        <div class="dialog" part="dialog">
          <div class="title" id="title"></div>
          <slot></slot>  <!-- 默认插槽：内容由外部注入 -->
          <div class="actions">
            <slot name="actions">
              <button id="close-btn">关闭</button>
            </slot>
          </div>
        </div>
      </div>
    `;

    this.shadow.appendChild(template.content.cloneNode(true));
  }

  // ── 生命周期：组件挂载到 DOM ──────────────────
  connectedCallback() {
    this._updateTitle();
    this._updateVisibility();

    // 绑定事件
    this.shadow
      .querySelector("#close-btn")
      ?.addEventListener("click", () => this._close());
    this.shadow.querySelector(".overlay").addEventListener("click", (e) => {
      if (e.target === e.currentTarget) this._close();
    });
  }

  // ── 生命周期：属性变更 ────────────────────────
  attributeChangedCallback(name, oldVal, newVal) {
    if (name === "title") this._updateTitle();
    if (name === "open") this._updateVisibility();
  }

  // ── 生命周期：组件从 DOM 移除 ─────────────────
  disconnectedCallback() {
    // 清理事件、定时器等资源
  }

  _updateTitle() {
    const titleEl = this.shadow.querySelector("#title");
    if (titleEl) titleEl.textContent = this.getAttribute("title") || "";
  }

  _updateVisibility() {
    this.hidden = !this.hasAttribute("open");
  }

  _close() {
    this.removeAttribute("open");
    // 派发自定义事件供外部监听
    this.dispatchEvent(
      new CustomEvent("dialog-close", { bubbles: true, composed: true }),
    );
  }

  // ── 公开 API ──────────────────────────────────
  show() {
    this.setAttribute("open", "");
  }

  hide() {
    this.removeAttribute("open");
  }
}

// 注册自定义元素
customElements.define("app-dialog", AppDialog);
```

#### 2. 在 React 中消费 Web Components

```javascript
// ─────────────────────────────────────────────────
//  React Wrapper — 框架集成 Web Components
// ─────────────────────────────────────────────────

import React, { useRef, useEffect } from "react";

function ReactDialog({ open, title, onClose, children }) {
  const dialogRef = useRef(null);

  useEffect(() => {
    const el = dialogRef.current;
    if (!el) return;

    // 监听 Web Component 自定义事件
    const handler = () => onClose?.();
    el.addEventListener("dialog-close", handler);
    return () => el.removeEventListener("dialog-close", handler);
  }, [onClose]);

  // React 不能直接设置 boolean attribute，需要手动处理
  useEffect(() => {
    if (open) {
      dialogRef.current?.setAttribute("open", "");
    } else {
      dialogRef.current?.removeAttribute("open");
    }
  }, [open]);

  return (
    <app-dialog ref={dialogRef} title={title}>
      {children}
    </app-dialog>
  );
}

// ── 使用 ────────────────────────────────────────
function App() {
  const [showDialog, setShowDialog] = React.useState(false);

  return (
    <>
      <button onClick={() => setShowDialog(true)}>打开对话框</button>
      <ReactDialog
        open={showDialog}
        title="确认操作"
        onClose={() => setShowDialog(false)}
      >
        <p>确定要执行此操作吗？</p>
      </ReactDialog>
    </>
  );
}
```

> **本质洞察**：Web Components 解答了一个根本性问题 ——**「组件化一定需要框架吗？」**。答案是不需要。Custom Elements 提供了生命周期，Shadow DOM 提供了隔离，Slots 提供了组合。这三者加在一起就是一个 **浏览器原生的组件系统**。它的最大价值不在于替代 React/Vue，而在于 **跨框架复用** —— 用 Web Components 写的组件可以在 React、Vue、Angular 甚至纯 HTML 中使用，这是任何框架组件都做不到的。`::slotted`、`:host`、`part` 这些 CSS 伪类构成了 Shadow DOM 的 **"样式外交协议"** —— 组件内部样式不泄露，但允许外部通过特定通道定制。

---

## 质量指标

- **性能增量**：新技术引入后，原本的计算或交互瓶颈是否得到显著缓解。
- **渐进增强**：在不支持新技术的浏览器环境中，应用是否具备合理的退级保障。
- **语义化程度**：原生组件化后的 DOM 结构是否更清晰、对 SEO 与无障碍更友好。
