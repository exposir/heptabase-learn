<!--
- [INPUT]: Node.js Runtime, HTTP/2, SSR Engines (React/Vue), Hydration Mechanisms
- [OUTPUT]: BFF 层架构设计、同构渲染方案及服务端优化要求
- [POS]: 编程题/ 复杂场景专题，聚焦服务端能力支撑与前端架构纵向延伸
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.9 Node.js / BFF

在"前后端分离"向"全栈交付"进化的过程中，Node.js 承载的 BFF 层已成为提升前端响应灵活性与渲染性能的核心基础设施。

---

### 3.9.1 BFF 层架构设计 ⭐⭐⭐

**要求：** 设计一个支撑高性能业务交付的 BFF 服务框架。

- **职责挑战：**
  - **接口聚合 (Orchestration)**：实现面向前端 UI 的多异构微服务接口聚合，减少首屏请求数。
  - **数据缓存与清洗**：实现服务端级的高速缓存（Redis）与字段格式转换。
  - **错误降级 (Fallback)**：设计当后端核心接口挂掉时的容错处理与兜底方案。
  - **全链路追踪**：在 Node 侧集成 TraceID，打通前后端系统的监控指标。

#### 1. 接口聚合引擎 + 降级策略

```javascript
// ─────────────────────────────────────────────────
//  BFFOrchestrator — 接口聚合与容错引擎
// ─────────────────────────────────────────────────

class BFFOrchestrator {
  constructor(options = {}) {
    this.cache = new Map(); // 内存缓存（生产环境用 Redis）
    this.cacheTTL = options.cacheTTL || 60_000; // 60s
    this.fallbacks = {}; // 降级数据
    this.circuitBreakers = {}; // 熔断器
  }

  // ── 接口聚合：并行请求多个微服务 ──────────────
  async aggregate(tasks) {
    // tasks: [{ key, url, fallback, cacheTTL }]
    const results = {};

    const promises = tasks.map(async (task) => {
      try {
        // 1. 优先读缓存
        const cached = this._getCache(task.key);
        if (cached) {
          results[task.key] = cached;
          return;
        }

        // 2. 熔断检查
        if (this._isCircuitOpen(task.key)) {
          results[task.key] = task.fallback || null;
          return;
        }

        // 3. 发起请求
        const data = await this._fetchWithTimeout(task.url, 3000);
        this._setCache(task.key, data, task.cacheTTL);
        this._resetCircuit(task.key);
        results[task.key] = data;
      } catch (error) {
        // 4. 降级
        this._recordFailure(task.key);
        results[task.key] = task.fallback || { error: error.message };
      }
    });

    await Promise.allSettled(promises);
    return results;
  }

  // ── 简易熔断器 ────────────────────────────────
  _recordFailure(key) {
    if (!this.circuitBreakers[key]) {
      this.circuitBreakers[key] = { failures: 0, openUntil: 0 };
    }
    const breaker = this.circuitBreakers[key];
    breaker.failures++;

    // 连续失败 5 次 → 熔断 30 秒
    if (breaker.failures >= 5) {
      breaker.openUntil = Date.now() + 30_000;
      breaker.failures = 0;
    }
  }

  _isCircuitOpen(key) {
    const breaker = this.circuitBreakers[key];
    return breaker && Date.now() < breaker.openUntil;
  }

  _resetCircuit(key) {
    delete this.circuitBreakers[key];
  }

  // ── 带超时的 Fetch ────────────────────────────
  _fetchWithTimeout(url, timeout) {
    return Promise.race([
      fetch(url).then((r) => r.json()),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error("请求超时")), timeout),
      ),
    ]);
  }

  // ── 缓存管理 ──────────────────────────────────
  _setCache(key, data, ttl) {
    this.cache.set(key, { data, expiry: Date.now() + (ttl || this.cacheTTL) });
  }

  _getCache(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    return item.data;
  }
}

// ── 使用示例 ────────────────────────────────────
const bff = new BFFOrchestrator();

// 首页聚合：同时请求用户、推荐、广告三个微服务
const pageData = await bff.aggregate([
  { key: "user", url: "http://user-svc/api/info", fallback: { name: "游客" } },
  { key: "recommend", url: "http://rec-svc/api/feed", fallback: [] },
  {
    key: "banner",
    url: "http://ad-svc/api/banner",
    fallback: [],
    cacheTTL: 300_000,
  },
]);
```

#### 2. 全链路 TraceID 中间件

```javascript
// ─────────────────────────────────────────────────
//  TraceMiddleware — 全链路追踪中间件
// ─────────────────────────────────────────────────

const crypto = require("crypto");

function traceMiddleware(req, res, next) {
  // 1. 从前端请求头提取，或自动生成
  const traceId = req.headers["x-trace-id"] || crypto.randomUUID();

  // 2. 注入到请求上下文（后续所有下游调用都携带）
  req.traceId = traceId;

  // 3. 写入响应头（前端可以在 DevTools 看到）
  res.setHeader("X-Trace-Id", traceId);

  // 4. 日志关联
  console.log(
    JSON.stringify({
      traceId,
      method: req.method,
      path: req.path,
      timestamp: new Date().toISOString(),
    }),
  );

  next();
}

// 下游请求自动携带 TraceID
async function callDownstream(url, traceId) {
  return fetch(url, {
    headers: { "X-Trace-Id": traceId },
  }).then((r) => r.json());
}
```

> **本质洞察**：BFF 的核心价值是 **「以前端视角重组后端数据」**。后端微服务按领域拆分（用户服务、订单服务），而前端页面需要的是按 **UI 视图** 组合的数据。BFF 就是这个 **"视图层数据编排器"**。它的三大法则：**聚合**（减少前端请求数）、**裁剪**（只返回前端需要的字段）、**容错**（一个服务挂了不影响整个页面）。本质上 BFF 就是 GraphQL 思想的命令式实现。

---

### 3.9.2 SSR 同构渲染方案 ⭐⭐⭐⭐

**要求：** 深入理解 Web 同构渲染的生命周期，并具备处理各种边缘情况的能力。

- **核心流程：**
  - **数据预取 (Data Fetching)**：在服务端精准获取首屏数据，并解决客户端无需二次获取的问题。
  - **Hydration (注水) 算法**：客户端如何正确地为静态 HTML 激活交互逻辑，并处理 DOM 结构不匹配 (Mismatch)。
  - **流式渲染 (Streaming Rendering)**：利用 HTTP 分块传输，极速首屏呈现与后续块动态载入。
  - **性能优化与缓存**：服务端页面片段缓存 (Fragment Cache) 与静态化策略。
  - **降级方案 (CSR Fallback)**：当服务端渲染压力过大或报错时，自动降级为纯客户端渲染的机制。

#### 1. SSR 核心流程（简化版 React SSR）

```javascript
// ─────────────────────────────────────────────────
//  SSR Server — 同构渲染核心流程
// ─────────────────────────────────────────────────

const express = require("express");
const React = require("react");
const { renderToPipeableStream } = require("react-dom/server");

const app = express();

app.get("*", async (req, res) => {
  try {
    // ── Step 1: 数据预取 ────────────────────────
    const initialData = await fetchPageData(req.path);

    // ── Step 2: 服务端渲染（流式） ──────────────
    const App = require("./App").default;
    const { pipe, abort } = renderToPipeableStream(
      <App initialData={initialData} />,
      {
        // Shell 就绪时开始发送
        onShellReady() {
          res.statusCode = 200;
          res.setHeader("Content-Type", "text/html");

          // 流式输出 HTML 头部
          res.write(`<!DOCTYPE html>
            <html>
            <head><title>SSR App</title></head>
            <body><div id="root">`);

          pipe(res); // 流式推送 React 渲染结果
        },

        // 所有 Suspense 边界就绪后
        onAllReady() {
          // 注入客户端 hydration 数据
          res.write(`</div>
            <script>
              window.__INITIAL_DATA__ = ${JSON.stringify(initialData)};
            </script>
            <script src="/client.js"></script>
            </body></html>`);
        },

        onError(error) {
          console.error("SSR Error:", error);
          // 降级为 CSR
          res.statusCode = 200;
          res.end(getCSRFallbackHTML());
        },
      },
    );

    // 超时保护：10 秒后强制中止 SSR
    setTimeout(() => abort(), 10_000);
  } catch (e) {
    // ── Step 3: 全局降级 → CSR ──────────────────
    res.status(200).send(getCSRFallbackHTML());
  }
});

// ── CSR 降级页面 ────────────────────────────────
function getCSRFallbackHTML() {
  return `<!DOCTYPE html>
    <html>
    <head><title>App</title></head>
    <body>
      <div id="root"></div>
      <script src="/client.js"></script>
    </body>
    </html>`;
}
```

#### 2. Hydration 与状态同步

```javascript
// ─────────────────────────────────────────────────
//  Client Hydration — 客户端注水逻辑
// ─────────────────────────────────────────────────

import { hydrateRoot } from "react-dom/client";
import App from "./App";

// 从服务端注入的全局变量读取初始数据
const initialData = window.__INITIAL_DATA__;

// hydrateRoot 不会重新创建 DOM，而是"激活"已有 DOM
hydrateRoot(document.getElementById("root"), <App initialData={initialData} />);

// ── Hydration Mismatch 处理策略 ─────────────────
// 1. suppressHydrationWarning：对于时间戳、随机数等必然不一致的内容
// 2. useEffect 延迟渲染：将客户端特有内容移到 useEffect
// 3. 客户端检测 Hook:
function useIsClient() {
  const [isClient, setIsClient] = React.useState(false);
  React.useEffect(() => setIsClient(true), []);
  return isClient;
}
```

#### 3. 页面级缓存策略

```javascript
// ─────────────────────────────────────────────────
//  FragmentCache — 页面片段级缓存
// ─────────────────────────────────────────────────

class SSRCache {
  constructor() {
    this.store = new Map();
  }

  // 页面级缓存
  getPage(url) {
    const cached = this.store.get(`page:${url}`);
    if (cached && Date.now() < cached.expiry) {
      return cached.html;
    }
    return null;
  }

  setPage(url, html, ttl = 60_000) {
    this.store.set(`page:${url}`, {
      html,
      expiry: Date.now() + ttl,
    });
  }

  // 组件片段级缓存（更精细的粒度）
  getFragment(componentId, props) {
    const key = `frag:${componentId}:${JSON.stringify(props)}`;
    const cached = this.store.get(key);
    if (cached && Date.now() < cached.expiry) return cached.html;
    return null;
  }

  setFragment(componentId, props, html, ttl = 300_000) {
    const key = `frag:${componentId}:${JSON.stringify(props)}`;
    this.store.set(key, { html, expiry: Date.now() + ttl });
  }

  // 缓存失效策略
  invalidate(pattern) {
    for (const key of this.store.keys()) {
      if (key.includes(pattern)) this.store.delete(key);
    }
  }
}
```

> **本质洞察**：SSR 的哲学困境是 **「一份代码的两次生命」**。同一段 React 代码在服务端是 **字符串拼接器**（生成 HTML），在客户端是 **事件绑定器**（激活交互）。Hydration 就是让"死的 HTML"复活的过程。流式渲染 (`renderToPipeableStream`) 解决的是首字节时间问题 —— 不等所有数据就绪就开始发送 HTML 外壳，本质是 HTTP 分块传输（chunked transfer）的巧妙利用。**降级方案是 SSR 的生命线** —— 宁可让用户看到纯 CSR 页面，也不能让他看到白屏。

---

### 3.9.3 Serverless 应用与优化 ⭐⭐⭐

**要求：** 基于 FaaS 模式部署逻辑，关注运维成本与启动性能。

- **优化重点：**
  - **冷启动 (Cold Start)**：优化包体积、Tree-shaking 及并发调用策略。
  - **函数拆分颗粒度**：单一职责函数的设计与协作模式。
  - **无状态设计 (Stateless)**：如何在计算层与持久层（数据库/缓存）间建立稳定的状态映射。

#### 1. Serverless 函数设计与冷启动优化

```javascript
// ─────────────────────────────────────────────────
//  Serverless Function — 冷启动优化实践
// ─────────────────────────────────────────────────

// ── 核心原则：模块级初始化只在冷启动时执行一次 ───
//    后续的"热启动"复用在同一容器实例

// 1. 延迟初始化（Lazy Init）：数据库连接放在模块作用域
let dbConnection = null;

async function getDB() {
  if (!dbConnection) {
    // 冷启动时才创建连接（约 200-500ms）
    dbConnection = await createDatabaseConnection({
      host: process.env.DB_HOST,
      pool: { min: 1, max: 5 }, // Serverless 用小连接池
    });
  }
  return dbConnection;
}

// 2. 函数入口：保持精简
exports.handler = async (event, context) => {
  // 关闭"等待事件循环清空"，避免连接池阻止容器回收
  context.callbackWaitsForEmptyEventLoop = false;

  const { path, method, body } = parseEvent(event);

  try {
    const db = await getDB();
    const result = await routeHandler(path, method, body, db);

    return {
      statusCode: 200,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(result),
    };
  } catch (error) {
    return {
      statusCode: error.statusCode || 500,
      body: JSON.stringify({ error: error.message }),
    };
  }
};

// ── 冷启动优化清单 ──────────────────────────────
// 1. 包体积：用 esbuild 打包，Tree-shake 移除未使用代码
// 2. 依赖精简：用 @aws-sdk/client-s3 替代整个 aws-sdk
// 3. 预热策略：定时触发（每 5 分钟 ping 一次保持容器活跃）
// 4. 并发预留：Provisioned Concurrency 预留实例
```

#### 2. 函数拆分与编排

```javascript
// ─────────────────────────────────────────────────
//  FunctionOrchestrator — 函数拆分与编排
// ─────────────────────────────────────────────────

// 单一职责函数设计（每个函数只做一件事）

// 函数 A：用户鉴权
exports.authHandler = async (event) => {
  const token = event.headers.authorization;
  const user = await verifyJWT(token);
  return { userId: user.id, role: user.role };
};

// 函数 B：数据查询
exports.queryHandler = async (event) => {
  const { userId } = event;
  const db = await getDB();
  return db.query("SELECT * FROM orders WHERE user_id = ?", [userId]);
};

// 函数 C：编排层（组合 A + B）
exports.pageHandler = async (event) => {
  // Step Functions / 编排器调用
  const auth = await invokeLambda("authHandler", event);

  if (!auth.userId) {
    return { statusCode: 401, body: "Unauthorized" };
  }

  const orders = await invokeLambda("queryHandler", {
    userId: auth.userId,
  });

  return {
    statusCode: 200,
    body: JSON.stringify({ user: auth, orders }),
  };
};

// ── 无状态设计的状态管理 ────────────────────────
// Serverless 函数本身无状态，状态存储在外部：
// - 会话状态 → Redis / DynamoDB
// - 文件状态 → S3 / OSS
// - 任务状态 → SQS / 消息队列
// 函数只做计算，数据在外部服务中流转
```

> **本质洞察**：Serverless 的哲学是 **「计算是瞬态的，数据是永恒的」**。函数像闪电一样闪现又消失，状态必须全部外化。冷启动是 Serverless 的"原罪" —— 每次从零构建运行环境的代价。优化冷启动的本质是 **减少"从零到可执行"的距离**：更小的包、更少的依赖、更懒的初始化。这与操作系统的进程启动优化思路一致 —— 一切昂贵的初始化都应该被延迟到真正需要的那一刻。

---

## 质量指标

- **稳定性 (QPS)**：Node 服务在高并发请求下的负载波动。
- **TTFB (Time To First Byte)**：SSR 模式下服务端响应的首字节时长。
- **可维护性**：同构代码在 Node 端与浏览器端的共享程度与测试覆盖率。
