<!--
- [INPUT]: 递归算法、Map/HashMap 映射、正则解析、字符串大数运算
- [OUTPUT]: 高效的数据转换工具类与业务逻辑常用函数
- [POS]: 编程题/ 模块的数据加工中心，提供工业级的业务逻辑处理能力
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.3 数据处理与工具函数

数据处理是前端业务逻辑的压舱石。从原始的 JSON 响应到 UI 能够消费的结构（如 Tree 或 Flatten List），**转换的效率与健壮性决定了应用的响应质量**。

---

### 1.3.1 数组与树形转换 (Array & Tree)

**现象**：后端返回的扁平 List 需要在前端渲染成文件夹树、组织架构图。
**本质**：利用 `id/pid` 的引用关联，通过递归或 `Map` 映射（空间换时间）重建层级关系。

| 题目                       | 难度   | 优先级 | 考察点                             |
| :------------------------- | :----- | :----- | :--------------------------------- |
| **数组转树 (arrayToTree)** | ⭐⭐⭐ | 必会   | Map 映射加速、引用传递、根节点识别 |
| **树转数组 (treeToArray)** | ⭐⭐⭐ | 必会   | 递归 BFS/DFS、层级属性平铺         |
| **数组扁平化 (flat)**      | ⭐⭐   | 必会   | 递归深度控制、reduce/stack 实现    |
| **数组乱序 (Shuffle)**     | ⭐⭐   | 掌握   | Fisher-Yates 洗牌算法              |

#### 1. 数组转树 (空间换时间版)

```javascript
// ─────────────────────────────────────────────────
//  arrayToTree — 高效的数组转树形结构
// ─────────────────────────────────────────────────

function arrayToTree(items) {
  const result = []; // 存放根节点
  const itemMap = {}; // 快速索引表

  // 1. 初始化 Map，使所有节点可通过 id 瞬间获取
  for (const item of items) {
    itemMap[item.id] = { ...item, children: [] };
  }

  // 2. 只有一次遍历，通过 Map 建立父子引用
  for (const item of items) {
    const id = item.id;
    const pid = item.pid;
    const treeItem = itemMap[id];

    if (pid === 0 || pid === null || !itemMap[pid]) {
      // 根节点
      result.push(treeItem);
    } else {
      // 子节点：直接挂载到父节点的 children 下
      itemMap[pid].children.push(treeItem);
    }
  }

  return result;
}

// ── 验证 ──
const list = [
  { id: 1, pid: 0, name: "Root" },
  { id: 2, pid: 1, name: "Child 1" },
  { id: 3, pid: 1, name: "Child 2" },
  { id: 4, pid: 2, name: "Grandchild" },
];
console.log(JSON.stringify(arrayToTree(list), null, 2));
```

> **本质洞察**：数组转树的单次遍历写法利用了 **JavaScript 对象的引用特性**。即使父节点还没被处理到其 children 数组，子节点被 push 进去的操作也是在同一个引用地址上进行的。

---

### 1.3.2 深度路径处理 (Deep Path)

**现象**：访问 `user.profile.settings.theme` 时，中间任何一级缺失都会导致崩溃。
**本质**：字符串路径解析（Split/Regex）与指针移动。

#### 对象路径取值 (get)

```javascript
// ─────────────────────────────────────────────────
//  get — 实现 lodash.get
// ─────────────────────────────────────────────────

function get(object, path, defaultValue) {
  // 处理路径：'a[0].b.c' -> ['a', '0', 'b', 'c']
  const keys = path.replace(/\[(\d+)\]/g, ".$1").split(".");

  let result = object;
  for (const key of keys) {
    result = Object(result)[key];
    if (result === undefined) return defaultValue;
  }

  return result;
}

// ── 验证 ──
const data = { a: [{ b: { c: 3 } }] };
console.log(get(data, "a[0].b.c")); // 3
console.log(get(data, "a.b.c", "N/A")); // "N/A"
```

---

### 1.3.3 大数运算 (Big Number)

**现象**：JS 数值超过 $2^{53}-1$ 精度会丢失（0.1 + 0.2 != 0.3）。
**本质**：用**字符串或数组**模拟人工竖式计算逻辑。

#### 大数相加

```javascript
// ─────────────────────────────────────────────────
//  add — 字符串大数相加
// ─────────────────────────────────────────────────

function bigIntAdd(a, b) {
  let res = "";
  let carry = 0; // 进位

  a = a.split("");
  b = b.split("");

  while (a.length || b.length || carry) {
    // 每次弹出最末位，补 0
    carry += ~~a.pop() + ~~b.pop();
    res = (carry % 10) + res;
    carry = Math.floor(carry / 10);
  }

  return res;
}

// ── 验证 ──
console.log(bigIntAdd("9007199254740991", "1")); // "9007199254740992"
```

---

## 质量指标

- **异常鲁棒性**：大数相加必须兼容空字符串或非数值输入。
- **引用隔离**：`arrayToTree` 建议返回新节点副本，避免修改原始数组项。
- **边界覆盖**：`get` 函数需处理数组索引（如 `[0]`）的语法。
