<!--
- [INPUT]: 递归算法、Map/HashMap 映射、正则解析、字符串大数运算
- [OUTPUT]: 高效的数据转换工具与工业级业务逻辑函数
- [POS]: 编程题/ 模块的数据加工中心，处理从扁平到树形、从原始到结构化的一切数据变换
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.3 数据处理与工具函数

数据处理是前端业务逻辑的压舱石。从后端返回的原始 JSON 到 UI 能消费的规范结构，**转换的效率与健壮性决定了应用的响应质量**。这一章的每一个函数都是工程中会反复使用的基础设施。

---

### 1.3.1 数组操作 (Array Operations)

**现象**：嵌套的数组需要展平、重复元素需要去除、扁平的 List 需要渲染成 Tree。
**本质**：递归（或栈模拟）处理未知层级深度，利用 `Set`/`Map` 做 O(1) 查找加速。

| 题目                        | 难度   | 优先级 | 考察点                     |
| :-------------------------- | :----- | :----- | :------------------------- |
| **数组扁平化 flat**         | ⭐⭐   | 必会   | 递归深度控制、reduce/stack |
| **数组去重（多种方式）**    | ⭐⭐   | 必会   | Set、filter、reduce        |
| **数组分组 groupBy**        | ⭐⭐   | 掌握   | reduce                     |
| **数组转树形结构**          | ⭐⭐⭐ | 必会   | Map 映射加速、引用传递     |
| **树形结构转扁平数组**      | ⭐⭐⭐ | 必会   | BFS/DFS 递归遍历           |
| **数组乱序 (Fisher-Yates)** | ⭐⭐   | 掌握   | 等概率洗牌算法             |
| **数组交集/并集/差集**      | ⭐⭐   | 掌握   | Set 运算                   |

#### 1. 数组扁平化 flat

```javascript
// ─────────────────────────────────────────────────
//  flatten — 多种实现方式
// ─────────────────────────────────────────────────

// 方式一：递归 + reduce（支持深度控制）
function flatten(arr, depth = Infinity) {
  return arr.reduce((acc, cur) => {
    if (Array.isArray(cur) && depth > 0) {
      return acc.concat(flatten(cur, depth - 1));
    }
    return acc.concat(cur);
  }, []);
}

// 方式二：栈迭代（避免递归爆栈）
function flattenIterative(arr) {
  const stack = [...arr];
  const result = [];
  while (stack.length) {
    const item = stack.pop();
    if (Array.isArray(item)) {
      stack.push(...item); // 展开后重新入栈
    } else {
      result.unshift(item); // 头部插入，保持顺序
    }
  }
  return result;
}

// 方式三：toString hack（仅限数值数组）
function flattenHack(arr) {
  return arr
    .toString()
    .split(",")
    .map((v) => +v);
}

// ── 验证 ──
const nested = [1, [2, [3, [4]], 5]];
console.log(flatten(nested)); // [1, 2, 3, 4, 5]
console.log(flatten(nested, 1)); // [1, 2, [3, [4]], 5]
console.log(flattenIterative(nested)); // [1, 2, 3, 4, 5]
```

> **本质洞察**：`flat` 的 `depth` 参数背后是一个哲学问题——你要"展平到什么程度"？`Infinity` 意味着消除所有嵌套，而有限的 depth 则是在说"保留一定的结构是有意义的"。这与 CSS `z-index` 的层叠上下文异曲同工。

#### 2. 数组去重（多种方式）

```javascript
// ─────────────────────────────────────────────────
//  unique — 多种去重策略
// ─────────────────────────────────────────────────

// 方式一：Set（最优，O(n)）
const unique1 = (arr) => [...new Set(arr)];

// 方式二：filter + indexOf
const unique2 = (arr) => arr.filter((v, i) => arr.indexOf(v) === i);

// 方式三：reduce + includes
const unique3 = (arr) =>
  arr.reduce((acc, cur) => (acc.includes(cur) ? acc : [...acc, cur]), []);

// 方式四：对象引用去重（适用于数组中的对象）
function uniqueBy(arr, key) {
  const seen = new Map();
  return arr.filter((item) => {
    const k = typeof key === "function" ? key(item) : item[key];
    if (seen.has(k)) return false;
    seen.set(k, true);
    return true;
  });
}

// ── 验证 ──
console.log(unique1([1, 2, 2, 3, 3, 3])); // [1, 2, 3]
console.log(unique2([1, 2, 2, 3])); // [1, 2, 3]

const users = [
  { id: 1, name: "A" },
  { id: 2, name: "B" },
  { id: 1, name: "C" },
];
console.log(uniqueBy(users, "id")); // [{ id: 1, name: 'A' }, { id: 2, name: 'B' }]
```

> **本质洞察**：`Set` 的去重为什么是 O(n)？因为 Set 内部用的是 Hash Table，每次 `has` 和 `add` 都是 O(1)。而 `indexOf` 去重是 O(n²)——每次 indexOf 都要从头扫描。选择数据结构就是选择时间复杂度。

#### 3. 数组分组 groupBy

```javascript
// ─────────────────────────────────────────────────
//  groupBy — 按指定规则对数组分组
// ─────────────────────────────────────────────────

function groupBy(arr, keyOrFn) {
  return arr.reduce((groups, item) => {
    const key = typeof keyOrFn === "function" ? keyOrFn(item) : item[keyOrFn];
    (groups[key] = groups[key] || []).push(item);
    return groups;
  }, {});
}

// ── 验证 ──
const people = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 25 },
];
console.log(groupBy(people, "age"));
// { 25: [{ name: 'Alice'... }, { name: 'Charlie'... }], 30: [{ name: 'Bob'... }] }

console.log(groupBy([1, 2, 3, 4, 5], (n) => (n % 2 === 0 ? "even" : "odd")));
// { odd: [1, 3, 5], even: [2, 4] }
```

> **本质洞察**：`groupBy` 是 `reduce` 最经典的应用场景——将一维数组按某个维度"折叠"成多维对象。SQL 的 `GROUP BY` 做的是同一件事，只是表达语法不同。

#### 4. 数组转树形结构

```javascript
// ─────────────────────────────────────────────────
//  arrayToTree — O(n) 复杂度的数组转树
// ─────────────────────────────────────────────────

function arrayToTree(
  items,
  { idKey = "id", pidKey = "pid", childrenKey = "children" } = {},
) {
  const result = [];
  const itemMap = {};

  // 第一遍：建立 id → 节点的映射
  for (const item of items) {
    itemMap[item[idKey]] = { ...item, [childrenKey]: [] };
  }

  // 第二遍：通过映射建立父子关系（引用传递）
  for (const item of items) {
    const treeItem = itemMap[item[idKey]];
    const parentId = item[pidKey];

    if (
      parentId === 0 ||
      parentId === null ||
      parentId === undefined ||
      !itemMap[parentId]
    ) {
      result.push(treeItem); // 根节点
    } else {
      itemMap[parentId][childrenKey].push(treeItem); // 挂载到父节点
    }
  }

  return result;
}

// ── 验证 ──
const list = [
  { id: 1, pid: 0, name: "技术部" },
  { id: 2, pid: 1, name: "前端组" },
  { id: 3, pid: 1, name: "后端组" },
  { id: 4, pid: 2, name: "React 小队" },
  { id: 5, pid: 2, name: "Vue 小队" },
  { id: 6, pid: 3, name: "Java 小队" },
];
console.log(JSON.stringify(arrayToTree(list), null, 2));
// 技术部 → [前端组 → [React 小队, Vue 小队], 后端组 → [Java 小队]]
```

> **本质洞察**：单次遍历版的秘密在于 **JavaScript 对象的引用特性**。当你把 `itemMap[2]` push 到 `itemMap[1].children` 里时，两个地方持有的是**同一个对象引用**。后续对 `itemMap[2]` 的任何修改（如往它的 children 里 push 子节点）都会自动反映在父节点的 children 列表中。

#### 5. 树形结构转扁平数组

```javascript
// ─────────────────────────────────────────────────
//  treeToArray — DFS/BFS 树转扁平
// ─────────────────────────────────────────────────

// DFS 深度优先（递归）
function treeToArrayDFS(tree, childrenKey = "children") {
  const result = [];
  function traverse(nodes) {
    for (const node of nodes) {
      const { [childrenKey]: children, ...rest } = node;
      result.push(rest);
      if (children && children.length) traverse(children);
    }
  }
  traverse(tree);
  return result;
}

// BFS 广度优先（队列）
function treeToArrayBFS(tree, childrenKey = "children") {
  const result = [];
  const queue = [...tree];
  while (queue.length) {
    const node = queue.shift();
    const { [childrenKey]: children, ...rest } = node;
    result.push(rest);
    if (children && children.length) queue.push(...children);
  }
  return result;
}

// ── 验证 ──
const tree = [
  {
    id: 1,
    name: "A",
    children: [
      { id: 2, name: "B", children: [] },
      { id: 3, name: "C", children: [{ id: 4, name: "D", children: [] }] },
    ],
  },
];
console.log(treeToArrayDFS(tree));
// [{ id: 1, name: 'A' }, { id: 2, name: 'B' }, { id: 3, name: 'C' }, { id: 4, name: 'D' }]
```

> **本质洞察**：DFS 和 BFS 的区别不是"谁更好"，而是**输出顺序不同**。DFS 会先深入到叶子节点再回溯（适合文件系统遍历），BFS 则逐层输出（适合层级展示）。选择遍历策略就是选择「你要按什么顺序看这棵树」。

#### 6. 数组乱序（Fisher-Yates 洗牌算法）

```javascript
// ─────────────────────────────────────────────────
//  shuffle — Fisher-Yates 等概率洗牌
// ─────────────────────────────────────────────────

function shuffle(arr) {
  const result = [...arr]; // 不修改原数组
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]]; // 解构交换
  }
  return result;
}

// ── 验证 ──
console.log(shuffle([1, 2, 3, 4, 5])); // 每次不同，如 [3, 1, 5, 4, 2]

// 验证等概率性：运行 100000 次，统计每个位置出现 1 的次数
const stats = Array(5).fill(0);
for (let i = 0; i < 100000; i++) {
  const s = shuffle([1, 2, 3, 4, 5]);
  stats[s.indexOf(1)]++;
}
console.log(stats); // 约 [20000, 20000, 20000, 20000, 20000]（均匀分布）
```

> **本质洞察**：`sort(() => Math.random() - 0.5)` 不是真正的洗牌——它的概率分布不均匀，与排序算法的实现强耦合。Fisher-Yates 通过「从后向前，每次与随机位置交换」，数学上证明了等概率性。

#### 7. 数组交集 / 并集 / 差集

```javascript
// ─────────────────────────────────────────────────
//  集合运算 — 交集 / 并集 / 差集
// ─────────────────────────────────────────────────

const intersection = (a, b) => {
  const setB = new Set(b);
  return [...new Set(a)].filter((x) => setB.has(x));
};

const union = (a, b) => [...new Set([...a, ...b])];

const difference = (a, b) => {
  const setB = new Set(b);
  return a.filter((x) => !setB.has(x));
};

// ── 验证 ──
console.log(intersection([1, 2, 3], [2, 3, 4])); // [2, 3]
console.log(union([1, 2, 3], [2, 3, 4])); // [1, 2, 3, 4]
console.log(difference([1, 2, 3], [2, 3, 4])); // [1]
```

> **本质洞察**：所有集合运算的核心都是 `Set.has()`——O(1) 的查找。不用 Set 的话，交集就变成 O(n×m) 的暴力搜索。**数据结构的选择，直接决定了算法的时间复杂度上限。**

---

### 1.3.2 对象操作 (Object Operations)

**现象**：深层嵌套的对象需要安全访问、序列化、比较差异。
**本质**：递归遍历 + 路径解析是处理任意深度对象的通用范式。

| 题目             | 难度   | 优先级 | 考察点                   |
| :--------------- | :----- | :----- | :----------------------- |
| **对象扁平化**   | ⭐⭐⭐ | 必会   | 递归、路径拼接           |
| **对象反扁平化** | ⭐⭐⭐ | 掌握   | 路径分割、逐层构建       |
| **路径取值 get** | ⭐⭐⭐ | 必会   | lodash.get、正则路径解析 |
| **路径设置 set** | ⭐⭐⭐ | 必会   | lodash.set、自动创建层级 |
| **对象深度冻结** | ⭐⭐   | 了解   | Object.freeze 递归       |
| **对象 diff**    | ⭐⭐⭐ | 掌握   | 递归比较、变更类型识别   |

#### 1. 对象扁平化

```javascript
// ─────────────────────────────────────────────────
//  flattenObject — 嵌套对象转扁平键值对
// ─────────────────────────────────────────────────

function flattenObject(obj, prefix = "", result = {}) {
  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}.${key}` : key;
    if (value && typeof value === "object" && !Array.isArray(value)) {
      flattenObject(value, newKey, result);
    } else {
      result[newKey] = value;
    }
  }
  return result;
}

// ── 验证 ──
const nested = { a: { b: { c: 1 } }, d: 2, e: { f: { g: 3 } } };
console.log(flattenObject(nested));
// { 'a.b.c': 1, d: 2, 'e.f.g': 3 }
```

> **本质洞察**：扁平化的本质是**树的先序遍历**——到达叶子节点时记录完整路径。这和文件系统的绝对路径概念完全一致。

#### 2. 对象反扁平化

```javascript
// ─────────────────────────────────────────────────
//  unflattenObject — 扁平键值对还原为嵌套对象
// ─────────────────────────────────────────────────

function unflattenObject(obj) {
  const result = {};

  for (const [flatKey, value] of Object.entries(obj)) {
    const keys = flatKey.split(".");
    let current = result;

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (i === keys.length - 1) {
        current[key] = value; // 最后一段：赋值
      } else {
        current[key] = current[key] || {}; // 中间段：自动创建空对象
        current = current[key];
      }
    }
  }

  return result;
}

// ── 验证 ──
console.log(unflattenObject({ "a.b.c": 1, d: 2, "e.f.g": 3 }));
// { a: { b: { c: 1 } }, d: 2, e: { f: { g: 3 } } }
```

> **本质洞察**：反扁平化是**逐步构建路径**的过程。每一段路径要么指向已有的对象，要么创建新对象。这和 `mkdir -p` 的行为完全一致——没有中间目录就自动创建。

#### 3. 路径取值 get（lodash.get）

```javascript
// ─────────────────────────────────────────────────
//  get — 安全的深层路径取值
// ─────────────────────────────────────────────────

function get(object, path, defaultValue) {
  // 'a[0].b.c' → ['a', '0', 'b', 'c']
  const keys =
    typeof path === "string"
      ? path.replace(/\[(\d+)\]/g, ".$1").split(".")
      : path;

  let result = object;
  for (const key of keys) {
    result = Object(result)[key]; // Object() 包装防止 null/undefined 报错
    if (result === undefined) return defaultValue;
  }
  return result;
}

// ── 验证 ──
const data = { a: [{ b: { c: 3 } }], x: null };
console.log(get(data, "a[0].b.c")); // 3
console.log(get(data, "a[0].b.d", "N/A")); // "N/A"
console.log(get(data, "x.y.z", "safe")); // "safe"（x 是 null，不会报错）
console.log(get(data, ["a", "0", "b", "c"])); // 3（也支持数组路径）
```

> **本质洞察**：`Object(result)[key]` 是整个实现中最精妙的一行。`Object(null)` 和 `Object(undefined)` 会返回空对象 `{}`，在它上面取任何属性都只是 `undefined` 而不会 `throw`。这一行消除了所有中间节点为 `null` 的特殊分支。

#### 4. 路径设置 set（lodash.set）

```javascript
// ─────────────────────────────────────────────────
//  set — 安全的深层路径设置（自动创建中间层级）
// ─────────────────────────────────────────────────

function set(object, path, value) {
  const keys =
    typeof path === "string"
      ? path.replace(/\[(\d+)\]/g, ".$1").split(".")
      : path;

  let current = object;
  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    const nextKey = keys[i + 1];
    // 下一个 key 是数字则创建数组，否则创建对象
    if (current[key] === undefined || current[key] === null) {
      current[key] = /^\d+$/.test(nextKey) ? [] : {};
    }
    current = current[key];
  }
  current[keys[keys.length - 1]] = value;
  return object;
}

// ── 验证 ──
const obj = {};
set(obj, "a.b.c", 42);
console.log(obj); // { a: { b: { c: 42 } } }

set(obj, "a.d[0]", "hello");
console.log(obj); // { a: { b: { c: 42 }, d: ['hello'] } }
```

> **本质洞察**：`set` 比 `get` 多了一个决策——当中间层级缺失时，创建对象还是数组？答案藏在**下一个 key 是否是纯数字**里。这是 lodash 的经典做法，用最少的信息做最合理的推断。

#### 5. 对象深度冻结

```javascript
// ─────────────────────────────────────────────────
//  deepFreeze — 递归冻结对象
// ─────────────────────────────────────────────────

function deepFreeze(obj) {
  Object.freeze(obj);
  Object.getOwnPropertyNames(obj).forEach((key) => {
    const value = obj[key];
    if (value && typeof value === "object" && !Object.isFrozen(value)) {
      deepFreeze(value);
    }
  });
  return obj;
}

// ── 验证 ──
const config = deepFreeze({ api: { host: "example.com", port: 443 } });
config.api.host = "hacked.com"; // 静默失败（严格模式下 TypeError）
console.log(config.api.host); // "example.com"（未被修改）
```

> **本质洞察**：`Object.freeze` 是浅冻结——只冻结一层。深度冻结需要递归。但在生产环境建议用 Immer 而非 deepFreeze，因为冻结会丧失所有修改能力，Immer 的结构共享方案在保持不可变性的同时还能高效创建新副本。

#### 6. 对象 diff

```javascript
// ─────────────────────────────────────────────────
//  diff — 深度比较两个对象的差异
// ─────────────────────────────────────────────────

function diff(obj1, obj2) {
  const result = {};

  const allKeys = new Set([
    ...Object.keys(obj1 || {}),
    ...Object.keys(obj2 || {}),
  ]);

  for (const key of allKeys) {
    const val1 = obj1?.[key];
    const val2 = obj2?.[key];

    if (val1 === val2) continue;

    if (
      val1 &&
      val2 &&
      typeof val1 === "object" &&
      typeof val2 === "object" &&
      !Array.isArray(val1) &&
      !Array.isArray(val2)
    ) {
      const nested = diff(val1, val2);
      if (Object.keys(nested).length > 0) {
        result[key] = nested;
      }
    } else {
      result[key] = { from: val1, to: val2 };
    }
  }

  return result;
}

// ── 验证 ──
const before = { name: "Alice", age: 25, meta: { role: "dev", level: 3 } };
const after = {
  name: "Alice",
  age: 26,
  meta: { role: "dev", level: 4 },
  active: true,
};
console.log(diff(before, after));
// { age: { from: 25, to: 26 }, meta: { level: { from: 3, to: 4 } }, active: { from: undefined, to: true } }
```

> **本质洞察**：`diff` 是 Virtual DOM diff 的朴素版本——React 的 `reconciliation` 做的本质上就是这件事，只不过对象换成了 DOM 节点树，`from/to` 换成了 `insert/update/delete` 操作。

---

### 1.3.3 常用工具函数 (Utility Functions)

| 题目                    | 难度     | 优先级 | 考察点                 |
| :---------------------- | :------- | :----- | :--------------------- |
| **模板字符串解析**      | ⭐⭐⭐   | 掌握   | 正则、replace          |
| **大数相加**            | ⭐⭐⭐   | 掌握   | 字符串逐位运算         |
| **大数相乘**            | ⭐⭐⭐⭐ | 了解   | 竖式乘法模拟           |
| **千分位格式化**        | ⭐⭐     | 必会   | 正则、toLocaleString   |
| **版本号比较**          | ⭐⭐     | 必会   | 字符串分割逐段比较     |
| **驼峰转换**            | ⭐⭐     | 掌握   | 正则                   |
| **URL 参数解析**        | ⭐⭐     | 必会   | URLSearchParams        |
| **实现 JSON.stringify** | ⭐⭐⭐⭐ | 了解   | 类型递归处理、循环引用 |
| **实现 JSON.parse**     | ⭐⭐⭐⭐ | 了解   | eval / 状态机          |

#### 1. 模板字符串解析

```javascript
// ─────────────────────────────────────────────────
//  render — 模板字符串解析（类 Mustache）
// ─────────────────────────────────────────────────

function render(template, data) {
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    return data[key] !== undefined ? data[key] : match;
  });
}

// ── 验证 ──
console.log(
  render("Hello, {{name}}! You are {{age}} years old.", {
    name: "Linus",
    age: 55,
  }),
);
// "Hello, Linus! You are 55 years old."
console.log(render("{{greeting}}, {{missing}}!", { greeting: "Hi" }));
// "Hi, {{missing}}!"（未匹配到的保持原样）
```

> **本质洞察**：模板引擎的核心是 `replace` + 正则的 capture group。`(\w+)` 捕获的变量名就是 `data` 对象的 key。从 Mustache 到 Vue 模板，底层机制相同。

#### 2. 大数相加

```javascript
// ─────────────────────────────────────────────────
//  bigAdd — 字符串大数加法（模拟竖式）
// ─────────────────────────────────────────────────

function bigAdd(a, b) {
  let result = "";
  let carry = 0;
  const arrA = a.split("");
  const arrB = b.split("");

  while (arrA.length || arrB.length || carry) {
    carry += ~~arrA.pop() + ~~arrB.pop(); // ~~ 将 undefined 转为 0
    result = (carry % 10) + result;
    carry = Math.floor(carry / 10);
  }

  return result;
}

// ── 验证 ──
console.log(bigAdd("9007199254740991", "1234567890123456789"));
// "1243575089378197780"
console.log(bigAdd("999", "1")); // "1000"
```

> **本质洞察**：`~~undefined === 0` 是 JS 中最骚的类型转换之一——双取反可以把任何值转为整数。利用它免去了对两个数长度不一致的 padding 处理。

#### 3. 大数相乘

```javascript
// ─────────────────────────────────────────────────
//  bigMultiply — 竖式乘法模拟
// ─────────────────────────────────────────────────

function bigMultiply(a, b) {
  const result = new Array(a.length + b.length).fill(0);

  for (let i = a.length - 1; i >= 0; i--) {
    for (let j = b.length - 1; j >= 0; j--) {
      const mul = (a[i] - "0") * (b[j] - "0");
      const p1 = i + j;
      const p2 = i + j + 1;
      const sum = mul + result[p2];

      result[p2] = sum % 10;
      result[p1] += Math.floor(sum / 10);
    }
  }

  return result.join("").replace(/^0+/, "") || "0";
}

// ── 验证 ──
console.log(bigMultiply("123", "456")); // "56088"
console.log(bigMultiply("999", "999")); // "998001"
console.log(bigMultiply("0", "12345")); // "0"
```

> **本质洞察**：竖式乘法中 `i * j` 的结果影响的位置是 `[i+j]` 和 `[i+j+1]`——这就是小学竖式乘法的数学本质。用数组模拟进位比字符串拼接干净得多。

#### 4. 千分位格式化

```javascript
// ─────────────────────────────────────────────────
//  formatNumber — 千分位格式化
// ─────────────────────────────────────────────────

// 方式一：正则（面试推荐）
function formatNumber(num) {
  const [integer, decimal] = String(num).split(".");
  const formatted = integer.replace(/\B(?=(\d{3})+$)/g, ",");
  return decimal !== undefined ? `${formatted}.${decimal}` : formatted;
}

// 方式二：toLocaleString（生产推荐）
const formatNumberNative = (num) => num.toLocaleString("en-US");

// ── 验证 ──
console.log(formatNumber(1234567.89)); // "1,234,567.89"
console.log(formatNumber(1000)); // "1,000"
console.log(formatNumberNative(1234567.89)); // "1,234,567.89"
```

> **本质洞察**：`/\B(?=(\d{3})+$)/g` 是正则中**零宽断言**的经典应用。`\B` 表示非单词边界（防止在开头插入逗号），`(?=(\d{3})+$)` 表示"后面跟着 3 的倍数个数字直到末尾"。

#### 5. 版本号比较

```javascript
// ─────────────────────────────────────────────────
//  compareVersion — 语义化版本比较
// ─────────────────────────────────────────────────

function compareVersion(v1, v2) {
  const a = v1.split(".");
  const b = v2.split(".");
  const len = Math.max(a.length, b.length);

  for (let i = 0; i < len; i++) {
    const n1 = parseInt(a[i] || "0", 10);
    const n2 = parseInt(b[i] || "0", 10);
    if (n1 > n2) return 1;
    if (n1 < n2) return -1;
  }
  return 0;
}

// ── 验证 ──
console.log(compareVersion("1.0.1", "1.0.0")); // 1
console.log(compareVersion("1.0", "1.0.0")); // 0
console.log(compareVersion("0.9.9", "1.0.0")); // -1
console.log(compareVersion("1.10.0", "1.9.0")); // 1（注意不是字符串比较）
```

> **本质洞察**：版本号比较的陷阱在于——`"10" < "9"` 在字符串比较中是 `true`。必须**转为数字后逐段比较**。`|| "0"` 处理版本号长度不一致的情况。

#### 6. 驼峰转换

```javascript
// ─────────────────────────────────────────────────
//  camelCase / kebabCase — 命名风格互转
// ─────────────────────────────────────────────────

// kebab-case → camelCase
function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
}

// camelCase → kebab-case
function toKebabCase(str) {
  return str.replace(/[A-Z]/g, (char) => `-${char.toLowerCase()}`);
}

// ── 验证 ──
console.log(toCamelCase("get-user-info")); // "getUserInfo"
console.log(toKebabCase("getUserInfo")); // "get-user-info"
```

#### 7. URL 参数解析

```javascript
// ─────────────────────────────────────────────────
//  parseQuery — URL 查询字符串解析
// ─────────────────────────────────────────────────

function parseQuery(url) {
  const queryString = url.split("?")[1];
  if (!queryString) return {};

  return queryString.split("&").reduce((params, pair) => {
    const [key, value = ""] = pair.split("=").map(decodeURIComponent);
    if (params[key] !== undefined) {
      // 相同 key 多次出现，转数组
      params[key] = [].concat(params[key], value);
    } else {
      params[key] = value;
    }
    return params;
  }, {});
}

// ── 验证 ──
console.log(
  parseQuery("https://example.com?name=Linus&age=55&tag=dev&tag=linux"),
);
// { name: 'Linus', age: '55', tag: ['dev', 'linux'] }
```

> **本质洞察**：URL 参数解析最容易忽略的边界是**同一个 key 出现多次**——在 HTTP 规范中这是合法的，需要转为数组。`URLSearchParams` 原生支持 `.getAll(key)`。

#### 8. 实现 JSON.stringify

```javascript
// ─────────────────────────────────────────────────
//  jsonStringify — 手写 JSON 序列化
// ─────────────────────────────────────────────────

function jsonStringify(value) {
  // null
  if (value === null) return "null";

  // 基本类型
  if (typeof value === "string") return `"${value}"`;
  if (typeof value === "number" || typeof value === "boolean")
    return String(value);
  if (
    typeof value === "undefined" ||
    typeof value === "function" ||
    typeof value === "symbol"
  ) {
    return undefined; // JSON 规范：这些类型被忽略
  }

  // Date
  if (value instanceof Date) return `"${value.toISOString()}"`;

  // 数组
  if (Array.isArray(value)) {
    const items = value.map((v) => jsonStringify(v) ?? "null"); // undefined 转 null
    return `[${items.join(",")}]`;
  }

  // 对象
  if (typeof value === "object") {
    const entries = Object.keys(value)
      .map((key) => {
        const val = jsonStringify(value[key]);
        if (val === undefined) return undefined; // 跳过 undefined/function
        return `"${key}":${val}`;
      })
      .filter(Boolean);
    return `{${entries.join(",")}}`;
  }
}

// ── 验证 ──
const testObj = {
  name: "Linus",
  age: 55,
  fn: () => {},
  undef: undefined,
  arr: [1, null, "str"],
};
console.log(jsonStringify(testObj));
// '{"name":"Linus","age":55,"arr":[1,null,"str"]}'
console.log(jsonStringify(testObj) === JSON.stringify(testObj)); // true
```

> **本质洞察**：`JSON.stringify` 最反直觉的行为是——`undefined` 和 `function` 在**对象中被删除**，在**数组中被转为 `null`**。这是因为 JSON 是语言无关的序列化格式，它没有 undefined 和 function 的概念。

#### 9. 实现 JSON.parse

```javascript
// ─────────────────────────────────────────────────
//  jsonParse — 手写 JSON 反序列化（安全版）
// ─────────────────────────────────────────────────

// 方式一：new Function（比 eval 稍安全）
function jsonParse(str) {
  return new Function("return " + str)();
}

// 方式二：利用原生 JSON.parse + reviver（面试时通常考方式一）

// ── 验证 ──
const json = '{"name":"Linus","age":55,"active":true}';
console.log(jsonParse(json)); // { name: 'Linus', age: 55, active: true }
```

> **本质洞察**：`eval` 和 `new Function` 都能解析 JSON，但都有**代码注入风险**。生产环境请永远使用原生 `JSON.parse`。手写这道题的目的是理解"JSON 是 JavaScript 对象字面量语法的子集"这一事实。

---

## 质量指标

- **时间复杂度意识**：`arrayToTree` 必须是 O(n)，禁止 O(n²) 的嵌套循环方案。
- **异常鲁棒性**：`get/set` 必须处理 `null`、`undefined` 中间节点。
- **引用隔离**：`arrayToTree` 应返回新节点副本，避免污染原始数组。
- **边界覆盖**：大数运算需处理前导零、空字符串。
