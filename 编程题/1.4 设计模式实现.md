<!--
- [INPUT]: 观察者模式、中介者模式、闭包、Proxy、状态机理论
- [OUTPUT]: 前端常见设计模式的工业级手写实现与模式对比分析
- [POS]: 编程题/ 模块的设计模式专题，提升系统解耦与架构抽象能力
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.4 设计模式实现

设计模式不是僵化的模板，而是**面对复杂度时的战术方案**。在前端领域，模式解决的核心问题是：组件间通信、状态流转、代码的「对扩展开放、对修改关闭」。每一个模式都是前人付出惨痛 bug 代价后提炼出的智慧结晶。

---

| 题目                          | 难度   | 优先级 | 考察点                                      |
| :---------------------------- | :----- | :----- | :------------------------------------------ |
| **单例模式（普通/惰性）**     | ⭐⭐   | 必会   | 闭包、static 变量、唯一实例保证             |
| **发布订阅模式 EventEmitter** | ⭐⭐⭐ | 必会   | 事件系统核心、once、off 精准卸载            |
| **观察者模式**                | ⭐⭐   | 掌握   | Subject/Observer 双向职责、与发布订阅的区别 |
| **代理模式（缓存代理）**      | ⭐⭐   | 掌握   | Proxy 拦截、缓存策略                        |
| **策略模式**                  | ⭐⭐   | 掌握   | 消除 if-else、策略配置化                    |
| **装饰器模式**                | ⭐⭐   | 了解   | AOP 切面编程、高阶函数                      |
| **命令模式**                  | ⭐⭐⭐ | 掌握   | 撤销/重做基础、命令队列                     |
| **状态机模式**                | ⭐⭐⭐ | 掌握   | 复杂状态管理、状态转移表                    |

### 1. 单例模式（Singleton）

确保一个类只有一个实例，并提供全局访问点。

```javascript
// ─────────────────────────────────────────────────
//  Singleton — 惰性单例
// ─────────────────────────────────────────────────

// 方式一：Class + static（简洁）
class Singleton {
  static instance = null;

  constructor(name) {
    if (Singleton.instance) return Singleton.instance;
    this.name = name;
    Singleton.instance = this;
  }
}

// 方式二：闭包（更灵活，可包装任意类）
function createSingleton(Creator) {
  let instance = null;
  return function (...args) {
    if (!instance) {
      instance = new Creator(...args);
    }
    return instance;
  };
}

// ── 验证 ──
const a = new Singleton("first");
const b = new Singleton("second");
console.log(a === b); // true
console.log(b.name); // "first"（返回的是第一次创建的实例）

class DB {
  constructor(url) {
    this.url = url;
    console.log(`Connected to ${url}`);
  }
}
const getDB = createSingleton(DB);
const db1 = getDB("postgres://localhost"); // 输出 Connected...
const db2 = getDB("postgres://remote"); // 无输出（直接返回已有实例）
console.log(db1 === db2); // true
```

> **本质洞察**：单例的哲学是「唯一性是一种约束而非特性」。数据库连接池、全局状态管理器（Redux Store）天然是单例——它们的多实例会导致数据不一致。闭包版的 `createSingleton` 更优雅，因为它把"是否单例"的决策从**类自身**抽离到**使用方**。

---

### 2. 发布订阅模式 EventEmitter

通过一个中介中心（Event Bus）实现事件的注册、分发和注销。

```javascript
// ─────────────────────────────────────────────────
//  EventEmitter — 工业级发布订阅中心
// ─────────────────────────────────────────────────

class EventEmitter {
  constructor() {
    this.events = Object.create(null); // 纯净对象，无 prototype 干扰
  }

  // 注册监听
  on(type, handler) {
    (this.events[type] || (this.events[type] = [])).push(handler);
    return this;
  }

  // 触发事件
  emit(type, ...args) {
    const handlers = this.events[type];
    if (!handlers) return false;

    // 浅拷贝，防止 handler 执行中 off 导致数组变异跳过任务
    [...handlers].forEach((handler) => {
      try {
        handler.apply(this, args);
      } catch (e) {
        console.error(`[EventEmitter] Error in "${type}":`, e);
      }
    });
    return true;
  }

  // 移除监听
  off(type, handler) {
    const handlers = this.events[type];
    if (!handlers) return this;

    this.events[type] = handlers.filter(
      (h) => h !== handler && h._origin !== handler,
    );
    return this;
  }

  // 一次性监听
  once(type, handler) {
    const wrapper = (...args) => {
      this.off(type, wrapper);
      handler.apply(this, args);
    };
    wrapper._origin = handler; // 保留原函数引用，off(type, originalHandler) 能正确匹配
    return this.on(type, wrapper);
  }

  // 移除某类型的所有监听
  removeAllListeners(type) {
    if (type) {
      delete this.events[type];
    } else {
      this.events = Object.create(null);
    }
    return this;
  }

  // 获取监听器数量
  listenerCount(type) {
    return (this.events[type] || []).length;
  }
}

// ── 验证 ──
const bus = new EventEmitter();

const onPlay = (song) => console.log(`Playing: ${song}`);
bus.on("play", onPlay);
bus.once("play", (song) => console.log(`Logged: ${song}`));

bus.emit("play", "Hey Jude"); // Playing: Hey Jude / Logged: Hey Jude
bus.emit("play", "Let It Be"); // Playing: Let It Be（once 已自动移除）

bus.off("play", onPlay);
bus.emit("play", "Something"); // 无输出（所有监听已清除）
console.log(bus.listenerCount("play")); // 0
```

> **本质洞察**：`once` 的实现中 `wrapper._origin = handler` 这行代码解决了一个微妙问题——如果用户在 `once` 注册后、触发前调用 `off(type, originalHandler)` 来取消，它能正确匹配到内部的 wrapper 并移除。丢掉这个引用，`off` 就无法清除 `once` 注册的监听器。

---

### 3. 观察者模式 (Observer)

Observer 和 Subject 直接建立联系，**没有中介**——Subject 维护观察者列表并直接通知。

```javascript
// ─────────────────────────────────────────────────
//  Observer Pattern — 无中介的直接通知
// ─────────────────────────────────────────────────

// 被观察者
class Subject {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
    }
  }

  removeObserver(observer) {
    this.observers = this.observers.filter((o) => o !== observer);
  }

  notify(data) {
    this.observers.forEach((observer) => observer.update(data));
  }
}

// 观察者
class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`[${this.name}] received: ${JSON.stringify(data)}`);
  }
}

// ── 验证 ──
const store = new Subject();
const componentA = new Observer("Header");
const componentB = new Observer("Sidebar");

store.addObserver(componentA);
store.addObserver(componentB);
store.notify({ type: "LOGIN", user: "Linus" });
// [Header] received: {"type":"LOGIN","user":"Linus"}
// [Sidebar] received: {"type":"LOGIN","user":"Linus"}

store.removeObserver(componentB);
store.notify({ type: "LOGOUT" });
// [Header] received: {"type":"LOGOUT"}
```

**观察者 vs 发布订阅对比**：

| 维度     | 观察者模式                | 发布订阅模式                      |
| :------- | :------------------------ | :-------------------------------- |
| 耦合度   | Subject 直接引用 Observer | 通过 EventBus 中介解耦            |
| 通信方式 | 同步调用 `update()`       | 基于 Event Name 分发              |
| 谁触发   | Subject.notify()          | EventEmitter.emit()               |
| 适用场景 | Vue 响应式数据更新        | 跨模块事件总线、Node EventEmitter |

> **本质洞察**：观察者模式是**耦合的**（Subject 知道 Observer 的接口），发布订阅是**解耦的**（发布者和订阅者互不相识，只认识 Event Bus）。Vue 的 `reactive` 是观察者模式，Vue 的 `$emit` 是发布订阅模式——两者共存于同一个框架，服务不同的场景。

---

### 4. 代理模式（缓存代理）

在不修改原函数的前提下，为其增加缓存层。

```javascript
// ─────────────────────────────────────────────────
//  缓存代理 — 记忆化计算结果
// ─────────────────────────────────────────────────

function createCacheProxy(fn) {
  const cache = new Map();
  return new Proxy(fn, {
    apply(target, thisArg, args) {
      const key = JSON.stringify(args);
      if (cache.has(key)) {
        console.log(`[Cache Hit] ${key}`);
        return cache.get(key);
      }
      const result = Reflect.apply(target, thisArg, args);
      cache.set(key, result);
      return result;
    },
  });
}

// ── 验证 ──
function heavyCompute(a, b) {
  console.log("Computing...");
  return a * b + a + b;
}

const cachedCompute = createCacheProxy(heavyCompute);
console.log(cachedCompute(10, 20)); // Computing... → 230
console.log(cachedCompute(10, 20)); // [Cache Hit] → 230（不再计算）
console.log(cachedCompute(5, 5)); // Computing... → 35
```

> **本质洞察**：`Proxy` 的 `apply` trap 拦截函数调用，是 JavaScript 中实现 AOP（面向切面编程）最优雅的方式。缓存代理的本质是**用空间换时间**——React 的 `useMemo` 和 `React.memo` 就是缓存代理的框架级应用。

---

### 5. 策略模式 (Strategy)

将算法封装到独立的策略对象中，通过配置（而非分支）选择行为。

```javascript
// ─────────────────────────────────────────────────
//  策略模式 — 消除 if-else 分支
// ─────────────────────────────────────────────────

// 策略映射表
const validationStrategies = {
  isNonEmpty: (value) => value.trim() !== "" || "不能为空",
  minLength: (value, len) => value.length >= len || `最少 ${len} 个字符`,
  isMobile: (value) => /^1[3-9]\d{9}$/.test(value) || "手机号格式错误",
  isEmail: (value) => /^\S+@\S+\.\S+$/.test(value) || "邮箱格式错误",
};

// 验证器
class Validator {
  constructor() {
    this.rules = [];
  }

  addRule(value, strategy, ...params) {
    this.rules.push(() => validationStrategies[strategy](value, ...params));
  }

  validate() {
    for (const rule of this.rules) {
      const result = rule();
      if (result !== true) return result; // 返回第一个错误信息
    }
    return true;
  }
}

// ── 验证 ──
const v = new Validator();
v.addRule("", "isNonEmpty");
v.addRule("ab", "minLength", 6);
v.addRule("bad-phone", "isMobile");

console.log(v.validate()); // "不能为空"（返回第一个不通过的）

const v2 = new Validator();
v2.addRule("hello@world.com", "isEmail");
console.log(v2.validate()); // true
```

> **本质洞察**：策略模式的哲学是「行为可以像数据一样被配置」。每多一个 if-else 分支，代码就多一个僵化点。策略表让新增规则变成**加一行配置**而非修改判断逻辑——这就是"对修改关闭、对扩展开放"的活体标本。

---

### 6. 装饰器模式 (Decorator / AOP)

在不修改原函数源码的情况下，给它"穿上外套"——增加前置/后置逻辑。

```javascript
// ─────────────────────────────────────────────────
//  AOP — 面向切面增强
// ─────────────────────────────────────────────────

Function.prototype.before = function (beforeFn) {
  const originalFn = this;
  return function (...args) {
    beforeFn.apply(this, args); // 前置切面
    return originalFn.apply(this, args);
  };
};

Function.prototype.after = function (afterFn) {
  const originalFn = this;
  return function (...args) {
    const result = originalFn.apply(this, args);
    afterFn.apply(this, args); // 后置切面
    return result;
  };
};

// ── 验证 ──
function submitForm(data) {
  console.log("提交表单:", data);
  return "submitted";
}

const enhancedSubmit = submitForm
  .before((data) => console.log("验证参数:", data))
  .after((data) => console.log("埋点上报:", data));

enhancedSubmit({ name: "test" });
// 验证参数: { name: 'test' }
// 提交表单: { name: 'test' }
// 埋点上报: { name: 'test' }
```

> **本质洞察**：装饰器的精髓是「洋葱模型」——请求像穿洋葱一样层层进入，响应又层层退出。Express 中间件、Koa 的 `next()`、Redux 中间件，本质上都是装饰器模式的链式变体。

---

### 7. 命令模式 (Command)

将操作封装为对象，支持撤销（Undo）和重做（Redo）。

```javascript
// ─────────────────────────────────────────────────
//  命令模式 — 支持撤销/重做
// ─────────────────────────────────────────────────

class CommandManager {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
  }

  execute(command) {
    command.execute();
    this.undoStack.push(command);
    this.redoStack.length = 0; // 执行新命令后，清空重做栈
  }

  undo() {
    const command = this.undoStack.pop();
    if (command) {
      command.undo();
      this.redoStack.push(command);
    }
  }

  redo() {
    const command = this.redoStack.pop();
    if (command) {
      command.execute();
      this.undoStack.push(command);
    }
  }
}

// 具体命令：文本编辑
class InsertTextCommand {
  constructor(editor, text) {
    this.editor = editor;
    this.text = text;
  }

  execute() {
    this.editor.content += this.text;
    console.log(`插入 "${this.text}" → "${this.editor.content}"`);
  }

  undo() {
    this.editor.content = this.editor.content.slice(0, -this.text.length);
    console.log(`撤销 "${this.text}" → "${this.editor.content}"`);
  }
}

// ── 验证 ──
const editor = { content: "" };
const manager = new CommandManager();

manager.execute(new InsertTextCommand(editor, "Hello")); // 插入 "Hello" → "Hello"
manager.execute(new InsertTextCommand(editor, " World")); // 插入 " World" → "Hello World"
manager.undo(); // 撤销 " World" → "Hello"
manager.undo(); // 撤销 "Hello" → ""
manager.redo(); // 插入 "Hello" → "Hello"
```

> **本质洞察**：命令模式把「动作」从「执行者」中解耦出来，变成可存储、可回放、可撤销的**一等公民**。每一个 `command` 对象都是一条「历史记录」——这正是文本编辑器 Ctrl-Z 和 Git 版本控制的底层原理。

---

### 8. 状态机模式 (State Machine)

用状态转移表显式定义所有合法状态和转移条件，取代散落在各处的 if-else。

```javascript
// ─────────────────────────────────────────────────
//  StateMachine — 有限状态机
// ─────────────────────────────────────────────────

class StateMachine {
  constructor(config) {
    this.state = config.initial;
    this.transitions = config.transitions;
  }

  transition(event) {
    const currentTransitions = this.transitions[this.state];
    if (!currentTransitions || !currentTransitions[event]) {
      console.warn(`[FSM] No transition: ${this.state} + ${event}`);
      return false;
    }

    const nextState = currentTransitions[event];
    console.log(`[FSM] ${this.state} --${event}--> ${nextState}`);
    this.state = nextState;
    return true;
  }

  getState() {
    return this.state;
  }
}

// ── 验证：Promise 状态机 ──
const promiseFSM = new StateMachine({
  initial: "pending",
  transitions: {
    pending: {
      resolve: "fulfilled",
      reject: "rejected",
    },
    // fulfilled 和 rejected 都没有任何转移 → 终态
    fulfilled: {},
    rejected: {},
  },
});

promiseFSM.transition("resolve"); // pending --resolve--> fulfilled
promiseFSM.transition("reject"); // [FSM] No transition（已经是 fulfilled，不可逆）
console.log(promiseFSM.getState()); // "fulfilled"

// ── 验证：红绿灯 ──
const trafficLight = new StateMachine({
  initial: "red",
  transitions: {
    red: { timer: "green" },
    green: { timer: "yellow" },
    yellow: { timer: "red" },
  },
});

trafficLight.transition("timer"); // red → green
trafficLight.transition("timer"); // green → yellow
trafficLight.transition("timer"); // yellow → red
```

> **本质洞察**：状态机把散落在代码各处的 `if (status === 'xxx')` 收归到一张**转移表**中。非法状态转移会被自动拦截，而非悄无声息地产生 bug。Promise 本身就是一个三态状态机——Pending → Fulfilled/Rejected，且不可逆。

---

## 质量指标

- **解耦程度**：EventEmitter 的 handler 之间互不影响（Try-Catch），单个 handler 异常不阻塞其他 handler。
- **内存安全**：`once` 的包装函数保留 `_origin` 引用，确保 `off` 能正确清理。
- **扩展性**：策略模式应能通过 `strategies[newKey] = fn` 动态添加新策略而无需修改验证器。
- **不可逆性**：状态机的终态不应有任何出边（transition），违反即是 bug。
