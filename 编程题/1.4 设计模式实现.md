<!--
- [INPUT]: 观察者模式、中介者模式、闭包、解耦原则
- [OUTPUT]: 前端常见设计模式的工业级手写代码
- [POS]: 编程题/ 模块的设计模式专题，提升系统解耦与架构能力
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.4 设计模式实现

设计模式不是僵化的模板，而是**面对复杂度时的战术方案**。在前端领域，模式往往用于解决组件间通信、状态流转及代码的开写闭合问题。

---

### 1.4.1 发布订阅与观察者 (Pub-Sub & Observer)

**现象**：组件 A 的点击需要通知无关的组件 B 和 C 进行刷新。
**本质**：通过一个中介（EventEmitter）或直接建立一对多的依赖关系（Observer），实现**时间与空间的解耦**。

| 题目                      | 难度   | 优先级 | 考察点                                  |
| :------------------------ | :----- | :----- | :-------------------------------------- |
| **发布订阅 EventEmitter** | ⭐⭐⭐ | 必会   | 数组存储监听者、once 实现、off 精准卸载 |
| **观察者模式实现**        | ⭐⭐   | 掌握   | Subject 与 Observer 的双向职责划分      |
| **两者对比分析**          | ⭐     | 必会   | 是否存在调度中心、耦合度差异            |

#### 1. EventEmitter 实现

发布订阅模式的标配：支持多参数、一次性监听、错误隔离。

```javascript
// ─────────────────────────────────────────────────
//  EventEmitter — 工业级发布订阅中心
// ─────────────────────────────────────────────────

class EventEmitter {
  constructor() {
    this.events = {};
  }

  // 监听事件
  on(type, handler) {
    if (!this.events[type]) {
      this.events[type] = [];
    }
    this.events[type].push(handler);
    return this; // 支持链式调用
  }

  // 发布事件
  emit(type, ...args) {
    const handlers = this.events[type];
    if (!handlers) return false;

    // 浅拷贝一份，防止在执行过程中修改原数组（如 off 调用）导致跳过任务
    [...handlers].forEach((handler) => {
      try {
        handler.apply(this, args);
      } catch (e) {
        console.error(`Error in event "${type}":`, e);
      }
    });
    return true;
  }

  // 卸载事件
  off(type, handler) {
    if (!this.events[type]) return this;

    this.events[type] = this.events[type].filter(
      (h) => h !== handler && h.origin !== handler,
    );
    return this;
  }

  // 只执行一次
  once(type, handler) {
    const wrapper = (...args) => {
      this.off(type, wrapper);
      handler.apply(this, args);
    };
    // 关键：保留原函数引用，方便 off(type, originalHandler)
    wrapper.origin = handler;
    this.on(type, wrapper);
    return this;
  }
}

// ── 验证 ──
const bus = new EventEmitter();
const play = (song) => console.log(`Playing: ${song}`);

bus.on("play", play);
bus.once("play", (song) => console.log(`Logging: ${song}`));

bus.emit("play", "Hey Jude"); // 触发两个
bus.emit("play", "Let It Be"); // 只触发第一个
bus.off("play", play);
bus.emit("play", "Something"); // 无输出
```

> **本质洞察**：`EventEmitter` 是典型的**中介者模式**应用。它消除了"谁触发了事件"和"谁监听了事件"之间的直接引用，是构建大型可插拔系统的基石。

---

### 1.4.2 创建型与行为型模式 (Creational & Behavioral)

| 题目                     | 难度 | 优先级 | 考察点                                |
| :----------------------- | :--- | :----- | :------------------------------------ |
| **单例模式 (Singleton)** | ⭐⭐ | 必会   | 惰性初始化、闭包/Static 变量唯一性    |
| **策略模式 (Strategy)**  | ⭐⭐ | 掌握   | Map 对象消除 if-else 分支、逻辑配置化 |
| **代理模式 (Proxy)**     | ⭐⭐ | 掌握   | 缓存代理的基础实现、Proxy 拦截        |

#### 策略模式示例 (消除 if-else)

```javascript
// ─────────────────────────────────────────────────
//  策略模式 — 将算法家族独立封装
// ─────────────────────────────────────────────────

const calculateBonus = (level, salary) => {
  const strategies = {
    S: (s) => s * 4,
    A: (s) => s * 3,
    B: (s) => s * 2,
  };

  return (strategies[level] || ((s) => s))(salary);
};

console.log(calculateBonus("S", 20000)); // 80000
```

---

## 质量指标

- **解耦程度**：`EventEmitter` 必须确保事件处理器互不影响（Try-Catch）。
- **清理逻辑**：`once` 的包裹函数必须能被正确引用并清理，防止内存溢出。
- **扩展性**：策略模式应易于动态添加新策略，无需修改主逻辑。
