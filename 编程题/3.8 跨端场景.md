<!--
- [INPUT]: Native WebKit/WebView, JSBridge Protocols, Offline Caching Strategies, Containerization
- [OUTPUT]: 跨端移动开发架构设计与通信方案要求
- [POS]: 编程题/ 复杂场景专题，聚焦 Hybrid 混合开发与多端一致性方案
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.8 跨端场景

跨端开发不仅要追求"一套代码，多端运行"，更要解决 Web 环境与原生环境（Native）之间的通信边界与体验落差。

---

### 3.8.1 JSBridge 通信设计 ⭐⭐⭐

**要求：** 设计一套基于 Hybrid 架构的双向通信协议栈。

- **实战要素：**
  - **通信协议规范**：定义 `Native://method?params&callbackId` 的标准化调用协议。
  - **回调映射机制**：实现 JS 与 Native 异步通信的回调存储与触发逻辑。
  - **超时与异常处理**：处理 Native 响应超时或由于环境版本导致的调用失败。
  - **降级与 mock**：在普通浏览器环境中实现功能 Mock，保证业务代码的不侵入性。
  - **版本兼容管理**：通过能力检测（Feature Detection）管理 SDK 应用的版本梯度。

#### 1. JSBridge 核心协议实现

```javascript
// ─────────────────────────────────────────────────
//  JSBridge — Hybrid 双向通信协议栈
// ─────────────────────────────────────────────────

class JSBridge {
  constructor(options = {}) {
    this.callbackMap = {}; // callbackId → {resolve, reject, timer}
    this.callbackId = 0;
    this.timeout = options.timeout || 5000;
    this.mockHandlers = {}; // 浏览器降级 Mock
    this.isNative = this._detectNative();

    // 暴露给 Native 调用的全局入口
    window.__JSBridge_callback__ = this._onNativeCallback.bind(this);
  }

  // ── 环境检测 ──────────────────────────────────
  _detectNative() {
    return !!(
      window.webkit?.messageHandlers || // iOS WKWebView
      window.NativeBridge // Android 注入
    );
  }

  // ── JS 调用 Native（核心） ────────────────────
  invoke(method, params = {}) {
    return new Promise((resolve, reject) => {
      const id = `cb_${++this.callbackId}_${Date.now()}`;

      // 1. 注册回调
      const timer = setTimeout(() => {
        delete this.callbackMap[id];
        reject(new Error(`JSBridge 调用超时: ${method}`));
      }, this.timeout);

      this.callbackMap[id] = { resolve, reject, timer };

      // 2. 发送消息到 Native
      if (this.isNative) {
        this._sendToNative(method, params, id);
      } else {
        // 非 Native 环境 → 走 Mock
        this._invokeMock(method, params, id);
      }
    });
  }

  _sendToNative(method, params, callbackId) {
    const message = { method, params, callbackId };

    if (window.webkit?.messageHandlers?.bridge) {
      // iOS WKWebView
      window.webkit.messageHandlers.bridge.postMessage(message);
    } else if (window.NativeBridge?.postMessage) {
      // Android
      window.NativeBridge.postMessage(JSON.stringify(message));
    } else {
      // 兜底：URL Scheme 拦截（最古老但兼容性最好）
      const iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.src = `native://${method}?params=${encodeURIComponent(
        JSON.stringify(params),
      )}&callbackId=${callbackId}`;
      document.body.appendChild(iframe);
      setTimeout(() => iframe.remove(), 100);
    }
  }

  // ── Native 回调 JS ────────────────────────────
  _onNativeCallback(callbackId, result) {
    const callback = this.callbackMap[callbackId];
    if (!callback) return;

    clearTimeout(callback.timer);
    delete this.callbackMap[callbackId];

    if (result.error) {
      callback.reject(new Error(result.error));
    } else {
      callback.resolve(result.data);
    }
  }

  // ── 浏览器降级 Mock ───────────────────────────
  registerMock(method, handler) {
    this.mockHandlers[method] = handler;
  }

  async _invokeMock(method, params, callbackId) {
    const handler = this.mockHandlers[method];
    const callback = this.callbackMap[callbackId];

    if (!handler) {
      clearTimeout(callback.timer);
      delete this.callbackMap[callbackId];
      callback.reject(new Error(`无 Mock: ${method}`));
      return;
    }

    try {
      const result = await handler(params);
      this._onNativeCallback(callbackId, { data: result });
    } catch (e) {
      this._onNativeCallback(callbackId, { error: e.message });
    }
  }

  // ── 能力检测 ──────────────────────────────────
  supports(method) {
    if (this.isNative) {
      // 通过同步调用检测 Native 是否注册了该方法
      return window.__NativeCapabilities__?.includes(method) ?? false;
    }
    return method in this.mockHandlers;
  }
}

// ── 使用示例 ────────────────────────────────────
const bridge = new JSBridge({ timeout: 3000 });

// 注册 Mock（开发环境可用）
bridge.registerMock("getLocation", async () => ({
  lat: 39.9042,
  lng: 116.4074,
}));

// 业务代码——不关心是 Native 还是 Mock
const location = await bridge.invoke("getLocation");
```

> **本质洞察**：JSBridge 的设计本质是 **「异构进程间通信 (IPC)」**。JS 线程和 Native 线程是两个独立的执行空间，它们之间的通信和操作系统中的进程通信面临完全相同的问题：序列化/反序列化、异步回调匹配、超时处理、版本协商。**callbackMap 就是一个简化版的系统调用表（syscall table）**，每个 callbackId 就是一个 "文件描述符"。

---

### 3.8.2 离线包方案与资源拦截 ⭐⭐⭐

**要求：** 设计并模拟一个完整的资源离线化分发与劫持流程。

- **核心环节：**
  - **分发与更新逻辑**：实现增量包下载、MD5 校验与后台静默更新流程。
  - **资源请求拦截**：WebView 侧对 HTTP 请求的拦截并映射到本地文件系统的逻辑。
  - **版本回滚能力**：应对质量故障的快速降级与多版本共存管理。

#### 1. 离线包管理器

```javascript
// ─────────────────────────────────────────────────
//  OfflinePackageManager — 离线包分发与管理
// ─────────────────────────────────────────────────

class OfflinePackageManager {
  constructor(config) {
    this.cdnBase = config.cdnBase;
    this.dbName = "OfflinePackages";
    this.currentVersion = null;
    this.manifest = null; // 资源清单 {path → {hash, size}}
  }

  // ── 初始化：检查更新 ──────────────────────────
  async init() {
    this.currentVersion = await this._getLocalVersion();
    const remoteManifest = await this._fetchManifest();

    if (remoteManifest.version !== this.currentVersion) {
      await this._downloadDiff(remoteManifest);
    }
    this.manifest = remoteManifest;
  }

  // ── 增量更新：只下载变更文件 ──────────────────
  async _downloadDiff(remoteManifest) {
    const localManifest = await this._getLocalManifest();
    const diffFiles = [];

    // 对比 hash，找出变更文件
    for (const [path, info] of Object.entries(remoteManifest.files)) {
      if (
        !localManifest?.files?.[path] ||
        localManifest.files[path].hash !== info.hash
      ) {
        diffFiles.push(path);
      }
    }

    // 并行下载变更文件
    const downloads = diffFiles.map(async (path) => {
      const response = await fetch(`${this.cdnBase}/${path}`);
      const blob = await response.blob();

      // MD5 校验
      const hash = await this._calcHash(blob);
      if (hash !== remoteManifest.files[path].hash) {
        throw new Error(`文件校验失败: ${path}`);
      }

      return { path, blob };
    });

    try {
      const results = await Promise.all(downloads);
      await this._saveToLocal(results, remoteManifest);
    } catch (e) {
      console.error("增量更新失败，保持当前版本:", e);
      // 更新失败不影响使用旧版本
    }
  }

  // ── 资源拦截：URL → 本地文件映射 ──────────────
  async interceptRequest(url) {
    const path = new URL(url).pathname;

    // 查找本地缓存
    const localBlob = await this._getLocalFile(path);
    if (localBlob) {
      return new Response(localBlob, {
        headers: { "X-Source": "offline-cache" },
      });
    }

    // 本地没有 → 回退网络请求
    return fetch(url);
  }

  // ── 版本回滚 ──────────────────────────────────
  async rollback() {
    const previousVersion = await this._getPreviousVersion();
    if (previousVersion) {
      await this._switchVersion(previousVersion);
      location.reload(); // 重载以应用旧版本资源
    }
  }

  // ── 多版本管理 ────────────────────────────────
  async _saveToLocal(files, manifest) {
    const db = await this._openDB();
    const tx = db.transaction(["files", "versions"], "readwrite");

    // 保存文件
    const fileStore = tx.objectStore("files");
    files.forEach(({ path, blob }) => {
      fileStore.put({ path, blob, version: manifest.version });
    });

    // 保存版本记录（保留最近 3 个版本）
    const versionStore = tx.objectStore("versions");
    versionStore.put({
      version: manifest.version,
      manifest,
      timestamp: Date.now(),
    });
  }
}
```

> **本质洞察**：离线包方案的本质是在客户端建立了一个 **「本地 CDN」**。它的三个核心问题映射到分布式系统中就是：**数据同步**（增量更新）、**一致性校验**（MD5）、**故障回退**（版本回滚）。这和 Git 的工作原理惊人地相似 —— manifest 就是 commit，hash 就是 object id，rollback 就是 git reset。

---

### 3.8.3 多端适配与抹平技术 ⭐⭐⭐

**要求：** 在跨端开发（如小程序、RN、H5）中建立一套标准化的适配工具链。

- **技术要求：**
  - **条件编译机制**：设计基于编译时环境变量的代码分支选择方案。
  - **API 抹平设计**：统一各端（如位置获取、导航控制）的异步接口调用标准。
  - **样式适配方案**：处理不同物理像素密度下（rem/px/rpx）的视觉一致性。
  - **跨端组件差异**：设计抽象化的核心组件层，支持跨 Runtime 的差异化渲染。

#### 1. API 抹平层

```javascript
// ─────────────────────────────────────────────────
//  UnifiedAPI — 跨端 API 适配层
// ─────────────────────────────────────────────────

class UnifiedAPI {
  constructor() {
    this.platform = this._detectPlatform();
    this.adapters = {};
  }

  _detectPlatform() {
    if (typeof wx !== "undefined") return "wechat";
    if (typeof my !== "undefined") return "alipay";
    if (typeof swan !== "undefined") return "baidu";
    if (typeof tt !== "undefined") return "tiktok";
    return "h5";
  }

  // ── 注册平台适配器 ────────────────────────────
  registerAdapter(apiName, platformMap) {
    this.adapters[apiName] = platformMap;
  }

  // ── 统一调用入口 ──────────────────────────────
  async call(apiName, params = {}) {
    const adapter = this.adapters[apiName];
    if (!adapter) throw new Error(`未注册的 API: ${apiName}`);

    const platformImpl = adapter[this.platform] || adapter.fallback;
    if (!platformImpl) {
      throw new Error(`平台 ${this.platform} 不支持 ${apiName}`);
    }

    return platformImpl(params);
  }
}

// ── 注册示例：定位 API 抹平 ─────────────────────
const api = new UnifiedAPI();

api.registerAdapter("getLocation", {
  wechat: (params) =>
    new Promise((resolve, reject) => {
      wx.getLocation({
        type: "gcj02",
        success: (res) => resolve({ lat: res.latitude, lng: res.longitude }),
        fail: reject,
      });
    }),
  h5: () =>
    new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(
        (pos) =>
          resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude }),
        reject,
      );
    }),
  fallback: () => Promise.resolve({ lat: 0, lng: 0 }),
});

// 业务代码：一行适配所有平台
const loc = await api.call("getLocation");
```

#### 2. 条件编译机制

```javascript
// ─────────────────────────────────────────────────
//  条件编译 — Webpack/Vite 插件模式
// ─────────────────────────────────────────────────

// 源代码中使用编译指令标记：
// #ifdef WECHAT
// console.log("微信小程序专用代码");
// #endif

// #ifdef H5
// console.log("H5 专用代码");
// #endif

// Webpack Loader 实现条件编译
function conditionalCompileLoader(source) {
  const platform = this.query.platform || "h5";

  // 正则匹配 #ifdef / #endif 块
  const pattern = /#ifdef\s+(\w+)\n([\s\S]*?)#endif/g;

  return source.replace(pattern, (match, condition, code) => {
    return condition.toUpperCase() === platform.toUpperCase() ? code : "";
  });
}

// ── 样式适配：px → rpx 自动转换 ─────────────────
function pxToRpx(cssContent, designWidth = 750) {
  // 750 设计稿下 1px = 1rpx
  return cssContent.replace(/(\d+(\.\d+)?)px/g, (match, value) => {
    const rpxValue = (parseFloat(value) * (750 / designWidth)).toFixed(2);
    return `${rpxValue}rpx`;
  });
}
```

> **本质洞察**：多端适配的哲学核心是 **「抽象层的位置决定了灵活性的边界」**。API 抹平层是一个 **适配器模式 (Adapter Pattern)** 的工程实践，条件编译是 **编译期多态** 的体现。它们共同构成了经典的 **分层架构**：业务代码 → 统一接口层 → 平台适配层 → 原生能力。层与层之间只通过契约（接口）通信，这是所有"一次编写，到处运行"方案的共同基因 —— 从 Java 的 JVM 到 Flutter 的 Skia，概莫能外。

---

## 质量指标

- **通信延迟**：JSBridge 调用的平均耗时波动。
- **离线覆盖率**：首屏核心资源的二次打开离线化指标（P99）。
- **维护成本**：跨端方案是否提供了健壮的调试工具与模拟环境。
