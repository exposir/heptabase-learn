<!--
- [INPUT]: DOM API、事件冒泡机制、浏览器视口几何计算
- [OUTPUT]: 高性能的基础 UI 交互与浏览器能力封装
- [POS]: 编程题/ 模块的终端交互专题，连接逻辑与视图的桥梁
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.5 DOM 与事件

在框架时代，直接操作 DOM 已非主流，但**理解原生 API 是优化性能与解决边界问题（如第三方组件集成）的最后底牌**。

---

### 1.5.1 事件处理 (Event Handling)

**现象**：为 1000 个列表项绑定点击事件会导致严重的内存占用与初次渲染卡顿。
**本质**：利用**事件冒泡（Event Bubbling）**机制，将监听器挂载到共同父元素上进行统一分发。

| 题目                | 难度 | 优先级 | 考察点                                        |
| :------------------ | :--- | :----- | :-------------------------------------------- |
| **事件委托封装**    | ⭐⭐ | 必会   | `event.target` 识别、选择器匹配、冒泡控制     |
| **手写 Ajax (XHR)** | ⭐⭐ | 必会   | `readyState` 状态流转、响应处理、Promise 配合 |
| **禁止右键/复制**   | ⭐   | 掌握   | 阻止默认事件 `preventDefault`                 |

#### 1. 通用事件委托实现

```javascript
// ─────────────────────────────────────────────────
//  delegate — 纯原生事件委托助手
// ─────────────────────────────────────────────────

function delegate(parent, selector, type, fn) {
  parent.addEventListener(
    type,
    (event) => {
      const target = event.target;
      // 向上递归查找，判断点击的是否为目标元素（或其子元素）
      const matchedElement = target.closest(selector);

      // 确保匹配到的元素在监听的父容器内
      if (matchedElement && parent.contains(matchedElement)) {
        fn.call(matchedElement, event);
      }
    },
    false,
  );
}

// ── 验证 ──
// <ul id="list"><li>1</li><li>2</li></ul>
// delegate(document.getElementById('list'), 'li', 'click', function(e) {
//   console.log('Clicked item text:', this.innerText);
// });
```

---

### 1.5.2 视口与尺寸 (Viewport & Geometry)

**现象**：图片进入屏幕时再加载（懒加载），或广告滚动到视口时计费。
**本质**：通过 `getBoundingClientRect` 获取元素相对于视口的绝对坐标，与 `window.innerHeight` 进行范围判定。

#### 判定元素是否在视口内

```javascript
// ─────────────────────────────────────────────────
//  isInViewport — 监控元素可见性
// ─────────────────────────────────────────────────

function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  const vWidth = window.innerWidth || document.documentElement.clientWidth;
  const vHeight = window.innerHeight || document.documentElement.clientHeight;

  // 判定四个边界是否都在视口范围内
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= vHeight &&
    rect.right <= vWidth
  );
}

// ── 进阶：IntersectionObserver (现代方案) ──
// const obs = new IntersectionObserver((entries) => {
//   if (entries[0].isIntersecting) { /* 进入视口 */ }
// });
// obs.observe(element);
```

---

### 1.5.3 进阶 DOM 操作 (Advanced DOM)

| 题目                 | 难度 | 优先级 | 考察点                                       |
| :------------------- | :--- | :----- | :------------------------------------------- |
| **标签分布统计**     | ⭐⭐ | 掌握   | `document.querySelectorAll('*')`、Map 计数   |
| **实现 insertAfter** | ⭐   | 了解   | `parentNode.insertBefore` 配合 `nextSibling` |

#### 获取页面所有标签种类及数量

```javascript
const getTagStats = () => {
  const tags = document.querySelectorAll("*");
  const stats = {};

  tags.forEach((tag) => {
    const name = tag.tagName.toLowerCase();
    stats[name] = (stats[name] || 0) + 1;
  });

  return stats;
};

// ── 验证 ──
// console.table(getTagStats());
```

---

## 质量指标

- **兼容性**：优先使用 `closest` 等现代原生接口，若需兼容旧版需手动编写 `while` 循环判定。
- **性能**：事件委托父容器不宜过高（如挂载到 `body`），应尽量靠近目标元素以减少冒泡路径长度。
- **准确性**：视口判定需考虑 `window` 与 `document.documentElement` 的差异。
