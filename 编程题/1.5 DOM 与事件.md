<!--
- [INPUT]: DOM API、事件冒泡/捕获机制、浏览器视口几何 API、XMLHttpRequest
- [OUTPUT]: 高性能的基础 UI 交互封装与浏览器原生能力的深度运用
- [POS]: 编程题/ 模块的终端交互专题，连接 JavaScript 逻辑与浏览器渲染引擎的桥梁
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.5 DOM 与事件

在框架时代直接操作 DOM 已非主流，但**理解原生 API 是优化性能、调试问题和处理边界（如第三方SDK集成）的最后底牌**。面试中考 DOM 操作，考的不是你会不会写，而是你是否理解浏览器工作的底层机制。

---

| 题目                            | 难度 | 优先级 | 考察点                                       |
| :------------------------------ | :--- | :----- | :------------------------------------------- |
| **事件委托封装**                | ⭐⭐ | 必会   | 事件冒泡、`closest` 匹配                     |
| **手写 Ajax（XHR）**            | ⭐⭐ | 必会   | XMLHttpRequest、readyState 状态流转          |
| **实现 getElementsByClassName** | ⭐⭐ | 了解   | 递归遍历 DOM 树                              |
| **实现 insertAfter**            | ⭐   | 了解   | DOM 操作基础                                 |
| **判断 DOM 元素是否在视口**     | ⭐⭐ | 掌握   | getBoundingClientRect / IntersectionObserver |
| **获取页面所有标签种类和数量**  | ⭐⭐ | 了解   | DOM 遍历、Map 计数                           |

### 1. 事件委托封装

利用冒泡机制，将监听器挂载到父元素上，通过 `target` 识别实际触发源。

```javascript
// ─────────────────────────────────────────────────
//  delegate — 通用事件委托助手
// ─────────────────────────────────────────────────

function delegate(parent, selector, type, handler) {
  parent.addEventListener(
    type,
    function (event) {
      // closest 从 event.target 向上查找最近的匹配元素
      const matchedElement = event.target.closest(selector);
      // 确保匹配到的元素是在监听容器内部，而非外部的同名元素
      if (matchedElement && parent.contains(matchedElement)) {
        handler.call(matchedElement, event);
      }
    },
    false, // 在冒泡阶段处理
  );
}

// ── 验证 ──
// <ul id="list">
//   <li><span>Item 1</span></li>
//   <li><span>Item 2</span></li>
// </ul>
//
// delegate(document.getElementById('list'), 'li', 'click', function(e) {
//   console.log('Clicked:', this.textContent);
//   // 即使点击的是 <span>，closest('li') 也能正确匹配到 <li>
// });
```

> **本质洞察**：`closest(selector)` 是事件委托的救星——它从 target 向上遍历直到找到匹配元素。在 `closest` 出现之前，开发者不得不手动 `while (target !== parent)` 循环判断。`parent.contains(matchedElement)` 这步检查看似多余，实则防止了「冒泡穿透」——匹配到的元素可能在 parent 外部。

---

### 2. 手写 Ajax（XHR）

```javascript
// ─────────────────────────────────────────────────
//  ajax — 基于 XMLHttpRequest 的 Promise 封装
// ─────────────────────────────────────────────────

function ajax({ method = "GET", url, data = null, headers = {} }) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(method, url, true);

    // 设置请求头
    Object.entries(headers).forEach(([key, value]) => {
      xhr.setRequestHeader(key, value);
    });

    xhr.onreadystatechange = function () {
      if (xhr.readyState !== 4) return; // 0:未初始化 1:加载 2:已发送 3:接收中 4:完成

      if (xhr.status >= 200 && xhr.status < 300) {
        try {
          resolve(JSON.parse(xhr.responseText));
        } catch {
          resolve(xhr.responseText);
        }
      } else {
        reject(new Error(`HTTP Error: ${xhr.status} ${xhr.statusText}`));
      }
    };

    xhr.onerror = () => reject(new Error("Network Error"));
    xhr.ontimeout = () => reject(new Error("Request Timeout"));

    // 发送数据
    if (data && typeof data === "object") {
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.send(JSON.stringify(data));
    } else {
      xhr.send(data);
    }
  });
}

// ── 验证 ──
// ajax({ url: '/api/users', method: 'GET' })
//   .then(data => console.log('Users:', data))
//   .catch(err => console.error('Error:', err.message));
//
// ajax({
//   url: '/api/users',
//   method: 'POST',
//   data: { name: 'Linus', role: 'admin' },
// }).then(console.log);
```

**readyState 状态流转**：

| readyState | 常量             | 含义                          |
| :--------: | :--------------- | :---------------------------- |
|     0      | UNSENT           | `open()` 尚未调用             |
|     1      | OPENED           | `open()` 已调用               |
|     2      | HEADERS_RECEIVED | `send()` 已调用，头已收到     |
|     3      | LOADING          | 下载中，responseText 部分可用 |
|     4      | DONE             | 完成                          |

> **本质洞察**：`XMLHttpRequest` 的 5 个 `readyState` 本质上是一个**生命周期状态机**。面试中常见的"为什么 readyState 要判断 4"——因为 `onreadystatechange` 会在**每次**状态变化时触发（1→2→3→4），只有到达 4 才意味着响应完整可用。

---

### 3. 实现 getElementsByClassName

不使用原生 `getElementsByClassName`，手写 DOM 树的递归搜索。

```javascript
// ─────────────────────────────────────────────────
//  getElementsByClassName — 递归 DOM 遍历
// ─────────────────────────────────────────────────

function getElementsByClassName(root, className) {
  const result = [];

  function traverse(node) {
    // 检查当前节点是否匹配
    if (node.classList && node.classList.contains(className)) {
      result.push(node);
    }
    // 递归遍历所有子节点
    for (const child of node.children) {
      traverse(child);
    }
  }

  traverse(root);
  return result;
}

// ── 验证 ──
// const items = getElementsByClassName(document.body, 'highlight');
// console.log(items.length);
```

> **本质洞察**：DOM 就是一棵多叉树——`children` 是子节点列表，`parentNode` 是父节点。所有 DOM 查询的底层实现都是树的遍历。`querySelectorAll` 的强大只是对这种遍历+匹配的抽象包装。

---

### 4. 实现 insertAfter

DOM API 只有 `insertBefore`，没有 `insertAfter`——需要手动实现。

```javascript
// ─────────────────────────────────────────────────
//  insertAfter — 在目标节点之后插入
// ─────────────────────────────────────────────────

function insertAfter(newNode, referenceNode) {
  const parent = referenceNode.parentNode;
  if (parent.lastChild === referenceNode) {
    // 目标是最后一个子节点 → 直接 appendChild
    parent.appendChild(newNode);
  } else {
    // 在目标的下一个兄弟节点之前插入 = 在目标之后插入
    parent.insertBefore(newNode, referenceNode.nextSibling);
  }
}

// ── 简化版（其实 insertBefore(new, ref.nextSibling) 就能处理所有情况）──
function insertAfterSimple(newNode, referenceNode) {
  // nextSibling 为 null 时，insertBefore 等效于 appendChild
  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}

// ── 验证 ──
// const newEl = document.createElement('p');
// newEl.textContent = 'Inserted!';
// insertAfterSimple(newEl, document.getElementById('target'));
```

> **本质洞察**：`insertBefore(newNode, null)` 等同于 `appendChild(newNode)` ——这是 DOM 规范中一个优雅的设计。`nextSibling` 为 `null` 时正好触发这个行为，所以简化版只需一行代码就能覆盖所有边界。这就是 Linus 所说的**好品味**——**通过理解 API 的边界行为，消除特殊情况**。

---

### 5. 判断 DOM 元素是否在视口内

```javascript
// ─────────────────────────────────────────────────
//  isInViewport — 方式一：getBoundingClientRect
// ─────────────────────────────────────────────────

function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  const vWidth = window.innerWidth || document.documentElement.clientWidth;
  const vHeight = window.innerHeight || document.documentElement.clientHeight;

  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= vHeight &&
    rect.right <= vWidth
  );
}

// ─────────────────────────────────────────────────
//  方式二：IntersectionObserver（现代高性能方案）
// ─────────────────────────────────────────────────

function observeVisibility(element, callback) {
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        callback(entry.isIntersecting, entry);
      });
    },
    { threshold: 0 }, // 0 = 只要有一个像素进入视口就触发
  );

  observer.observe(element);
  return () => observer.disconnect(); // 返回清理函数
}

// ── 验证 ──
// console.log(isInViewport(document.getElementById('target')));
//
// const cleanup = observeVisibility(document.getElementById('lazy-img'), (visible) => {
//   if (visible) {
//     console.log('图片进入视口，开始加载');
//     cleanup(); // 加载后取消观察
//   }
// });
```

**两种方案对比**：

| 维度     | getBoundingClientRect         | IntersectionObserver     |
| :------- | :---------------------------- | :----------------------- |
| 触发方式 | 同步调用、需要手动绑定 scroll | 异步回调、浏览器自动调度 |
| 性能     | 每次调用触发重排（reflow）    | 不触发重排、更高效       |
| 兼容性   | IE9+                          | IE 不支持                |
| 典型用途 | 一次性判断                    | 持续监控（懒加载/曝光）  |

> **本质洞察**：`getBoundingClientRect()` 的调用会触发**强制重排（Forced Reflow）**——浏览器必须重新计算所有元素的布局位置才能返回准确结果。在 scroll 事件中频繁调用它是性能杀手。`IntersectionObserver` 的出现就是为了解决这个问题——它把判断交给浏览器的合成线程，不阻塞主线程。

---

### 6. 获取页面所有标签种类和数量

```javascript
// ─────────────────────────────────────────────────
//  getTagStats — 统计页面标签分布
// ─────────────────────────────────────────────────

function getTagStats() {
  const tags = document.querySelectorAll("*");
  const stats = new Map();

  tags.forEach((tag) => {
    const name = tag.tagName.toLowerCase();
    stats.set(name, (stats.get(name) || 0) + 1);
  });

  // 按数量降序排列
  return [...stats.entries()]
    .sort((a, b) => b[1] - a[1])
    .reduce((obj, [key, val]) => {
      obj[key] = val;
      return obj;
    }, {});
}

// ── 验证 ──
// console.table(getTagStats());
// 输出类似：
// ┌─────┬────────┐
// │ div │   42   │
// │ span│   28   │
// │ a   │   15   │
// │ p   │   12   │
// └─────┴────────┘
```

> **本质洞察**：`document.querySelectorAll('*')` 返回的是一个**静态 NodeList**（快照），而 `document.getElementsByTagName('*')` 返回的是**活动 HTMLCollection**（会随 DOM 变化自动更新）。在遍历时修改 DOM 的话，用错了集合类型会导致无限循环或跳过元素。

---

## 质量指标

- **性能意识**：事件委托的父容器不宜设置太高（如 `document.body`），应尽量靠近目标元素减少冒泡路径。
- **浏览器兼容**：`closest` 在 IE 中不可用，需用 `while` + `matches` polyfill。
- **内存管理**：`IntersectionObserver` 使用后必须 `disconnect()`，否则会造成内存泄漏。
- **类型安全**：XHR 的 `responseText` 不一定是 JSON，解析时需 try-catch 保护。
