<!--
- [INPUT]: JSON Schema, Form Logic, RBAC Model, Micro-frontend Sandbox (Proxy/with), Shadow DOM
- [OUTPUT]: 高级组件与 SDK 设计方案大纲，涵盖表单引擎、权限系统及微前端架构要求
- [POS]: 编程题/ 复杂场景专题，聚焦高复用性组件与企业级架构设计
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.6 组件与 SDK 设计

组件与 SDK 的设计不仅仅是 UI 的封装，更是对业务逻辑高度抽象与复杂运行环境隔离的工程能力体现。

---

### 3.6.1 表单引擎设计 ⭐⭐⭐⭐

**要求：** 设计一个基于配置驱动（Schema-driven）的高可靠表单引擎。

- **核心挑战：**
  - **Schema 结构设计**：如何定义字段类型、校验规则与布局信息的规范化描述。
  - **字段联动机制**：实现复杂的依赖关系逻辑（如字段 A 的值决定字段 B 的可见性或校验规则）。
  - **校验规则引擎**：支持异步校验、并行校验与自定义校验规则的链式调用。
  - **自定义组件接入**：建立标准化的适配层，支持第三方 UI 库与业务组件的动态注入。
  - **性能优化**：在大表单（100+ 字段）场景下的局部更新与状态管理策略。

#### 1. Schema 驱动的表单引擎核心

表单引擎的本质是 **「Schema → Field Graph → Reactive UI」** 的映射管线。

```javascript
// ─────────────────────────────────────────────────
//  FormEngine — Schema 驱动的表单引擎核心
// ─────────────────────────────────────────────────

class FormEngine {
  constructor(schema, options = {}) {
    this.schema = schema;
    this.store = {}; // 字段值存储
    this.errors = {}; // 校验错误
    this.visibility = {}; // 字段可见性
    this.listeners = new Map();
    this.componentRegistry = new Map(); // 自定义组件注册表

    // 从 schema 中构建依赖图
    this.depGraph = this._buildDependencyGraph(schema.fields);
    this._initDefaults(schema.fields);
  }

  // ── 依赖图构建 ──────────────────────────────────
  _buildDependencyGraph(fields) {
    const graph = {};
    fields.forEach((field) => {
      graph[field.name] = {
        dependsOn: field.dependencies || [],
        affects: [],
      };
    });
    // 反向填充 affects
    Object.keys(graph).forEach((name) => {
      graph[name].dependsOn.forEach((dep) => {
        if (graph[dep]) graph[dep].affects.push(name);
      });
    });
    return graph;
  }

  // ── 字段值变更（核心：级联触发联动） ───────────
  setValue(fieldName, value) {
    const oldValue = this.store[fieldName];
    this.store[fieldName] = value;

    // 1. 触发自身校验
    this._validateField(fieldName);

    // 2. 级联更新所有受影响字段
    const affected = this.depGraph[fieldName]?.affects || [];
    affected.forEach((name) => {
      this._evaluateVisibility(name);
      this._validateField(name);
    });

    // 3. 通知订阅者
    this._notify(fieldName, value, oldValue);
  }

  // ── 联动：可见性评估 ───────────────────────────
  _evaluateVisibility(fieldName) {
    const field = this.schema.fields.find((f) => f.name === fieldName);
    if (!field?.visibleWhen) {
      this.visibility[fieldName] = true;
      return;
    }
    // visibleWhen 是一个表达式函数，接收整个 store
    this.visibility[fieldName] = field.visibleWhen(this.store);
  }

  // ── 注册自定义组件 ─────────────────────────────
  registerComponent(type, component) {
    this.componentRegistry.set(type, component);
  }
}
```

#### 2. 校验规则引擎：链式 + 异步

```javascript
// ─────────────────────────────────────────────────
//  ValidationEngine — 链式异步校验
// ─────────────────────────────────────────────────

class ValidationEngine {
  constructor() {
    this.rules = new Map();
  }

  // 注册自定义规则
  defineRule(name, validatorFn) {
    this.rules.set(name, validatorFn);
  }

  // 执行校验链
  async validate(value, ruleChain, context) {
    const errors = [];

    for (const rule of ruleChain) {
      const validator = this.rules.get(rule.type);
      if (!validator) continue;

      try {
        const result = await validator(value, rule.params, context);
        if (result !== true) {
          errors.push({
            rule: rule.type,
            message: result || rule.message,
          });
          // 是否短路：遇到第一个错误即停止
          if (rule.bail) break;
        }
      } catch (e) {
        errors.push({ rule: rule.type, message: `校验异常: ${e.message}` });
      }
    }
    return errors;
  }
}

// ── 使用示例 ──────────────────────────────────────
const engine = new ValidationEngine();

engine.defineRule("required", (value) => {
  return value !== undefined && value !== "" ? true : "此字段为必填项";
});

engine.defineRule("asyncUnique", async (value, params) => {
  const exists = await fetch(`/api/check?field=${params.field}&value=${value}`);
  const result = await exists.json();
  return !result.exists ? true : "该值已被占用";
});
```

> **本质洞察**：表单引擎的核心是 **「依赖图 + 响应式求值」**。每个字段是图的一个节点，联动关系是边。字段值变更就是图的一次拓扑传播。这和 Excel 的单元格公式引擎、Vue 的响应式系统，本质上是同一个问题 —— **有向无环图 (DAG) 的增量求值**。

---

### 3.6.2 权限控制系统 (Auth SDK) ⭐⭐⭐

**要求：** 设计一套支持细粒度控制的前端权限管理 SDK。

- **实战要点：**
  - **RBAC 模型实现**：基于"角色-权限"的映射逻辑在前端的落地。
  - **声明式控制**：实现权限指令 (v-permission) 与高阶组件 (HOC) 包装。
  - **动态路由管理**：根据权限配置异步生成路由树，并处理越权访问拦截。
  - **状态动态更新**：处理用户切换角色或权限变更时的 UI 实时刷新。

#### 1. RBAC 权限内核

```javascript
// ─────────────────────────────────────────────────
//  PermissionSDK — RBAC 权限管理内核
// ─────────────────────────────────────────────────

class PermissionSDK {
  constructor() {
    this.roles = new Set();
    this.permissions = new Set();
    this.rolePermMap = {}; // 角色 → 权限集合 映射
    this.listeners = [];
  }

  // ── 初始化：从服务端拉取权限配置 ────────────────
  async init(userId) {
    const { roles, permissions, mapping } = await fetch(
      `/api/auth/permissions?uid=${userId}`,
    ).then((r) => r.json());

    this.roles = new Set(roles);
    this.permissions = new Set(permissions);
    this.rolePermMap = mapping;
    this._notify();
  }

  // ── 核心：权限判定 ─────────────────────────────
  has(permission) {
    // 直接权限匹配
    if (this.permissions.has(permission)) return true;
    // 通配符匹配：user:* 可以匹配 user:read, user:write
    for (const perm of this.permissions) {
      if (perm.endsWith(":*")) {
        const prefix = perm.slice(0, -1);
        if (permission.startsWith(prefix)) return true;
      }
    }
    return false;
  }

  // ── 复合条件判定 ───────────────────────────────
  hasAll(...permissions) {
    return permissions.every((p) => this.has(p));
  }

  hasAny(...permissions) {
    return permissions.some((p) => this.has(p));
  }

  // ── 角色切换（实时刷新） ──────────────────────
  async switchRole(newRole) {
    const { permissions } = await fetch(
      `/api/auth/role/${newRole}/permissions`,
    ).then((r) => r.json());

    this.roles = new Set([newRole]);
    this.permissions = new Set(permissions);
    this._notify(); // 触发全局 UI 刷新
  }

  // ── 订阅权限变更 ──────────────────────────────
  onChange(callback) {
    this.listeners.push(callback);
    return () => {
      this.listeners = this.listeners.filter((l) => l !== callback);
    };
  }

  _notify() {
    this.listeners.forEach((fn) => fn(this.permissions));
  }
}
```

#### 2. 动态路由生成

```javascript
// ─────────────────────────────────────────────────
//  DynamicRouteGenerator — 权限驱动的路由树生成
// ─────────────────────────────────────────────────

function generateRoutes(allRoutes, permissionSDK) {
  return allRoutes.reduce((acc, route) => {
    // 无权限限制 → 直接放行
    if (!route.meta?.permission) {
      acc.push(route);
      return acc;
    }

    // 有权限限制 → 判定
    if (permissionSDK.has(route.meta.permission)) {
      const filteredRoute = { ...route };
      // 递归处理子路由
      if (route.children) {
        filteredRoute.children = generateRoutes(route.children, permissionSDK);
      }
      acc.push(filteredRoute);
    }
    return acc;
  }, []);
}

// ── React HOC: 权限包装器 ────────────────────────
function withPermission(Component, requiredPermission) {
  return function PermissionGuard(props) {
    const sdk = usePermissionSDK(); // Context Hook

    if (!sdk.has(requiredPermission)) {
      return null; // 或渲染 <NoAccess /> 提示
    }
    return <Component {...props} />;
  };
}
```

> **本质洞察**：前端权限的本质是 **「过滤器模式」**。路由树、菜单项、按钮 —— 所有 UI 元素都是权限集合的一个投影。RBAC 只是组织这个集合的方式。真正的难点不在判定逻辑，而在 **状态变更时的一致性传播** —— 切换角色后，整棵 UI 树必须即刻响应，这本质上又回到了响应式系统的核心问题。

---

### 3.6.3 微前端容器架构 ⭐⭐⭐⭐⭐

**要求：** 模拟微前端框架核心流程，解决应用隔离与通信问题。

- **技术要求：**
  - **JS 沙箱隔离**：使用 `with` + `Proxy` 或快照 (Snapshot) 技术实现全局变量隔离。
  - **CSS 隔离**：Shadow DOM vs Scoped CSS 方案的实现细节与优劣。
  - **应用间通信**：基于事件总线 (EventBus) 或全局状态共享的解耦通信设计。
  - **路由劫持**：监听原生路由变化并准确调度子应用的挂载与卸载。
  - **公共依赖共享**：处理多应用间库版本的冲突与外部声明 (Externals)。

#### 1. JS 沙箱：Proxy 隔离方案

```javascript
// ─────────────────────────────────────────────────
//  ProxySandbox — 子应用 JS 隔离沙箱
// ─────────────────────────────────────────────────

class ProxySandbox {
  constructor(name) {
    this.name = name;
    this.running = false;
    const rawWindow = window;
    const fakeWindow = {};

    this.proxy = new Proxy(fakeWindow, {
      get(target, key) {
        // 优先从沙箱自身作用域取值
        if (Reflect.has(target, key)) {
          return Reflect.get(target, key);
        }
        // 否则从真实 window 取（共享只读属性）
        const value = rawWindow[key];
        // 绑定 this 防止函数丢失上下文
        return typeof value === "function" ? value.bind(rawWindow) : value;
      },

      set(target, key, value) {
        // 所有写操作都落到沙箱内部，不污染真实 window
        Reflect.set(target, key, value);
        return true;
      },

      has(target, key) {
        return true; // 配合 with 语句，拦截所有变量查找
      },
    });
  }

  activate() {
    this.running = true;
  }

  deactivate() {
    this.running = false;
  }

  // 在沙箱内执行代码
  execScript(code) {
    // with + Proxy：让代码中所有全局变量访问都走 Proxy
    const fn = new Function("window", `with(window) { ${code} }`);
    fn.call(this.proxy, this.proxy);
  }
}
```

#### 2. CSS 隔离：Shadow DOM 方案

```javascript
// ─────────────────────────────────────────────────
//  CSSIsolation — Shadow DOM 样式隔离
// ─────────────────────────────────────────────────

class ShadowDOMContainer {
  constructor(hostElement) {
    this.shadow = hostElement.attachShadow({ mode: "open" });
  }

  mount(htmlContent, cssContent) {
    // 样式严格隔离在 Shadow 内部
    const style = document.createElement("style");
    style.textContent = cssContent;
    this.shadow.appendChild(style);

    const container = document.createElement("div");
    container.innerHTML = htmlContent;
    this.shadow.appendChild(container);

    return container;
  }

  unmount() {
    this.shadow.innerHTML = "";
  }
}

// ── 备选方案：运行时 CSS 前缀改写 ────────────────
function scopeCSS(cssText, appName) {
  // 将 .btn {} 改写为 [data-app="myApp"] .btn {}
  return cssText.replace(
    /([^{}]+)\{/g,
    (match, selector) => `[data-app="${appName}"] ${selector.trim()} {`,
  );
}
```

#### 3. 微前端路由劫持与应用调度

```javascript
// ─────────────────────────────────────────────────
//  MicroRouter — 路由劫持与子应用生命周期调度
// ─────────────────────────────────────────────────

class MicroFrontendRouter {
  constructor() {
    this.apps = []; // 注册的子应用列表
    this.activeApp = null;
    this._hijackHistory();
    this._hijackPopstate();
  }

  registerApp(app) {
    // app: { name, entry, container, activeRule: (url) => bool }
    this.apps.push(app);
  }

  // ── 劫持 pushState / replaceState ──────────────
  _hijackHistory() {
    const originalPush = history.pushState;
    const originalReplace = history.replaceState;
    const self = this;

    history.pushState = function (...args) {
      originalPush.apply(this, args);
      self._reroute();
    };
    history.replaceState = function (...args) {
      originalReplace.apply(this, args);
      self._reroute();
    };
  }

  _hijackPopstate() {
    window.addEventListener("popstate", () => this._reroute());
  }

  // ── 核心：路由匹配 → 卸载旧应用 → 挂载新应用 ──
  async _reroute() {
    const currentUrl = window.location.pathname;
    const targetApp = this.apps.find((app) => app.activeRule(currentUrl));

    if (targetApp === this.activeApp) return;

    // 卸载当前活跃应用
    if (this.activeApp) {
      await this.activeApp.unmount();
      this.activeApp.sandbox.deactivate();
    }

    // 挂载目标应用
    if (targetApp) {
      targetApp.sandbox.activate();
      await targetApp.mount(document.querySelector(targetApp.container));
      this.activeApp = targetApp;
    }
  }
}
```

> **本质洞察**：微前端的两个核心问题是 **「隔离」** 与 **「通信」**，它们天然矛盾。Proxy 沙箱实现的是 **写隔离读共享**—— 这是操作系统进程隔离思想的 JS 映射。Shadow DOM 则是浏览器原生提供的 **样式进程空间**。微前端本质上是在浏览器中模拟操作系统的进程管理：隔离内存、隔离样式、调度生命周期、建立 IPC（进程间通信）。

---

### 3.6.4 低代码引擎 (Low-code Engine) ⭐⭐⭐⭐⭐

**要求：** 设计一个可视化的低代码搭建平台核心引擎。

- **核心模块：**
  - **物料拖拽系统**：从左侧物料库到中间画布的精准坐标映射与放置算法。
  - **组件树协议**：递归生成的页面 JSON 数据结构模型。
  - **实时属性编辑**：基于 Schema 的属性面板动态生成与数据双向绑定。
  - **系统级服务**：完善的撤销重做 (Undo/Redo) 栈管理与预览发布流。

#### 1. 组件树协议（页面 Schema）

```javascript
// ─────────────────────────────────────────────────
//  ComponentTreeProtocol — 页面 Schema 数据结构
// ─────────────────────────────────────────────────

// 页面即一棵组件树的 JSON 描述
const pageSchema = {
  id: "page-root",
  type: "Page",
  props: { title: "首页" },
  children: [
    {
      id: "header-001",
      type: "Header",
      props: { logo: "/logo.png", nav: ["首页", "关于"] },
      children: [],
    },
    {
      id: "form-001",
      type: "Form",
      props: { action: "/api/submit" },
      children: [
        {
          id: "input-001",
          type: "Input",
          props: { label: "用户名" },
          children: [],
        },
        {
          id: "btn-001",
          type: "Button",
          props: { text: "提交" },
          children: [],
        },
      ],
    },
  ],
};
```

#### 2. 拖拽引擎：坐标映射与树操作

```javascript
// ─────────────────────────────────────────────────
//  DragDropEngine — 物料拖拽核心
// ─────────────────────────────────────────────────

class DragDropEngine {
  constructor(schemaTree) {
    this.schema = schemaTree;
  }

  // ── 树操作：在指定节点下插入子节点 ─────────────
  insertNode(parentId, index, newNode) {
    const parent = this._findNodeById(this.schema, parentId);
    if (!parent) return;
    parent.children.splice(index, 0, {
      ...newNode,
      id: this._generateId(),
    });
    return this.schema;
  }

  // ── 树操作：移动节点位置 ──────────────────────
  moveNode(nodeId, newParentId, newIndex) {
    const { node, parent, index } = this._detachNode(this.schema, nodeId);
    if (!node) return;
    const newParent = this._findNodeById(this.schema, newParentId);
    newParent.children.splice(newIndex, 0, node);
    return this.schema;
  }

  // ── 递归查找节点 ──────────────────────────────
  _findNodeById(tree, id) {
    if (tree.id === id) return tree;
    for (const child of tree.children || []) {
      const found = this._findNodeById(child, id);
      if (found) return found;
    }
    return null;
  }

  _generateId() {
    return `node-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  }
}
```

#### 3. 撤销重做栈 (Command Pattern)

```javascript
// ─────────────────────────────────────────────────
//  UndoRedoManager — 命令模式的撤销重做
// ─────────────────────────────────────────────────

class UndoRedoManager {
  constructor(maxHistory = 50) {
    this.undoStack = [];
    this.redoStack = [];
    this.maxHistory = maxHistory;
  }

  // 每次操作都要记录正向和逆向操作
  execute(command) {
    command.execute();
    this.undoStack.push(command);
    this.redoStack = []; // 新操作清空 redo 栈

    // 限制历史长度
    if (this.undoStack.length > this.maxHistory) {
      this.undoStack.shift();
    }
  }

  undo() {
    const command = this.undoStack.pop();
    if (!command) return;
    command.undo();
    this.redoStack.push(command);
  }

  redo() {
    const command = this.redoStack.pop();
    if (!command) return;
    command.execute();
    this.undoStack.push(command);
  }
}

// ── 具体命令实例 ────────────────────────────────
class InsertNodeCommand {
  constructor(engine, parentId, index, nodeData) {
    this.engine = engine;
    this.parentId = parentId;
    this.index = index;
    this.nodeData = nodeData;
    this.insertedId = null;
  }

  execute() {
    const result = this.engine.insertNode(
      this.parentId,
      this.index,
      this.nodeData,
    );
    // 记住插入节点的 id，以便 undo 时精准删除
    this.insertedId = result?.id;
  }

  undo() {
    this.engine.removeNode(this.insertedId);
  }
}
```

> **本质洞察**：低代码引擎的核心回答了一个哲学问题 ——**「UI 是什么？」**。答案是：**UI 是一棵树的投影**。整个低代码引擎就是围绕 **Schema Tree** 的 CRUD（增删改查）。拖拽是 Insert，属性面板是 Update，撤销重做是 Snapshot/Command。所有视觉上的华丽交互，底层都是对一棵 JSON 树的操作 —— 与 Virtual DOM 的本质殊途同归。

---

## 质量指标

- **抽象层级**：SDK 是否做到了逻辑与 UI 的彻底分离。
- **扩展灵活性**：系统是否支持插件化扩展，避免核心代码膨胀。
- **隔离安全性**：微前端场景下子应用是否会对主应用产生不可逆的污染。
