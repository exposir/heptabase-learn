<!--
- [INPUT]: 异步编程规范 (Promise A+)、事件循环、微任务/宏任务机制
- [OUTPUT]: Promise 全家桶手写实现、异步控制流方案、定时器优化技巧
- [POS]: 编程题/ 模块的核心专题，深入探索 JavaScript 非阻塞执行模型
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.2 异步编程专题

异步是 JavaScript 的灵魂。从 Callback Hell 到 Promise，再到 `async/await`，前端异步演进史本质上是**对"流程控制权"的归还与语义化重塑**。手写 Promise 不是为了造轮子，而是为了真正理解"状态机驱动的异步链条"是如何运转的。

---

### 1.2.1 Promise 系列 ⭐⭐⭐

**现象**：异步操作可以在语法层面上像同步代码一样链式表达。
**本质**：通过状态机（Pending → Fulfilled / Rejected）管理回调函数的执行时机与结果传递。

| 题目                   | 难度       | 优先级 | 考察点                                       |
| :--------------------- | :--------- | :----- | :------------------------------------------- |
| **Promise 完整实现**   | ⭐⭐⭐⭐⭐ | 必会   | A+ 规范、状态迁移、then 链式调用、微任务队列 |
| **Promise.resolve**    | ⭐⭐       | 必会   | thenable 处理、值穿透                        |
| **Promise.reject**     | ⭐         | 必会   | 基础静态方法                                 |
| **Promise.all**        | ⭐⭐⭐     | 必会   | 并发执行、结果顺序保证、快速失败             |
| **Promise.race**       | ⭐⭐       | 必会   | 竞态、第一个 settled 的结果决定一切          |
| **Promise.allSettled** | ⭐⭐       | 必会   | 全部 settled、不短路                         |
| **Promise.any**        | ⭐⭐       | 掌握   | AggregateError、第一个成功                   |
| **Promise.finally**    | ⭐⭐       | 掌握   | 清理逻辑、值穿透                             |
| **Promise 并发控制**   | ⭐⭐⭐⭐   | 必会   | 任务队列调度、动态补位                       |
| **Promise 重试机制**   | ⭐⭐⭐     | 必会   | 递归、指数退避                               |
| **Promise 超时控制**   | ⭐⭐⭐     | 必会   | Promise.race 应用                            |
| **可取消的 Promise**   | ⭐⭐⭐     | 掌握   | AbortController                              |

#### 1. Promise 完整实现 (A+ 规范)

实现 A+ 规范的关键在于 `then` 方法必须返回**全新的 Promise**，且 `resolvePromise` 过程必须处理 thenable 对象和循环引用。

```javascript
// ─────────────────────────────────────────────────
//  MyPromise — 符合 A+ 规范的完整实现
// ─────────────────────────────────────────────────

const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class MyPromise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      // 如果 resolve 的值是一个 Promise，递归展开
      if (value instanceof MyPromise) {
        return value.then(resolve, reject);
      }
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach((fn) => fn());
      }
    };

    const reject = (reason) => {
      if (this.status === PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }

  then(onFulfilled, onRejected) {
    // 值穿透：.then(null) 不应中断链条
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : (v) => v;
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (e) => {
            throw e;
          };

    const promise2 = new MyPromise((resolve, reject) => {
      const handleFulfilled = () => {
        queueMicrotask(() => {
          try {
            const x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        });
      };

      const handleRejected = () => {
        queueMicrotask(() => {
          try {
            const x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e);
          }
        });
      };

      if (this.status === FULFILLED) handleFulfilled();
      if (this.status === REJECTED) handleRejected();
      if (this.status === PENDING) {
        this.onResolvedCallbacks.push(handleFulfilled);
        this.onRejectedCallbacks.push(handleRejected);
      }
    });

    return promise2;
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }
}

// ─────────────────────────────────────────────────
//  resolvePromise — A+ 规范 2.3（核心解析逻辑）
// ─────────────────────────────────────────────────

function resolvePromise(promise2, x, resolve, reject) {
  // 2.3.1 循环引用检测
  if (promise2 === x) {
    return reject(new TypeError("Chaining cycle detected for promise"));
  }

  // 2.3.3 处理 thenable 对象（包括其他 Promise 实现）
  if ((x !== null && typeof x === "object") || typeof x === "function") {
    let called = false; // 防止多次调用
    try {
      const then = x.then;
      if (typeof then === "function") {
        then.call(
          x,
          (y) => {
            if (called) return;
            called = true;
            resolvePromise(promise2, y, resolve, reject); // 递归展开
          },
          (r) => {
            if (called) return;
            called = true;
            reject(r);
          },
        );
      } else {
        resolve(x); // 普通对象，直接 resolve
      }
    } catch (e) {
      if (called) return;
      called = true;
      reject(e);
    }
  } else {
    // 2.3.4 原始值，直接 resolve
    resolve(x);
  }
}

// ── 验证 ──
const p = new MyPromise((resolve) => {
  setTimeout(() => resolve("Hello"), 100);
});

p.then((val) => {
  console.log(val); // "Hello"
  return new MyPromise((resolve) => resolve("World"));
}).then((val) => {
  console.log(val); // "World" ← 链式 + 递归展开
});
```

> **本质洞察**：`then` 链条不是把 callback 存起来那么简单，它是在构建一棵**状态分叉树**。`resolvePromise` 中的 `called` 标志位是 A+ 规范最精妙的防御——它处理的是「不可信的第三方 thenable 可能同时调用 resolve 和 reject」的现实。

#### 2. Promise.resolve / Promise.reject

```javascript
// ─────────────────────────────────────────────────
//  静态方法 — resolve / reject
// ─────────────────────────────────────────────────

MyPromise.resolve = function (value) {
  // 如果已经是 MyPromise 实例，直接返回（幂等性）
  if (value instanceof MyPromise) return value;

  return new MyPromise((resolve) => resolve(value));
};

MyPromise.reject = function (reason) {
  return new MyPromise((_, reject) => reject(reason));
};

// ── 验证 ──
MyPromise.resolve(42).then((v) => console.log(v)); // 42
MyPromise.resolve(new MyPromise((r) => setTimeout(() => r("lazy"), 50))).then(
  (v) => console.log(v),
); // "lazy"

MyPromise.reject("boom").catch((e) => console.log(e)); // "boom"
```

> **本质洞察**：`Promise.resolve` 的幂等性（传入 Promise 时直接返回）是语言设计中「最小意外原则」的体现——不要对已确定的事情做多余的包装。

#### 3. Promise.all

所有成功才成功，一个失败就失败。**结果顺序与输入顺序一致**（不是按完成顺序）。

```javascript
// ─────────────────────────────────────────────────
//  Promise.all — 并发执行，全部成功
// ─────────────────────────────────────────────────

MyPromise.all = function (promises) {
  return new MyPromise((resolve, reject) => {
    const results = [];
    let count = 0;
    const len = promises.length;

    if (len === 0) return resolve([]);

    promises.forEach((p, index) => {
      // 用 MyPromise.resolve 包装，兼容非 Promise 值
      MyPromise.resolve(p).then(
        (value) => {
          results[index] = value; // 保序：用 index 而非 push
          count++;
          if (count === len) resolve(results);
        },
        (reason) => reject(reason), // 快速失败
      );
    });
  });
};

// ── 验证 ──
MyPromise.all([
  MyPromise.resolve(1),
  new MyPromise((r) => setTimeout(() => r(2), 100)),
  MyPromise.resolve(3),
]).then((res) => console.log(res)); // [1, 2, 3]

MyPromise.all([MyPromise.resolve(1), MyPromise.reject("err")]).catch((e) =>
  console.log(e),
); // "err"
```

> **本质洞察**：`Promise.all` 的保序秘密在于 `results[index] = value` 而非 `results.push(value)`。index 在闭包中被冻结，即使后发先至，也会放到正确的位置。

#### 4. Promise.race

第一个 settled（无论成功或失败）的 Promise 决定最终结果。

```javascript
// ─────────────────────────────────────────────────
//  Promise.race — 竞态，第一个到达者胜
// ─────────────────────────────────────────────────

MyPromise.race = function (promises) {
  return new MyPromise((resolve, reject) => {
    for (const p of promises) {
      MyPromise.resolve(p).then(resolve, reject);
    }
  });
};

// ── 验证 ──
MyPromise.race([
  new MyPromise((r) => setTimeout(() => r("slow"), 200)),
  new MyPromise((r) => setTimeout(() => r("fast"), 50)),
]).then((res) => console.log(res)); // "fast"
```

> **本质洞察**：`race` 的实现如此简洁是因为 Promise 的状态迁移是**单向且不可逆**的——第一个 `resolve/reject` 调用后，后续的调用全部静默忽略。

#### 5. Promise.allSettled

不短路，所有 Promise 都会执行完毕，结果包含 `status` 和 `value/reason`。

```javascript
// ─────────────────────────────────────────────────
//  Promise.allSettled — 全部完成，无论成败
// ─────────────────────────────────────────────────

MyPromise.allSettled = function (promises) {
  return new MyPromise((resolve) => {
    const results = [];
    let count = 0;
    const len = promises.length;

    if (len === 0) return resolve([]);

    promises.forEach((p, index) => {
      MyPromise.resolve(p).then(
        (value) => {
          results[index] = { status: "fulfilled", value };
          if (++count === len) resolve(results);
        },
        (reason) => {
          results[index] = { status: "rejected", reason };
          if (++count === len) resolve(results);
        },
      );
    });
  });
};

// ── 验证 ──
MyPromise.allSettled([
  MyPromise.resolve("ok"),
  MyPromise.reject("fail"),
  MyPromise.resolve(42),
]).then((res) => console.log(res));
// [{ status: 'fulfilled', value: 'ok' },
//  { status: 'rejected', reason: 'fail' },
//  { status: 'fulfilled', value: 42 }]
```

> **本质洞察**：`allSettled` 和 `all` 的唯一区别是——`allSettled` 永远不会 `reject`。它体现了「宽容策略」：不因一个错误放弃全局，而是收集所有事实后交由上层决策。

#### 6. Promise.any

第一个 fulfilled 的 Promise 决定结果；全部 rejected 才抛出 `AggregateError`。

```javascript
// ─────────────────────────────────────────────────
//  Promise.any — 第一个成功者胜
// ─────────────────────────────────────────────────

MyPromise.any = function (promises) {
  return new MyPromise((resolve, reject) => {
    const errors = [];
    let count = 0;
    const len = promises.length;

    if (len === 0) {
      return reject(new AggregateError([], "All promises were rejected"));
    }

    promises.forEach((p, index) => {
      MyPromise.resolve(p).then(
        (value) => resolve(value), // 第一个成功直接 resolve
        (reason) => {
          errors[index] = reason;
          if (++count === len) {
            reject(new AggregateError(errors, "All promises were rejected"));
          }
        },
      );
    });
  });
};

// ── 验证 ──
MyPromise.any([
  MyPromise.reject("err1"),
  new MyPromise((r) => setTimeout(() => r("winner"), 100)),
  MyPromise.reject("err2"),
]).then((res) => console.log(res)); // "winner"

MyPromise.any([MyPromise.reject("a"), MyPromise.reject("b")]).catch((e) =>
  console.log(e.errors),
); // ['a', 'b']
```

> **本质洞察**：`any` 是 `all` 的镜像对称——`all` 在第一个失败时短路，`any` 在第一个成功时短路。它的诞生动机是「多源冗余」场景：同时请求 CDN 和源站，谁先回来用谁。

#### 7. Promise.finally

无论成功或失败都会执行清理函数，且**值穿透**——不改变链条的结果。

```javascript
// ─────────────────────────────────────────────────
//  Promise.prototype.finally — 清理逻辑
// ─────────────────────────────────────────────────

MyPromise.prototype.finally = function (callback) {
  return this.then(
    // 关键：用 Promise.resolve 包装 callback()，确保如果
    // callback 返回 Promise，等待它完成后再传递原始值
    (value) => MyPromise.resolve(callback()).then(() => value),
    (reason) =>
      MyPromise.resolve(callback()).then(() => {
        throw reason;
      }),
  );
};

// ── 验证 ──
MyPromise.resolve("data")
  .finally(() => console.log("cleanup")) // "cleanup"
  .then((v) => console.log(v)); // "data" ← 值穿透，不被 finally 吞掉

MyPromise.reject("err")
  .finally(() => console.log("cleanup")) // "cleanup"
  .catch((e) => console.log(e)); // "err" ← 错误也穿透
```

> **本质洞察**：`finally` 的穿透行为是最反直觉的细节——`callback()` 即使返回一个新值也不会改变链条结果。它只做「副作用」，不做「变换」。这是对 try-catch-finally 语义在异步世界的完美映射。

#### 8. Promise 并发控制

控制同时执行的异步任务数量——浏览器对同一域名限制 6 个 HTTP 连接，需要前端自行排队。

```javascript
// ─────────────────────────────────────────────────
//  promisePool — 限制并发数的任务池
// ─────────────────────────────────────────────────

function promisePool(tasks, limit) {
  return new Promise((resolve) => {
    let index = 0;
    let activeCount = 0;
    const results = [];
    const len = tasks.length;

    if (len === 0) return resolve([]);

    function next() {
      while (activeCount < limit && index < len) {
        const currentIndex = index++;
        activeCount++;
        tasks[currentIndex]()
          .then((value) => (results[currentIndex] = value))
          .catch((err) => (results[currentIndex] = err))
          .finally(() => {
            activeCount--;
            if (index >= len && activeCount === 0) {
              resolve(results); // 全部完成
            } else {
              next(); // 补位：腾出一个槽，立即填入下一个
            }
          });
      }
    }

    next();
  });
}

// ── 验证 ──
const delay = (ms, val) => () =>
  new Promise((r) => setTimeout(() => r(val), ms));

promisePool(
  [delay(300, "A"), delay(100, "B"), delay(200, "C"), delay(50, "D")],
  2,
).then((res) => console.log(res)); // ['A', 'B', 'C', 'D']（保序）
```

> **本质洞察**：并发控制的核心不在于"如何运行"，而在于"何时补位"。每个任务完成后都尝试从队列中拉取下一个，形成**自驱动的流水线**——这与操作系统的线程池调度是同构的。

#### 9. Promise 重试机制（指数退避）

```javascript
// ─────────────────────────────────────────────────
//  retry — 带指数退避的 Promise 重试
// ─────────────────────────────────────────────────

function retry(fn, retries = 3, delay = 1000, backoff = 2) {
  return new Promise((resolve, reject) => {
    function attempt(n, currentDelay) {
      fn()
        .then(resolve)
        .catch((err) => {
          if (n <= 0) {
            reject(err);
          } else {
            console.log(`重试中... 剩余 ${n} 次，延迟 ${currentDelay}ms`);
            setTimeout(
              () => attempt(n - 1, currentDelay * backoff),
              currentDelay,
            );
          }
        });
    }
    attempt(retries, delay);
  });
}

// ── 验证 ──
let count = 0;
const unstableAPI = () =>
  new Promise((resolve, reject) => {
    count++;
    count < 3 ? reject(`Fail #${count}`) : resolve("Success!");
  });

retry(unstableAPI, 5, 100).then(console.log); // "Success!"（第 3 次成功）
```

> **本质洞察**：指数退避（backoff）不是随意的等待加长，它是对**网络拥塞博弈论**的工程化应用——所有客户端都按指数增长间隔重试，避免同步重试导致的雪崩效应。

#### 10. Promise 超时控制

```javascript
// ─────────────────────────────────────────────────
//  withTimeout — 给任何 Promise 加上超时限制
// ─────────────────────────────────────────────────

function withTimeout(promise, ms) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Timeout after ${ms}ms`)), ms);
  });
  return Promise.race([promise, timeout]);
}

// ── 验证 ──
const slowTask = new Promise((r) => setTimeout(() => r("done"), 5000));
withTimeout(slowTask, 1000).catch((e) => console.log(e.message));
// "Timeout after 1000ms"
```

> **本质洞察**：超时控制就是 `race` 的直接应用——一个正常任务和一个「定时炸弹」赛跑，谁先到达就用谁的结果。

#### 11. 可取消的 Promise

```javascript
// ─────────────────────────────────────────────────
//  makeCancelable — 支持取消的 Promise 包装器
// ─────────────────────────────────────────────────

function makeCancelable(promise) {
  const controller = new AbortController();

  const wrapped = new Promise((resolve, reject) => {
    controller.signal.addEventListener("abort", () => {
      reject(new Error("Promise was cancelled"));
    });
    promise.then(resolve, reject);
  });

  return {
    promise: wrapped,
    cancel: () => controller.abort(),
  };
}

// ── 验证 ──
const { promise: p2, cancel } = makeCancelable(
  new Promise((r) => setTimeout(() => r("data"), 5000)),
);
p2.catch((e) => console.log(e.message)); // "Promise was cancelled"
cancel(); // 立即取消
```

> **本质洞察**：原生 Promise 不可取消是故意的设计——因为 Promise 表示的是「已经发生的事实」。可取消是在事实之上叠加的「观察者退出权」，本质上取消的不是异步操作本身，而是对结果的监听。

**Promise 静态方法对比**：

| 方法         |    短路条件    |     结果类型      | 用途场景                 |
| ------------ | :------------: | :---------------: | :----------------------- |
| `all`        | 第一个 reject  |      `Array`      | 并发请求，全部成功才继续 |
| `race`       | 第一个 settle  |       单值        | 超时控制、多源竞速       |
| `allSettled` |     不短路     | `Array<{status}>` | 批量操作后需要完整报告   |
| `any`        | 第一个 resolve |       单值        | CDN 多源备援             |

---

### 1.2.2 异步控制流 (Async Flow Control)

**现象**：需要按顺序执行一组异步任务，或者把 generator 变成 async/await。
**本质**：利用 `reduce` 串联 Promise 链，或用递归自动执行 generator 的 `next()`。

| 题目                              | 难度     | 优先级 | 考察点                   |
| :-------------------------------- | :------- | :----- | :----------------------- |
| **异步串行执行**                  | ⭐⭐     | 必会   | reduce 串联、async/await |
| **异步并行执行**                  | ⭐⭐     | 必会   | Promise.all              |
| **异步任务调度器 Scheduler**      | ⭐⭐⭐⭐ | 必会   | 队列、并发控制、动态补位 |
| **async/await 错误处理封装**      | ⭐⭐     | 掌握   | Go 风格 [err, data] 元组 |
| **实现 async/await（generator）** | ⭐⭐⭐⭐ | 了解   | generator 自动执行器     |

#### 1. 异步串行执行

```javascript
// ─────────────────────────────────────────────────
//  serial — 按顺序逐个执行异步任务
// ─────────────────────────────────────────────────

function serial(tasks) {
  return tasks.reduce(
    (prev, task) =>
      prev.then((results) => task().then((result) => [...results, result])),
    Promise.resolve([]),
  );
}

// ── 验证 ──
const t = (ms, val) => () =>
  new Promise((r) =>
    setTimeout(() => {
      console.log(val);
      r(val);
    }, ms),
  );

serial([t(100, "A"), t(50, "B"), t(80, "C")]).then(console.log);
// 输出顺序：A → B → C（严格串行，不按耗时）
// 最终结果：['A', 'B', 'C']
```

> **本质洞察**：`reduce` + `Promise.then` 构成了一个**异步版的 for 循环**。每一次 `then` 都是在对前一个任务说："你完成了，轮到下一个。"

#### 2. 异步任务调度器 Scheduler（类实现版）

```javascript
// ─────────────────────────────────────────────────
//  Scheduler — 带并发限制的任务调度器
// ─────────────────────────────────────────────────

class Scheduler {
  constructor(limit) {
    this.limit = limit;
    this.running = 0;
    this.queue = [];
  }

  add(taskCreator) {
    return new Promise((resolve, reject) => {
      this.queue.push({ taskCreator, resolve, reject });
      this._run();
    });
  }

  _run() {
    while (this.running < this.limit && this.queue.length > 0) {
      const { taskCreator, resolve, reject } = this.queue.shift();
      this.running++;
      taskCreator()
        .then(resolve, reject)
        .finally(() => {
          this.running--;
          this._run(); // 任务完成后立即补位
        });
    }
  }
}

// ── 验证 ──
const timeout = (time) => new Promise((resolve) => setTimeout(resolve, time));

const scheduler = new Scheduler(2); // 最多同时运行 2 个

const addTask = (time, order) => {
  scheduler.add(() => timeout(time)).then(() => console.log(order));
};

addTask(1000, "1"); // 1s 后输出
addTask(500, "2"); // 0.5s 后输出
addTask(300, "3"); // 0.8s 后输出（0.5s 时 2 完成，3 补位，再 0.3s）
addTask(400, "4"); // 1.2s 后输出
// 输出顺序: 2 → 3 → 1 → 4
```

> **本质洞察**：`Scheduler` 的核心是两个数字——`running`（当前占用的槽位数）和 `limit`（总槽位数）。每次有任务完成释放槽位时，`_run` 自动尝试拉取队列中的下一个任务。这与操作系统的信号量（Semaphore）是同一个模型。

#### 3. async/await 错误处理封装

```javascript
// ─────────────────────────────────────────────────
//  to — Go 风格的错误处理 [err, data]
// ─────────────────────────────────────────────────

function to(promise) {
  return promise.then((data) => [null, data]).catch((err) => [err, undefined]);
}

// ── 验证 ──
async function fetchData() {
  const [err, data] = await to(fetch("/api/user"));
  if (err) {
    console.error("请求失败:", err);
    return;
  }
  console.log("数据:", data);
}
```

> **本质洞察**：Go 语言用 `val, err := fn()` 强制你处理每一个错误。`to` 函数把这种纪律引入 JavaScript：不是忘记写 `try-catch` 那么简单，而是让错误处理成为**数据流的组成部分**。

#### 4. 实现 async/await（Generator 自动执行器）

```javascript
// ─────────────────────────────────────────────────
//  asyncToGenerator — 让 generator 自动执行
// ─────────────────────────────────────────────────

function asyncToGenerator(generatorFn) {
  return function (...args) {
    const gen = generatorFn.apply(this, args);

    return new Promise((resolve, reject) => {
      function step(key, arg) {
        let result;
        try {
          result = gen[key](arg); // gen.next(arg) 或 gen.throw(arg)
        } catch (e) {
          return reject(e);
        }
        const { value, done } = result;
        if (done) {
          resolve(value);
        } else {
          // 将 yield 的值包装为 Promise，自动递归
          Promise.resolve(value).then(
            (val) => step("next", val),
            (err) => step("throw", err),
          );
        }
      }
      step("next");
    });
  };
}

// ── 验证 ──
const getData = asyncToGenerator(function* () {
  const result1 = yield new Promise((r) => setTimeout(() => r("step1"), 100));
  console.log(result1); // "step1"
  const result2 = yield new Promise((r) => setTimeout(() => r("step2"), 100));
  console.log(result2); // "step2"
  return "done";
});

getData().then(console.log); // "step1" → "step2" → "done"
```

> **本质洞察**：`async/await` 就是 `generator + 自动执行器` 的语法糖。Babel 编译 async 函数后产出的代码几乎就是上面的 `asyncToGenerator`。理解它，就等于理解了 async/await 在引擎层面的真实运作方式。

---

### 1.2.3 定时器相关 (Timers & Optimization)

**现象**：用户在搜索框疯狂输入时，不应每次击键都发请求。
**本质**：**防抖**控制的是事件的触发频率（只处理最后一次），**节流**控制的是事件的执行频率（固定间隔处理一次）。

| 题目                            | 难度   | 优先级 | 考察点                 |
| :------------------------------ | :----- | :----- | :--------------------- |
| **setTimeout 实现 setInterval** | ⭐⭐   | 必会   | 递归调用、可清除       |
| **防抖 debounce（基础版）**     | ⭐⭐   | 必会   | 定时器重置、闭包       |
| **防抖 debounce（完整版）**     | ⭐⭐⭐ | 必会   | 立即执行、取消、返回值 |
| **节流 throttle（时间戳版）**   | ⭐⭐   | 必会   | 时间戳比较             |
| **节流 throttle（定时器版）**   | ⭐⭐   | 必会   | 定时器                 |
| **节流 throttle（完整版）**     | ⭐⭐⭐ | 必会   | 首尾调用、取消         |
| **带暂停/恢复的定时器**         | ⭐⭐   | 了解   | 状态管理               |

#### 1. setTimeout 实现 setInterval

```javascript
// ─────────────────────────────────────────────────
//  mySetInterval — 递归 setTimeout 替代 setInterval
// ─────────────────────────────────────────────────

function mySetInterval(fn, delay) {
  let timerId = null;
  let cancelled = false;

  function loop() {
    if (cancelled) return;
    fn();
    timerId = setTimeout(loop, delay);
  }

  timerId = setTimeout(loop, delay);

  // 返回清除函数
  return () => {
    cancelled = true;
    clearTimeout(timerId);
  };
}

// ── 验证 ──
let n = 0;
const cancel = mySetInterval(() => {
  console.log(++n);
  if (n >= 3) cancel();
}, 100); // 输出: 1, 2, 3（然后停止）
```

> **本质洞察**：`setInterval` 的致命问题是——如果回调执行时间超过间隔，任务会堆积。递归 `setTimeout` 保证**上一次执行完成后**才计算下一次延迟，彻底杜绝堆积。

#### 2. 防抖 debounce（完整版）

```javascript
// ─────────────────────────────────────────────────
//  debounce — 完整版（立即执行 + 取消 + 返回 Promise）
// ─────────────────────────────────────────────────

function debounce(fn, wait, immediate = false) {
  let timer = null;

  function debounced(...args) {
    return new Promise((resolve) => {
      if (timer) clearTimeout(timer);

      if (immediate && !timer) {
        // 立即执行模式：第一次触发时立即执行
        resolve(fn.apply(this, args));
      }

      timer = setTimeout(() => {
        if (!immediate) {
          resolve(fn.apply(this, args));
        }
        timer = null;
      }, wait);
    });
  }

  debounced.cancel = function () {
    clearTimeout(timer);
    timer = null;
  };

  return debounced;
}

// ── 验证 ──
const search = debounce((query) => console.log("搜索:", query), 300);
search("h");
search("he");
search("hel");
search("hello"); // 只输出: "搜索: hello"（300ms 后）
```

> **本质洞察**：`debounce` 像一个「耐心的服务员」——每次你改主意，它都重新开始等待。只有你停下来足够久，它才去厨房下单。

#### 3. 节流 throttle（完整版：首尾调用 + 取消）

```javascript
// ─────────────────────────────────────────────────
//  throttle — 完整版（首调用 + 尾调用 + 取消）
// ─────────────────────────────────────────────────

function throttle(fn, wait, options = {}) {
  let timer = null;
  let lastTime = 0;
  const { leading = true, trailing = true } = options;

  function throttled(...args) {
    const now = Date.now();

    // 首次调用且不需要 leading 时，初始化 lastTime
    if (!lastTime && !leading) lastTime = now;

    const remaining = wait - (now - lastTime);

    if (remaining <= 0 || remaining > wait) {
      // 到达执行时机
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      lastTime = now;
      fn.apply(this, args);
    } else if (!timer && trailing) {
      // 设置尾调用定时器
      timer = setTimeout(() => {
        lastTime = leading ? Date.now() : 0;
        timer = null;
        fn.apply(this, args);
      }, remaining);
    }
  }

  throttled.cancel = function () {
    clearTimeout(timer);
    timer = null;
    lastTime = 0;
  };

  return throttled;
}

// ── 验证 ──
const log = throttle(() => console.log("scroll"), 1000);
// 每秒最多输出一次 "scroll"，无论 scroll 事件触发多频繁
```

> **本质洞察**：`throttle` 像一个「限速器」——不管你踩多猛的油门（事件触发），它都按固定速率放行。`leading: true` 意味着第一下就响应，`trailing: true` 意味着最后一下也不丢。

#### 4. 带暂停/恢复的定时器

```javascript
// ─────────────────────────────────────────────────
//  PausableTimer — 带暂停/恢复能力的定时器
// ─────────────────────────────────────────────────

class PausableTimer {
  constructor(callback, delay) {
    this.callback = callback;
    this.remaining = delay;
    this.timerId = null;
    this.startTime = null;
    this.resume();
  }

  pause() {
    if (this.timerId === null) return;
    clearTimeout(this.timerId);
    this.timerId = null;
    this.remaining -= Date.now() - this.startTime;
  }

  resume() {
    if (this.timerId !== null) return;
    this.startTime = Date.now();
    this.timerId = setTimeout(() => {
      this.timerId = null;
      this.callback();
    }, this.remaining);
  }
}

// ── 验证 ──
const timer = new PausableTimer(() => console.log("Done!"), 3000);
setTimeout(() => timer.pause(), 1000); // 1s 后暂停
setTimeout(() => timer.resume(), 5000); // 5s 后恢复（再等 2s 后输出）
```

> **本质洞察**：暂停定时器的秘密在于记录「已消耗的时间」，用 `remaining = delay - elapsed` 计算剩余延迟。这是一种**增量快照**思维：不是从头开始，而是从上次中断的地方继续。

---

## 质量指标

- **微任务一致性**：MyPromise 使用 `queueMicrotask` 保证 then 回调异步执行。
- **内存安全**：Scheduler 中完成的任务不再持有引用，可被 GC 回收。
- **防抖/节流健壮性**：必须正确处理 `this` 绑定和参数透传。
- **边界处理**：`Promise.all([])` 应返回空数组，`Promise.race([])` 永远 pending。
