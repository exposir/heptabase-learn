<!--
- [INPUT]: 前端多标签页通信、状态管理、冲突处理算法
- [OUTPUT]: 四大状态同步场景的深度技术方案对比与实践指南
- [POS]: 编程题/ 模块的核心专题，解决分布式 UI 状态一致性问题
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

## 2.2 状态与数据同步的核心挑战

在现代 Web 应用中，状态不再是孤立的。它分布在不同的标签页、不同的客户端以及不稳定的网络环境中。同步的本质是**维护单一事实源（SSOT）并处理时间带来的歧义**。

---

### 2.2.1 多标签页状态同步 ⭐⭐⭐

**场景**：用户在 A 标签页登出，B/C 标签页需要立即感知并同步状态（如清空用户信息、重定向）。

#### 技术方案对比

| 方案                   | 优点                         | 缺点                       | 适用场景                     |
| :--------------------- | :--------------------------- | :------------------------- | :--------------------------- |
| **localStorage event** | 兼容性极佳，API 简单         | 仅限同源通信，数据量有限   | 通用的轻量级同步（如登录态） |
| **BroadcastChannel**   | API 现代且简洁，专为广播设计 | 兼容性要求（现代浏览器）   | 复杂的实时跨标签页状态同步   |
| **SharedWorker**       | 真正的"后台中枢"，可共享逻辑 | 复杂度高，调试困难         | 重型协作应用，需统一状态管理 |
| **ServiceWorker**      | 支持离线，生命周期独立       | 学习曲线陡峭，缓存管理复杂 | PWA 或需要强缓存策略的应用   |

#### 方案一：localStorage event — 最朴素的信使

```javascript
// ========== Tab A: 发送方 ==========
function logout() {
  localStorage.setItem(
    "auth_event",
    JSON.stringify({
      type: "LOGOUT",
      timestamp: Date.now(),
    }),
  );
  clearUserSession();
  redirect("/login");
}

// ========== Tab B/C: 接收方 ==========
// storage 事件只在「其他标签页」触发，发起修改的标签页不会收到
window.addEventListener("storage", (e) => {
  if (e.key !== "auth_event") return;

  const event = JSON.parse(e.newValue);
  if (event.type === "LOGOUT") {
    clearUserSession();
    redirect("/login");
  }
});
```

**关键陷阱**：

- `storage` 事件**只在其他同源标签页触发**，修改者自身不会收到
- 存储的是字符串，复杂对象需要序列化/反序列化
- `localStorage` 有 5~10MB 的容量限制，不适合大数据同步
- 写入是**同步阻塞主线程**的，高频写入会卡 UI

#### 方案二：BroadcastChannel — 现代广播电台

```javascript
// ========== 所有标签页共享同一段代码 ==========
const channel = new BroadcastChannel("app_sync");

// 发送消息（所有「其他」监听同名 channel 的标签页都会收到）
function broadcastStateChange(action) {
  channel.postMessage({
    type: action.type,
    payload: action.payload,
    source: sessionStorage.getItem("tabId"), // 标识发送源，防止回声
    timestamp: Date.now(),
  });
}

// 接收消息
channel.onmessage = (event) => {
  const { type, payload, source } = event.data;
  if (source === sessionStorage.getItem("tabId")) return; // 过滤自己发的

  switch (type) {
    case "LOGOUT":
      store.dispatch({ type: "USER/CLEAR" });
      router.push("/login");
      break;
    case "THEME_CHANGE":
      store.dispatch({ type: "UI/SET_THEME", payload });
      break;
    case "CART_UPDATE":
      store.dispatch({ type: "CART/SYNC", payload });
      break;
  }
};

// 页面卸载时关闭
window.addEventListener("beforeunload", () => channel.close());
```

**对比 `localStorage`**：

- 不需要序列化，可以直接传**结构化克隆算法**支持的任意对象
- 不落盘，纯内存广播，**性能更高**
- 语义明确：就是为了跨标签页通信而设计

#### 方案三：SharedWorker — 中心化状态枢纽

```javascript
// ========== shared-worker.js ==========
const ports = new Set();

onconnect = (e) => {
  const port = e.ports[0];
  ports.add(port);

  port.onmessage = (event) => {
    const { type, payload } = event.data;

    // 中心化逻辑处理：Worker 是唯一的真相源
    switch (type) {
      case "STATE_UPDATE":
        // 广播给所有连接的标签页（包括发送者）
        for (const p of ports) {
          p.postMessage({ type: "STATE_SYNC", payload });
        }
        break;
      case "DISCONNECT":
        ports.delete(port);
        break;
    }
  };

  // 新标签页连接时，推送当前完整状态
  port.postMessage({ type: "INIT_STATE", payload: currentState });
};

// ========== 标签页代码 ==========
const worker = new SharedWorker("/shared-worker.js");
worker.port.start();

worker.port.onmessage = (event) => {
  const { type, payload } = event.data;
  if (type === "STATE_SYNC") {
    store.replaceState(payload); // 直接替换本地状态
  }
};
```

**本质洞察**：`SharedWorker` 是唯一真正意义上的 **SSOT（单一事实源）** 方案。其他方案是"广播通知，各自处理"，而 `SharedWorker` 是"所有状态集中管理，标签页只是视图层"。

#### 方案四：ServiceWorker — 离线优先的同步者

```javascript
// ========== service-worker.js ==========
self.addEventListener("message", (event) => {
  // 获取所有受控的客户端（标签页）
  self.clients.matchAll().then((clients) => {
    clients.forEach((client) => {
      // 排除发送者
      if (client.id !== event.source.id) {
        client.postMessage(event.data);
      }
    });
  });
});

// ========== 标签页代码 ==========
navigator.serviceWorker.controller?.postMessage({
  type: "AUTH_CHANGE",
  payload: { loggedIn: false },
});

navigator.serviceWorker.addEventListener("message", (event) => {
  handleSyncMessage(event.data);
});
```

#### 哲学选择

| 你需要什么                   | 选什么               |
| :--------------------------- | :------------------- |
| 简单的事件通知（登录态同步） | `BroadcastChannel`   |
| 兼容 IE/旧浏览器             | `localStorage event` |
| 中心化状态管理               | `SharedWorker`       |
| 离线能力 + 后台同步          | `ServiceWorker`      |

---

### 2.2.2 乐观更新与回滚（Optimistic Update）⭐⭐⭐

**场景**：点赞、收藏等高频操作。追求"零延迟"体验，即用户操作后 UI 立即反馈，异步接口在后台执行。

#### 核心实现要点

1. **保存快照 (Snapshot)**：在更新本地状态前，必须深拷贝当前状态。
2. **并发控制**：多个乐观更新重叠时，需要版本号或序列机制确保回滚不会覆盖更新的操作。
3. **UI 降级**：当接口确认失败时，需提供清晰的失败提示，并利用快照执行数据回滚。
4. **状态库集成**：在 React Query 或 SWR 中，利用 `onMutate` 保存快照，`onError` 执行回滚。

#### 朴素版本 — 手动快照

```typescript
// ========== 朴素但完整的乐观更新 ==========
interface OptimisticAction<T> {
  snapshot: T; // 操作前的状态快照
  rollback: () => void; // 回滚函数
  version: number; // 版本号，处理并发
}

class OptimisticStore<T> {
  private state: T;
  private version = 0;
  private pendingActions: Map<string, OptimisticAction<T>> = new Map();

  async execute(
    actionId: string,
    optimisticUpdate: (state: T) => T,
    serverRequest: () => Promise<T>,
  ): Promise<void> {
    const snapshot = structuredClone(this.state); // 深拷贝，不是 JSON.parse
    const currentVersion = ++this.version;

    // Step 1: 乐观更新 → UI 立即响应
    this.state = optimisticUpdate(this.state);
    this.notify();

    // 记录待处理的操作
    this.pendingActions.set(actionId, {
      snapshot,
      rollback: () => {
        // 只有当没有更新的操作覆盖时才回滚
        if (this.version === currentVersion) {
          this.state = snapshot;
          this.notify();
        }
      },
      version: currentVersion,
    });

    try {
      // Step 2: 异步请求服务器
      const serverState = await serverRequest();

      // Step 3: 服务器确认 → 用服务器返回的真实数据替换
      this.state = serverState;
      this.notify();
    } catch (error) {
      // Step 4: 失败 → 回滚到快照
      const action = this.pendingActions.get(actionId);
      action?.rollback();
      showToast("操作失败，已恢复");
    } finally {
      this.pendingActions.delete(actionId);
    }
  }

  private notify() {
    /* 触发 UI 重渲染 */
  }
}
```

#### React Query 集成版 — 工业级实践

```typescript
// ========== React Query: 点赞的乐观更新 ==========
import { useMutation, useQueryClient } from "@tanstack/react-query";

function useLikeMutation(postId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: () => api.likePost(postId),

    // 乐观更新的核心钩子
    onMutate: async () => {
      // 1. 取消正在进行的查询，防止旧数据覆盖乐观数据
      await queryClient.cancelQueries({ queryKey: ["post", postId] });

      // 2. 保存快照
      const snapshot = queryClient.getQueryData(["post", postId]);

      // 3. 乐观更新缓存
      queryClient.setQueryData(["post", postId], (old: Post) => ({
        ...old,
        likes: old.likes + 1,
        isLiked: true,
      }));

      // 4. 返回快照，供 onError 使用
      return { snapshot };
    },

    onError: (_err, _vars, context) => {
      // 回滚到快照
      if (context?.snapshot) {
        queryClient.setQueryData(["post", postId], context.snapshot);
      }
      toast.error("点赞失败，请重试");
    },

    onSettled: () => {
      // 无论成功失败，最终都重新获取最新数据（保证一致性）
      queryClient.invalidateQueries({ queryKey: ["post", postId] });
    },
  });
}
```

#### 并发控制的关键问题

```
时间线：
  t1: 用户点赞 → state: likes=11 (乐观) → 请求发出
  t2: 用户取消赞 → state: likes=10 (乐观) → 请求发出
  t3: t1 的请求失败 → 回滚到 likes=10? 还是 11?

危险：如果 t1 回滚到它的快照 (likes=10)，会覆盖 t2 的正确操作。
```

**解决方案**：版本号。每次操作递增版本号，回滚时检查当前版本是否已被更新的操作覆盖：

```typescript
// 核心判断：只有当前版本号等于操作时的版本号时，才执行回滚
if (this.version === actionVersion) {
  this.state = snapshot;
}
// 否则，说明有更新的操作已经修改了状态，不应回滚
```

---

### 2.2.3 实时协同编辑冲突处理 ⭐⭐⭐⭐⭐

**场景**：多人同时编辑同一个文档（如 Google Docs）。核心在于**处理并发冲突并保证最终一致性**。

这是分布式系统中最深刻的问题。本质上是 **CAP 定理在前端的映射**。

#### 核心算法架构

| 算法                                           | 本质说明                           | 复杂度   | 优缺点                                                              |
| :--------------------------------------------- | :--------------------------------- | :------- | :------------------------------------------------------------------ |
| **Last-Write-Wins (LWW)**                      | 基于时间戳的最后覆盖               | O(1)     | **简单但粗暴**。会导致数据丢失，仅适用于对一致性要求不高的场景。    |
| **Operational Transformation (OT)**            | 对操作进行数学转换（如插入变移动） | O(N)     | **经典但依赖中心化**。需要高计算能力的服务器来协调转换逻辑。        |
| **Conflict-free Replicated Data Types (CRDT)** | 这种数据类型天然支持去中心化合并   | O(log N) | **优雅但复杂**。支持 P2P 同步，不依赖中心服务器，是现代协同的首选。 |

#### LWW（Last-Write-Wins）— 暴力美学

```typescript
// ========== 最简单的冲突解决：谁晚谁赢 ==========
interface Timestamped<T> {
  value: T;
  timestamp: number; // 用 Lamport 时钟或 HLC，不要用 Date.now()
  clientId: string; // 相同时间戳时的决胜器
}

function merge<T>(
  local: Timestamped<T>,
  remote: Timestamped<T>,
): Timestamped<T> {
  if (local.timestamp > remote.timestamp) return local;
  if (remote.timestamp > local.timestamp) return remote;
  // 时间戳相同时，用 clientId 字典序兜底，保证确定性
  return local.clientId > remote.clientId ? local : remote;
}
```

**致命缺陷**：用户 A 写了 1000 字，用户 B 改了标题 → 如果 B 更晚，A 的 1000 字全丢。**数据丢失是不可接受的**。

#### OT（Operational Transformation）— Google Docs 的经典方案

**核心思想**：不同步"状态"，同步"操作"（Operation）。通过数学变换让并发操作在任何执行顺序下都产生相同结果。

```typescript
// ========== OT 的核心：操作变换函数 ==========
type Operation =
  | { type: "insert"; pos: number; char: string }
  | { type: "delete"; pos: number };

/**
 * transform(op1, op2) → [op1', op2']
 * 保证：apply(apply(doc, op1), op2') === apply(apply(doc, op2), op1')
 * 这就是 OT 的数学不变量
 */
function transform(op1: Operation, op2: Operation): [Operation, Operation] {
  // 两个插入操作的变换
  if (op1.type === "insert" && op2.type === "insert") {
    if (op1.pos < op2.pos) {
      // op1 在前面插入，op2 需要右移
      return [op1, { ...op2, pos: op2.pos + 1 }];
    } else if (op1.pos > op2.pos) {
      // op2 在前面插入，op1 需要右移
      return [{ ...op1, pos: op1.pos + 1 }, op2];
    } else {
      // 相同位置：用 clientId 打破对称性
      return [op1, { ...op2, pos: op2.pos + 1 }]; // 约定 op1 优先
    }
  }

  // 插入 vs 删除
  if (op1.type === "insert" && op2.type === "delete") {
    if (op1.pos <= op2.pos) {
      return [op1, { ...op2, pos: op2.pos + 1 }];
    } else {
      return [{ ...op1, pos: op1.pos - 1 }, op2];
    }
  }

  // 删除 vs 插入（对称）
  if (op1.type === "delete" && op2.type === "insert") {
    const [op2t, op1t] = transform(op2, op1);
    return [op1t, op2t];
  }

  // 两个删除
  if (op1.type === "delete" && op2.type === "delete") {
    if (op1.pos < op2.pos) {
      return [op1, { ...op2, pos: op2.pos - 1 }];
    } else if (op1.pos > op2.pos) {
      return [{ ...op1, pos: op1.pos - 1 }, op2];
    } else {
      // 删除同一个字符 → 其中一个变成空操作
      return [{ type: "noop" } as any, { type: "noop" } as any];
    }
  }

  return [op1, op2];
}
```

**架构特点**：

- **中心化**：需要一台服务器作为仲裁者，维护操作的全局序
- **复杂度爆炸**：N 种操作类型需要 N² 个变换函数
- **正确性验证困难**：论文中已被证明很难实现完全正确的 OT

#### CRDT（Conflict-free Replicated Data Types）— 现代协同的终极答案

**核心哲学**：不是"解决冲突"，而是**设计出一种从数学上不可能产生冲突的数据结构**。

```typescript
// ========== CRDT 文本编辑：基于 RGA 的简化实现 ==========

interface CRDTChar {
  id: { clientId: string; seq: number }; // 全局唯一 ID
  value: string; // 字符内容
  parent: { clientId: string; seq: number } | null; // 插在谁后面
  deleted: boolean; // 墓碑删除（标记删除，不物理移除）
}

class CRDTDocument {
  private chars: CRDTChar[] = [];
  private clientId: string;
  private seq = 0;

  constructor(clientId: string) {
    this.clientId = clientId;
  }

  // 插入一个字符
  insert(index: number, value: string): CRDTChar {
    const id = { clientId: this.clientId, seq: ++this.seq };
    const parent = index > 0 ? this.visibleChars()[index - 1].id : null;

    const char: CRDTChar = { id, value, parent, deleted: false };
    this.integrateChar(char);
    return char; // 广播给其他节点
  }

  // 删除：只标记，不移除（墓碑机制，保证幂等）
  delete(index: number): CRDTChar {
    const char = this.visibleChars()[index];
    char.deleted = true;
    return char; // 广播给其他节点
  }

  // 集成远端操作 — 这是 CRDT 的魔法
  integrateChar(newChar: CRDTChar): void {
    // 找到 parent 的位置
    let pos = this.chars.findIndex(
      (c) =>
        c.id.clientId === newChar.parent?.clientId &&
        c.id.seq === newChar.parent?.seq,
    );
    pos = pos === -1 ? 0 : pos + 1;

    // 在 parent 之后，用字典序排列同级字符（保证确定性）
    while (pos < this.chars.length) {
      const existing = this.chars[pos];
      // 如果 existing 的 parent 不同，说明已经过了同级区域
      if (
        existing.parent?.clientId !== newChar.parent?.clientId ||
        existing.parent?.seq !== newChar.parent?.seq
      )
        break;
      // 同级比较：clientId 大的排前面（任意确定性规则即可）
      if (existing.id.clientId < newChar.id.clientId) break;
      pos++;
    }

    this.chars.splice(pos, 0, newChar);
  }

  // 获取可见文本
  getText(): string {
    return this.visibleChars()
      .map((c) => c.value)
      .join("");
  }

  private visibleChars(): CRDTChar[] {
    return this.chars.filter((c) => !c.deleted);
  }
}
```

#### 三大算法的哲学对比

```
LWW:  "时间决定一切" → 简单粗暴，适合单值覆盖（如更新用户头像）
OT:   "操作可以被数学变换" → 优雅但中心化，Google 选择它因为有强大的服务器
CRDT: "数据结构本身消除冲突" → 去中心化的终极优雅，代价是内存和存储开销
```

| 维度     | OT                     | CRDT                   |
| :------- | :--------------------- | :--------------------- |
| 架构     | 必须中心化服务器       | 完全去中心化，支持 P2P |
| 离线支持 | 差，需要服务器仲裁     | 天然支持离线编辑后合并 |
| 正确性   | 极难证明（工程陷阱多） | 有严格数学证明         |
| 存储开销 | 只存当前文档           | 需要保留墓碑和唯一 ID  |
| 工业实现 | Google Docs, Etherpad  | Yjs, Automerge, Figma  |

---

### 2.2.4 表单数据持久化与恢复 ⭐⭐

**场景**：长表单填写、草稿箱功能。防止因意外刷新或崩溃导致的劳动成果丢失。

#### 系统设计逻辑

- **频率控制**：通过防抖（Debounce）技术在用户停止输入后自动保存至 `indexedDB`。
- **状态恢复**：进入页面时检测未提交草稿，主动提示用户"是否恢复上次编辑内容"。
- **生命周期管理**：
  - **过期清理**：设置 TTL（生存时间），防止过期无效数据占用空间。
  - **多份草稿**：基于标识符（如 ID）区分不同实体的草稿，避免覆盖。

#### 完整实现：基于 IndexedDB 的草稿系统

```typescript
// ========== 基于 IndexedDB 的表单草稿系统 ==========

class DraftManager {
  private dbName = "app_drafts";
  private storeName = "drafts";
  private db: IDBDatabase | null = null;
  private saveTimers: Map<string, number> = new Map();
  private TTL = 7 * 24 * 60 * 60 * 1000; // 7 天过期

  async init(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onupgradeneeded = (e) => {
        const db = (e.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: "id" });
          store.createIndex("expireAt", "expireAt"); // 用于过期清理
        }
      };
      request.onsuccess = (e) => {
        this.db = (e.target as IDBOpenDBRequest).result;
        this.cleanup(); // 启动时清理过期草稿
        resolve();
      };
      request.onerror = () => reject(request.error);
    });
  }

  // 防抖保存：用户停止输入 800ms 后自动保存
  saveDraft(entityId: string, formData: Record<string, any>): void {
    const existingTimer = this.saveTimers.get(entityId);
    if (existingTimer) clearTimeout(existingTimer);

    const timer = window.setTimeout(() => {
      this.writeToDB({
        id: `draft_${entityId}`,
        entityId,
        data: formData,
        savedAt: Date.now(),
        expireAt: Date.now() + this.TTL,
      });
      this.saveTimers.delete(entityId);
    }, 800);

    this.saveTimers.set(entityId, timer);
  }

  // 检查是否有未提交的草稿
  async getDraft(entityId: string): Promise<Record<string, any> | null> {
    if (!this.db) return null;
    return new Promise((resolve) => {
      const tx = this.db!.transaction(this.storeName, "readonly");
      const store = tx.objectStore(this.storeName);
      const request = store.get(`draft_${entityId}`);
      request.onsuccess = () => {
        const draft = request.result;
        if (!draft || draft.expireAt < Date.now()) {
          resolve(null);
        } else {
          resolve(draft.data);
        }
      };
      request.onerror = () => resolve(null);
    });
  }

  // 提交成功后删除草稿
  async removeDraft(entityId: string): Promise<void> {
    if (!this.db) return;
    const tx = this.db.transaction(this.storeName, "readwrite");
    tx.objectStore(this.storeName).delete(`draft_${entityId}`);
  }

  // 清理过期草稿
  private async cleanup(): Promise<void> {
    if (!this.db) return;
    const tx = this.db.transaction(this.storeName, "readwrite");
    const store = tx.objectStore(this.storeName);
    const index = store.index("expireAt");
    const range = IDBKeyRange.upperBound(Date.now());

    index.openCursor(range).onsuccess = (e) => {
      const cursor = (e.target as IDBRequest<IDBCursorWithValue>).result;
      if (cursor) {
        cursor.delete();
        cursor.continue();
      }
    };
  }

  private async writeToDB(data: any): Promise<void> {
    if (!this.db) return;
    const tx = this.db.transaction(this.storeName, "readwrite");
    tx.objectStore(this.storeName).put(data);
  }
}
```

#### React 集成：useDraft Hook

```typescript
// ========== useDraft: 表单草稿的声明式 API ==========
function useDraft<T extends Record<string, any>>(
  entityId: string,
  defaultValues: T
) {
  const [formData, setFormData] = useState<T>(defaultValues);
  const [hasDraft, setHasDraft] = useState(false);
  const draftManager = useRef(new DraftManager());

  // 初始化：检查是否存在草稿
  useEffect(() => {
    draftManager.current.init().then(async () => {
      const draft = await draftManager.current.getDraft(entityId);
      if (draft) {
        setHasDraft(true);
        // 不自动恢复，而是提示用户选择
      }
    });
  }, [entityId]);

  // 自动保存
  useEffect(() => {
    draftManager.current.saveDraft(entityId, formData);
  }, [entityId, formData]);

  // 恢复草稿
  const restoreDraft = useCallback(async () => {
    const draft = await draftManager.current.getDraft(entityId);
    if (draft) {
      setFormData(draft as T);
      setHasDraft(false);
    }
  }, [entityId]);

  // 丢弃草稿
  const discardDraft = useCallback(async () => {
    await draftManager.current.removeDraft(entityId);
    setHasDraft(false);
  }, [entityId]);

  // 提交成功后清除
  const clearDraft = useCallback(async () => {
    await draftManager.current.removeDraft(entityId);
  }, [entityId]);

  return { formData, setFormData, hasDraft, restoreDraft, discardDraft, clearDraft };
}

// ========== 使用示例 ==========
function EditArticle({ articleId }: { articleId: string }) {
  const { formData, setFormData, hasDraft, restoreDraft, discardDraft, clearDraft } =
    useDraft(articleId, { title: '', content: '' });

  return (
    <div>
      {hasDraft && (
        <div className="draft-banner">
          <p>检测到未提交的草稿，是否恢复？</p>
          <button onClick={restoreDraft}>恢复</button>
          <button onClick={discardDraft}>丢弃</button>
        </div>
      )}
      <input
        value={formData.title}
        onChange={(e) => setFormData(prev => ({ ...prev, title: e.target.value }))}
      />
      <textarea
        value={formData.content}
        onChange={(e) => setFormData(prev => ({ ...prev, content: e.target.value }))}
      />
      <button onClick={async () => {
        await api.saveArticle(formData);
        await clearDraft();
      }}>
        提交
      </button>
    </div>
  );
}
```

---

## 改进建议

在实现这些同步逻辑时，应优先考虑 **可观察性**。每一个同步动作都应有明确的日志记录，以便在分布式环境下定位数据漂移的根源。

```typescript
// ========== 同步事件的结构化日志 ==========
interface SyncLog {
  action: string; // 'OPTIMISTIC_UPDATE' | 'ROLLBACK' | 'BROADCAST' | 'MERGE'
  source: string; // 'tab-a3f2' | 'worker' | 'server'
  target: string; // 'local_state' | 'indexeddb' | 'broadcast_channel'
  timestamp: number;
  version: number; // 状态版本号
  payload?: unknown; // 审计数据（注意脱敏）
  duration?: number; // 操作耗时
  success: boolean;
}

// 每一次同步操作都记录，形成可追溯的事件流
// 当线上出现"数据漂移"时，通过回放事件流定位是哪个环节的歧义导致了不一致
```

**哲学总结**：

> 同步的本质不是"让所有人看到一样的东西"。同步的本质是**在不确定的时间维度中，建立确定性的因果秩序**。
>
> - `localStorage` 说：我把消息放在桌上，谁经过谁看到
> - `BroadcastChannel` 说：我大声喊，所有人同时听见
> - `SharedWorker` 说：所有人把状态交给我，我是唯一的真相
> - `CRDT` 说：我从数学上消除了冲突的可能性
>
> 从"通知式同步"到"中心化同步"再到"数学化同步"，这是对不确定性的逐级征服。
