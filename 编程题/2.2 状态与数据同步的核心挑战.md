<!--
- [INPUT]: 前端多标签页通信、状态管理、冲突处理算法
- [OUTPUT]: 四大状态同步场景的深度技术方案对比与实践指南
- [POS]: 编程题/ 模块的核心专题，解决分布式 UI 状态一致性问题
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

## 2.2 状态与数据同步的核心挑战

在现代 Web 应用中，状态不再是孤立的。它分布在不同的标签页、不同的客户端以及不稳定的网络环境中。同步的本质是**维护单一事实源（SSOT）并处理时间带来的歧义**。

---

### 2.2.1 多标签页状态同步 ⭐⭐⭐

**场景**：用户在 A 标签页登出，B/C 标签页需要立即感知并同步状态（如清空用户信息、重定向）。

#### 技术方案对比

| 方案                   | 优点                         | 缺点                       | 适用场景                     |
| :--------------------- | :--------------------------- | :------------------------- | :--------------------------- |
| **localStorage event** | 兼容性极佳，API 简单         | 仅限同源通信，数据量有限   | 通用的轻量级同步（如登录态） |
| **BroadcastChannel**   | API 现代且简洁，专为广播设计 | 兼容性要求（现代浏览器）   | 复杂的实时跨标签页状态同步   |
| **SharedWorker**       | 真正的“后台中枢”，可共享逻辑 | 复杂度高，调试困难         | 重型协作应用，需统一状态管理 |
| **ServiceWorker**      | 支持离线，生命周期独立       | 学习曲线陡峭，缓存管理复杂 | PWA 或需要强缓存策略的应用   |

---

### 2.2.2 乐观更新与回滚（Optimistic Update）⭐⭐⭐

**场景**：点赞、收藏等高频操作。追求“零延迟”体验，即用户操作后 UI 立即反馈，异步接口在后台执行。

#### 核心实现要点

1.  **保存快照 (Snapshot)**：在更新本地状态前，必须深拷贝当前状态。
2.  **并发控制**：多个乐观更新重叠时，需要版本号或序列机制确保回滚不会覆盖更新的操作。
3.  **UI 降级**：当接口确认失败时，需提供清晰的失败提示，并利用快照执行数据回滚。
4.  **状态库集成**：在 React Query 或 SWR 中，利用 `onMutate` 保存快照，`onError` 执行回滚。

---

### 2.2.3 实时协同编辑冲突处理 ⭐⭐⭐⭐⭐

**场景**：多人同时编辑同一个文档（如 Google Docs）。核心在于**处理并发冲突并保证最终一致性**。

#### 核心算法架构

| 算法                                           | 本质说明                           | 复杂度   | 优缺点                                                              |
| :--------------------------------------------- | :--------------------------------- | :------- | :------------------------------------------------------------------ |
| **Last-Write-Wins (LWW)**                      | 基于时间戳的最后覆盖               | O(1)     | **简单但粗暴**。会导致数据丢失，仅适用于对一致性要求不高的场景。    |
| **Operational Transformation (OT)**            | 对操作进行数学转换（如插入变移动） | O(N)     | **经典但依赖中心化**。需要高计算能力的服务器来协调转换逻辑。        |
| **Conflict-free Replicated Data Types (CRDT)** | 这种数据类型天然支持去中心化合并   | O(log N) | **优雅但复杂**。支持 P2P 同步，不依赖中心服务器，是现代协同的首选。 |

---

### 2.2.4 表单数据持久化与恢复 ⭐⭐

场景：长表单填写、草稿箱功能。防止因意外刷新或崩溃导致的劳动成果丢失。

#### 系统设计逻辑

- **频率控制**：通过防抖（Debounce）技术在用户停止输入后自动保存至 `indexedDB`。
- **状态恢复**：进入页面时检测未提交草稿，主动提示用户“是否恢复上次编辑内容”。
- **生命周期管理**：
  - **过期清理**：设置 TTL（生存时间），防止过期无效数据占用空间。
  - **多份草稿**：基于标识符（如 ID）区分不同实体的草稿，避免覆盖。

---

## 改进建议

在实现这些同步逻辑时，应优先考虑 **可观察性**。每一个同步动作都应有明确的日志记录，以便在分布式环境下定位数据漂移的根源。
