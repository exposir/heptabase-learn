<!--
- [INPUT]: 浏览器事件模型 (Mouse/Touch Events), requestAnimationFrame, 碰撞检测原理
- [OUTPUT]: 高级交互场景的编程题目大纲与实现要求
- [POS]: 编程题/ 复杂场景专题，聚焦高交互细节与性能优化
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.1 复杂交互与动画

在前端进阶中，交互与动画的实现能力是衡量一个开发者对浏览器底层机制（如 Event Loop, Rendering Pipeline）掌握程度的重要标准。

---

### 3.1.1 手势系统设计 ⭐⭐⭐⭐

**要求：** 实现一个基础的手势识别系统，能够识别并区分不同的用户意图。

- **核心挑战：**
  - 手势识别逻辑（如何区分 Tap, Long Press, Pan）
  - 多指手势处理（Pinch 缩放、Rotate 旋转的坐标算法）
  - 手势冲突解决机制（如嵌套滚动时的手势捕获）
  - 惯性滚动 (Inertial Scrolling) 的数学模拟
  - 统一的事件抽象层（Pointer Events 适配）

#### 1. 手势状态机——区分 Tap, Long Press, Pan

手势识别的本质是**状态机**：根据时间阈值和位移阈值，在有限状态间转换。

```javascript
// ─────────────────────────────────────────────────
//  GestureRecognizer — 基于状态机的手势识别
// ─────────────────────────────────────────────────

class GestureRecognizer {
  constructor(element, options = {}) {
    this.el = element;
    this.config = {
      tapMaxDuration: 300, // Tap 最大持续时间 (ms)
      longPressDelay: 500, // Long Press 触发阈值
      panThreshold: 10, // Pan 识别的最小位移 (px)
      ...options,
    };

    // ── 状态机：IDLE → PENDING → TAP | LONG_PRESS | PAN ──
    this.state = "IDLE";
    this.startPos = null;
    this.startTime = 0;
    this.longPressTimer = null;
    this.listeners = {};

    this._bindEvents();
  }

  on(event, callback) {
    (this.listeners[event] ||= []).push(callback);
    return this; // 链式调用
  }

  _emit(event, data) {
    (this.listeners[event] || []).forEach((fn) => fn(data));
  }

  _bindEvents() {
    // Pointer Events: 统一 Mouse + Touch + Pen
    this.el.addEventListener("pointerdown", this._onStart.bind(this));
    this.el.addEventListener("pointermove", this._onMove.bind(this));
    this.el.addEventListener("pointerup", this._onEnd.bind(this));
    this.el.addEventListener("pointercancel", this._onEnd.bind(this));
  }

  _onStart(e) {
    this.state = "PENDING";
    this.startPos = { x: e.clientX, y: e.clientY };
    this.startTime = Date.now();

    // 启动 Long Press 计时器
    this.longPressTimer = setTimeout(() => {
      if (this.state === "PENDING") {
        this.state = "LONG_PRESS";
        this._emit("longpress", { x: e.clientX, y: e.clientY });
      }
    }, this.config.longPressDelay);
  }

  _onMove(e) {
    if (this.state === "IDLE") return;

    const dx = e.clientX - this.startPos.x;
    const dy = e.clientY - this.startPos.y;
    const distance = Math.hypot(dx, dy);

    // 位移超过阈值 → 转入 PAN 状态
    if (distance > this.config.panThreshold && this.state !== "PAN") {
      this.state = "PAN";
      clearTimeout(this.longPressTimer); // 取消 Long Press
      this._emit("panstart", { x: e.clientX, y: e.clientY });
    }

    if (this.state === "PAN") {
      this._emit("panmove", {
        x: e.clientX,
        y: e.clientY,
        deltaX: dx,
        deltaY: dy,
      });
    }
  }

  _onEnd(e) {
    clearTimeout(this.longPressTimer);

    if (this.state === "PENDING") {
      const duration = Date.now() - this.startTime;
      if (duration < this.config.tapMaxDuration) {
        this._emit("tap", { x: e.clientX, y: e.clientY });
      }
    } else if (this.state === "PAN") {
      this._emit("panend", { x: e.clientX, y: e.clientY });
    }

    this.state = "IDLE";
  }

  destroy() {
    this.el.removeEventListener("pointerdown", this._onStart);
    this.el.removeEventListener("pointermove", this._onMove);
    this.el.removeEventListener("pointerup", this._onEnd);
    this.listeners = {};
  }
}

// ── 验证 ──
const gesture = new GestureRecognizer(document.getElementById("target"));
gesture
  .on("tap", (e) => console.log("Tap!", e))
  .on("longpress", (e) => console.log("Long Press!", e))
  .on("panstart", (e) => console.log("Pan Start", e))
  .on("panmove", (e) => console.log("Pan Move", e))
  .on("panend", (e) => console.log("Pan End", e));
```

> **本质洞察**：所有手势识别都可以归结为一个**有限状态机 (FSM)**——`IDLE → PENDING → TAP | LONG_PRESS | PAN`。时间阈值决定 Tap vs LongPress，位移阈值决定 Tap vs Pan。手势库的一切复杂性，都是在这台状态机上叠加更多的状态转移条件。

#### 2. 多指手势——Pinch 缩放与 Rotate 旋转

核心是**两指间距变化率**（缩放）和**两指连线角度变化**（旋转）。

```javascript
// ─────────────────────────────────────────────────
//  PinchRotateRecognizer — 缩放与旋转
// ─────────────────────────────────────────────────

class PinchRotateRecognizer {
  constructor(element) {
    this.el = element;
    this.pointers = new Map(); // 活跃指针集合
    this.initialDistance = 0;
    this.initialAngle = 0;

    this.el.addEventListener("pointerdown", (e) => {
      this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (this.pointers.size === 2) this._onGestureStart();
    });

    this.el.addEventListener("pointermove", (e) => {
      if (!this.pointers.has(e.pointerId)) return;
      this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (this.pointers.size === 2) this._onGestureMove();
    });

    const removePointer = (e) => this.pointers.delete(e.pointerId);
    this.el.addEventListener("pointerup", removePointer);
    this.el.addEventListener("pointercancel", removePointer);
  }

  _getTwoFingers() {
    const pts = [...this.pointers.values()];
    return [pts[0], pts[1]];
  }

  _getDistance(a, b) {
    return Math.hypot(b.x - a.x, b.y - a.y);
  }

  _getAngle(a, b) {
    return Math.atan2(b.y - a.y, b.x - a.x) * (180 / Math.PI);
  }

  _onGestureStart() {
    const [a, b] = this._getTwoFingers();
    this.initialDistance = this._getDistance(a, b);
    this.initialAngle = this._getAngle(a, b);
  }

  _onGestureMove() {
    const [a, b] = this._getTwoFingers();
    const currentDistance = this._getDistance(a, b);
    const currentAngle = this._getAngle(a, b);

    // 缩放比 = 当前双指距离 / 初始双指距离
    const scale = currentDistance / this.initialDistance;

    // 旋转角 = 当前角度 - 初始角度
    const rotation = currentAngle - this.initialAngle;

    console.log(
      `Scale: ${scale.toFixed(2)}, Rotation: ${rotation.toFixed(1)}°`,
    );
  }
}
```

> **本质洞察**：Pinch/Rotate 的数学模型极其简洁——缩放是**距离比**，旋转是**角度差**。`Math.atan2` 把笛卡尔坐标映射到角度空间，完成了"向量 → 角度"的投影。所有多指手势的本质，都是对两个坐标点的几何关系做微分。

#### 3. 惯性滚动的数学模拟

惯性的本质是**指数衰减**：`v(t) = v₀ * e^(-friction * t)`。

```javascript
// ─────────────────────────────────────────────────
//  InertialScroll — 惯性滚动引擎
// ─────────────────────────────────────────────────

class InertialScroll {
  constructor(element) {
    this.el = element;
    this.velocity = { x: 0, y: 0 };
    this.friction = 0.95; // 摩擦系数 (0-1, 越大惰性越强)
    this.minVelocity = 0.5; // 速度低于此值停止
    this.lastPos = null;
    this.lastTime = 0;
    this.rafId = null;

    this.el.addEventListener("pointerdown", this._onDown.bind(this));
    this.el.addEventListener("pointermove", this._onMove.bind(this));
    this.el.addEventListener("pointerup", this._onUp.bind(this));
  }

  _onDown(e) {
    cancelAnimationFrame(this.rafId); // 停止正在进行的惯性
    this.lastPos = { x: e.clientX, y: e.clientY };
    this.lastTime = Date.now();
    this.velocity = { x: 0, y: 0 };
  }

  _onMove(e) {
    if (!this.lastPos) return;

    const now = Date.now();
    const dt = now - this.lastTime || 1; // 避免除以零

    // 实时计算瞬时速度 (px/ms)
    this.velocity.x = (e.clientX - this.lastPos.x) / dt;
    this.velocity.y = (e.clientY - this.lastPos.y) / dt;

    this.lastPos = { x: e.clientX, y: e.clientY };
    this.lastTime = now;
  }

  _onUp() {
    this.lastPos = null;
    // 速度转为 px/frame (假设 16.67ms/frame)
    this.velocity.x *= 16.67;
    this.velocity.y *= 16.67;
    this._startInertia();
  }

  _startInertia() {
    const tick = () => {
      // 指数衰减：每帧乘以摩擦系数
      this.velocity.x *= this.friction;
      this.velocity.y *= this.friction;

      // 应用位移
      this.el.scrollLeft -= this.velocity.x;
      this.el.scrollTop -= this.velocity.y;

      // 速度足够大时继续动画
      if (
        Math.abs(this.velocity.x) > this.minVelocity ||
        Math.abs(this.velocity.y) > this.minVelocity
      ) {
        this.rafId = requestAnimationFrame(tick);
      }
    };
    this.rafId = requestAnimationFrame(tick);
  }
}
```

> **本质洞察**：惯性滚动不是线性减速，而是**指数衰减**——每帧速度乘以摩擦系数 `v *= friction`，这与自然界的阻尼运动同构。iOS 的"橡皮筋回弹"在衰减结束后加入了一个弹簧方程 `F = -kx`，本质上是两段物理模拟的拼接。

---

### 3.1.2 复杂动画编排 ⭐⭐⭐

**要求：** 设计一个可控的动画管理系统，用于高效管理复杂的视觉反馈。

- **核心挑战：**
  - 动画时间轴 (Timeline) 的设计与管理
  - 动画任务的串行 (Sequence) 与并行 (Parallel) 组合实现
  - 滚动驱动动画 (Scroll-driven Animations) 的性能优化
  - 播放状态控制：暂停 (Pause)、恢复 (Resume)、倒放 (Reverse)
  - 基于 `requestAnimationFrame` 的精度补偿与掉帧处理

#### 1. 动画时间轴——可控的 Timeline 引擎

动画编排的核心是将**时间映射为进度 (0~1)**，再通过缓动函数映射为**属性值**。

```javascript
// ─────────────────────────────────────────────────
//  AnimationTimeline — 可暂停、倒放的时间轴
// ─────────────────────────────────────────────────

class AnimationTimeline {
  constructor() {
    this.tracks = []; // 动画轨道列表
    this.currentTime = 0; // 当前时间 (ms)
    this.duration = 0; // 总时长
    this.playbackRate = 1; // 播放速率 (负数=倒放)
    this.state = "idle"; // idle | running | paused
    this.rafId = null;
    this.lastFrameTime = 0;
  }

  // ── 添加动画轨道 ──
  add(track, offset = 0) {
    track.offset = offset;
    this.tracks.push(track);
    this.duration = Math.max(this.duration, offset + track.duration);
    return this;
  }

  play() {
    if (this.state === "running") return;
    this.state = "running";
    this.lastFrameTime = performance.now();
    this._tick();
    return this;
  }

  pause() {
    this.state = "paused";
    cancelAnimationFrame(this.rafId);
    return this;
  }

  resume() {
    return this.play();
  }

  reverse() {
    this.playbackRate *= -1;
    if (this.state !== "running") this.play();
    return this;
  }

  seek(timeMs) {
    this.currentTime = Math.max(0, Math.min(timeMs, this.duration));
    this._applyFrame(this.currentTime);
    return this;
  }

  _tick() {
    if (this.state !== "running") return;

    this.rafId = requestAnimationFrame((now) => {
      // ── 精度补偿：基于实际经过时间而非假设 16.67ms ──
      const delta = (now - this.lastFrameTime) * this.playbackRate;
      this.lastFrameTime = now;

      this.currentTime += delta;

      // 边界检查
      if (this.currentTime >= this.duration) {
        this.currentTime = this.duration;
        this._applyFrame(this.currentTime);
        this.state = "idle";
        return;
      }
      if (this.currentTime <= 0) {
        this.currentTime = 0;
        this._applyFrame(0);
        this.state = "idle";
        return;
      }

      this._applyFrame(this.currentTime);
      this._tick();
    });
  }

  _applyFrame(time) {
    for (const track of this.tracks) {
      const localTime = time - track.offset;
      if (localTime >= 0 && localTime <= track.duration) {
        const progress = localTime / track.duration; // 0~1
        track.update(track.ease(progress));
      }
    }
  }
}

// ── AnimationTrack: 单个动画轨道 ──
class AnimationTrack {
  constructor({ target, property, from, to, duration, ease = (t) => t }) {
    this.target = target;
    this.property = property;
    this.from = from;
    this.to = to;
    this.duration = duration;
    this.ease = ease; // 缓动函数
    this.offset = 0;
  }

  update(progress) {
    // 线性插值: value = from + (to - from) * progress
    const value = this.from + (this.to - this.from) * progress;
    this.target.style[this.property] = `${value}px`;
  }
}

// ── 常用缓动函数 ──
const Easing = {
  linear: (t) => t,
  easeInOut: (t) => (t < 0.5 ? 2 * t * t : 1 - (-2 * t + 2) ** 2 / 2),
  easeOutBounce: (t) => {
    const n1 = 7.5625,
      d1 = 2.75;
    if (t < 1 / d1) return n1 * t * t;
    if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
    if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  },
};

// ── 验证 ──
const box = document.getElementById("box");
const timeline = new AnimationTimeline();

timeline
  .add(
    new AnimationTrack({
      target: box,
      property: "translateX",
      from: 0,
      to: 300,
      duration: 1000,
      ease: Easing.easeInOut,
    }),
    0,
  )
  .add(
    new AnimationTrack({
      target: box,
      property: "opacity",
      from: 1,
      to: 0,
      duration: 500,
      ease: Easing.linear,
    }),
    500,
  ) // 延迟 500ms 后开始淡出
  .play();

// 控制：
// timeline.pause()
// timeline.reverse()
// timeline.seek(750)
```

> **本质洞察**：动画引擎的全部秘密在于一个公式：`value = from + (to - from) * ease(t / duration)`。Timeline 只是在管理**多个公式的时间偏移量 (offset)**。串行 = 上一个的 offset + duration 作为下一个的 offset；并行 = 相同的 offset。GSAP 的内核就是这台机器。

#### 2. 串行 (Sequence) 与并行 (Parallel)

```javascript
// ─────────────────────────────────────────────────
//  sequence / parallel — 动画组合器
// ─────────────────────────────────────────────────

function sequence(timeline, tracks) {
  let offset = 0;
  for (const track of tracks) {
    timeline.add(track, offset);
    offset += track.duration; // 下一个从前一个结束时开始
  }
  return timeline;
}

function parallel(timeline, tracks, offset = 0) {
  for (const track of tracks) {
    timeline.add(track, offset); // 所有动画同一时刻开始
  }
  return timeline;
}

// ── 验证：先移动再淡出（串行），同时缩放（并行叠加） ──
const tl = new AnimationTimeline();
sequence(tl, [
  new AnimationTrack({
    target: box,
    property: "left",
    from: 0,
    to: 200,
    duration: 600,
  }),
  new AnimationTrack({
    target: box,
    property: "top",
    from: 0,
    to: 100,
    duration: 400,
  }),
]);
// 并行叠加一个缩放
parallel(
  tl,
  [
    new AnimationTrack({
      target: box,
      property: "width",
      from: 50,
      to: 100,
      duration: 1000,
    }),
  ],
  0,
);
tl.play();
```

#### 3. 掉帧处理与精度补偿

```javascript
// ── 核心：基于 delta time 而非固定步长 ──
// 错误做法：每帧假设 16.67ms
// progress += 1 / 60;  // ❌ 掉帧时动画变慢

// 正确做法：基于实际经过时间
// const delta = now - lastFrameTime;  // ✅ 精确补偿
// currentTime += delta * playbackRate;

// 这已经在上面的 AnimationTimeline._tick 中实现
// 关键行: const delta = (now - this.lastFrameTime) * this.playbackRate;
```

> **本质洞察**：基于固定帧率 (1/60) 的动画在掉帧时会"变慢"，因为少走了一步但步长没变。基于 delta time 的动画在掉帧时会"跳跃"，因为一步走更远。前者不准确，后者不平滑——**工业级引擎选择后者**，因为"准时到达终点"比"过程丝滑"更重要。

---

### 3.1.3 拖拽排序系统 ⭐⭐⭐

**要求：** 手写实现一个流畅的拖拽排序逻辑，不依赖第三方库。

- **核心挑战：**
  - 拖拽过程中的实时占位符 (Placeholder) 计算
  - 跨容器拖拽 (Cross-container Dragging) 的坐标修正
  - 边界自动滚动 (Auto-scrolling) 逻辑
  - 键盘可访问性支持 (Keyboard Accessibility)

#### 1. 核心拖拽排序引擎

```javascript
// ─────────────────────────────────────────────────
//  SortableList — 拖拽排序引擎
// ─────────────────────────────────────────────────

class SortableList {
  constructor(container) {
    this.container = container;
    this.dragItem = null; // 正在拖拽的真实元素
    this.ghost = null; // 跟随鼠标的克隆体
    this.placeholder = null; // 占位符元素
    this.offsetX = 0; // 鼠标在元素内的偏移
    this.offsetY = 0;
    this.scrollRAF = null;

    this._bindEvents();
  }

  _bindEvents() {
    this.container.addEventListener("pointerdown", this._onDown.bind(this));
    document.addEventListener("pointermove", this._onMove.bind(this));
    document.addEventListener("pointerup", this._onUp.bind(this));
  }

  _onDown(e) {
    const item = e.target.closest("[data-sortable]");
    if (!item) return;

    e.preventDefault();
    this.dragItem = item;

    const rect = item.getBoundingClientRect();
    this.offsetX = e.clientX - rect.left;
    this.offsetY = e.clientY - rect.top;

    // ── 1. 创建幽灵元素 (Ghost)：跟随鼠标 ──
    this.ghost = item.cloneNode(true);
    Object.assign(this.ghost.style, {
      position: "fixed",
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      left: `${rect.left}px`,
      top: `${rect.top}px`,
      opacity: "0.8",
      pointerEvents: "none",
      zIndex: "9999",
      transition: "none",
    });
    document.body.appendChild(this.ghost);

    // ── 2. 创建占位符 (Placeholder)：保持布局空间 ──
    this.placeholder = document.createElement("div");
    Object.assign(this.placeholder.style, {
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      border: "2px dashed #ccc",
      borderRadius: "4px",
      backgroundColor: "rgba(0,0,0,0.05)",
    });

    // ── 3. 原元素隐藏，替换为占位符 ──
    item.style.display = "none";
    item.parentNode.insertBefore(this.placeholder, item);
  }

  _onMove(e) {
    if (!this.dragItem) return;

    // Ghost 跟随鼠标
    this.ghost.style.left = `${e.clientX - this.offsetX}px`;
    this.ghost.style.top = `${e.clientY - this.offsetY}px`;

    // ── 4. 实时计算目标位置：找到鼠标下方最近的兄弟元素 ──
    const siblings = [
      ...this.container.querySelectorAll("[data-sortable]"),
    ].filter((el) => el !== this.dragItem && el !== this.placeholder);

    let target = null;
    for (const sibling of siblings) {
      const rect = sibling.getBoundingClientRect();
      const midY = rect.top + rect.height / 2;
      // 鼠标在元素上半部分：插到它前面
      if (e.clientY < midY) {
        target = sibling;
        break;
      }
    }

    // 移动占位符到目标位置
    if (target) {
      this.container.insertBefore(this.placeholder, target);
    } else {
      this.container.appendChild(this.placeholder);
    }

    // ── 5. 边界自动滚动 ──
    this._autoScroll(e.clientY);
  }

  _onUp() {
    if (!this.dragItem) return;

    // ── 6. 确认位置：将真实元素放到占位符处 ──
    this.placeholder.parentNode.insertBefore(this.dragItem, this.placeholder);
    this.dragItem.style.display = "";

    // 清理
    this.placeholder.remove();
    this.ghost.remove();
    cancelAnimationFrame(this.scrollRAF);

    this.dragItem = null;
    this.ghost = null;
    this.placeholder = null;
  }

  // ── 自动滚动：鼠标靠近容器边缘时触发 ──
  _autoScroll(clientY) {
    cancelAnimationFrame(this.scrollRAF);
    const rect = this.container.getBoundingClientRect();
    const edgeSize = 50; // 触发区域大小 (px)
    const scrollSpeed = 8; // 滚动速度 (px/frame)

    const tick = () => {
      if (clientY < rect.top + edgeSize) {
        this.container.scrollTop -= scrollSpeed;
      } else if (clientY > rect.bottom - edgeSize) {
        this.container.scrollTop += scrollSpeed;
      } else {
        return; // 不在边缘区域，停止
      }
      this.scrollRAF = requestAnimationFrame(tick);
    };
    tick();
  }
}

// ── 验证 ──
// <ul id="list">
//   <li data-sortable>Item 1</li>
//   <li data-sortable>Item 2</li>
//   <li data-sortable>Item 3</li>
// </ul>
const sortable = new SortableList(document.getElementById("list"));
```

#### 2. 键盘可访问性

```javascript
// ─────────────────────────────────────────────────
//  KeyboardSortable — 无障碍拖拽
// ─────────────────────────────────────────────────

class KeyboardSortable extends SortableList {
  constructor(container) {
    super(container);
    this.selectedItem = null;

    this.container.addEventListener("keydown", (e) => {
      const item = e.target.closest("[data-sortable]");
      if (!item) return;

      switch (e.key) {
        case "Enter":
        case " ":
          e.preventDefault();
          this._toggleSelect(item);
          break;
        case "ArrowUp":
          e.preventDefault();
          if (this.selectedItem) this._moveUp(this.selectedItem);
          break;
        case "ArrowDown":
          e.preventDefault();
          if (this.selectedItem) this._moveDown(this.selectedItem);
          break;
        case "Escape":
          this._deselect();
          break;
      }
    });
  }

  _toggleSelect(item) {
    if (this.selectedItem === item) {
      this._deselect();
    } else {
      if (this.selectedItem) this._deselect();
      this.selectedItem = item;
      item.setAttribute("aria-grabbed", "true");
      item.classList.add("selected");
    }
  }

  _deselect() {
    if (!this.selectedItem) return;
    this.selectedItem.setAttribute("aria-grabbed", "false");
    this.selectedItem.classList.remove("selected");
    this.selectedItem = null;
  }

  _moveUp(item) {
    const prev = item.previousElementSibling;
    if (prev) {
      item.parentNode.insertBefore(item, prev);
      item.focus();
    }
  }

  _moveDown(item) {
    const next = item.nextElementSibling;
    if (next) {
      item.parentNode.insertBefore(next, item);
      item.focus();
    }
  }
}
```

> **本质洞察**：拖拽排序的本质是**三个空间的同步**——视觉空间（Ghost 跟随鼠标）、布局空间（Placeholder 占位）、数据空间（DOM 顺序即数据顺序）。当这三者失同步时，就会出现"闪烁"和"抖动"。dnd-kit 和 react-beautiful-dnd 的核心差异，就在于如何保持这三者的一致性。

---

### 3.1.4 移动端滚动细节 ⭐⭐⭐

**要求：** 解决移动端 Hybrid 或 Web App 中常见的滚动体验问题。

- **核心挑战：**
  - 滚动穿透 (Scroll Penetration) 的跨端完美兼容方案
  - iOS 橡皮筋效果 (Rubber Banding) 的精准控制
  - 嵌套滚动 (Nested Scrolling) 的手势传递与竞争处理
  - 下拉刷新 (Pull-to-refresh) 与原生滚动的冲突规避
  - 虚拟键盘弹出时对布局高度的实时纠正

#### 1. 滚动穿透——终极兼容方案

```javascript
// ─────────────────────────────────────────────────
//  ScrollLock — 防滚动穿透 (全兼容)
// ─────────────────────────────────────────────────

class ScrollLock {
  constructor() {
    this.scrollY = 0;
    this.isLocked = false;
  }

  lock() {
    if (this.isLocked) return;
    this.isLocked = true;

    // ── 方案 1: position: fixed (推荐，最稳定) ──
    // 记录当前滚动位置
    this.scrollY = window.scrollY;
    const scrollbarWidth =
      window.innerWidth - document.documentElement.clientWidth;

    Object.assign(document.body.style, {
      position: "fixed",
      top: `-${this.scrollY}px`,
      left: "0",
      right: "0",
      // 防止 fixed 导致滚动条消失引起的布局跳动
      paddingRight: `${scrollbarWidth}px`,
      overflow: "hidden",
    });
  }

  unlock() {
    if (!this.isLocked) return;
    this.isLocked = false;

    Object.assign(document.body.style, {
      position: "",
      top: "",
      left: "",
      right: "",
      paddingRight: "",
      overflow: "",
    });

    // 恢复滚动位置
    window.scrollTo(0, this.scrollY);
  }
}

// ── 弹窗场景验证 ──
const lock = new ScrollLock();

function openModal() {
  lock.lock();
  document.getElementById("modal").style.display = "flex";
}

function closeModal() {
  lock.unlock();
  document.getElementById("modal").style.display = "none";
}
```

**方案对比**：

| 方案                             | iOS Safari | Android | 布局跳动 | 滚动位置恢复 |
| -------------------------------- | :--------: | :-----: | :------: | :----------: |
| `overflow: hidden`               |     ❌     |   ✅    |    ✅    |   ✅ 无需    |
| `touch-action: none`             |     ✅     |   ✅    |    ✅    |      ✅      |
| **`position: fixed` + scrollTo** |     ✅     |   ✅    | ✅ 补偿  |      ✅      |

#### 2. 下拉刷新——手势劫持与回弹

```javascript
// ─────────────────────────────────────────────────
//  PullToRefresh — 不与原生滚动冲突
// ─────────────────────────────────────────────────

class PullToRefresh {
  constructor(container, onRefresh) {
    this.container = container;
    this.onRefresh = onRefresh;
    this.startY = 0;
    this.pullDistance = 0;
    this.threshold = 80; // 触发刷新的距离
    this.maxPull = 120; // 最大下拉距离
    this.isRefreshing = false;
    this.indicator = this._createIndicator();

    container.addEventListener("touchstart", this._onStart.bind(this), {
      passive: true,
    });
    container.addEventListener("touchmove", this._onMove.bind(this), {
      passive: false,
    });
    container.addEventListener("touchend", this._onEnd.bind(this));
  }

  _createIndicator() {
    const el = document.createElement("div");
    el.className = "pull-indicator";
    el.textContent = "↓ 下拉刷新";
    Object.assign(el.style, {
      position: "absolute",
      top: "-50px",
      width: "100%",
      textAlign: "center",
      transition: "transform 0.3s",
    });
    this.container.style.position = "relative";
    this.container.prepend(el);
    return el;
  }

  _onStart(e) {
    // 关键判断：只有 scrollTop === 0 时才启用下拉刷新
    // 这避免了与正常向上滚动的冲突
    if (this.container.scrollTop !== 0 || this.isRefreshing) return;
    this.startY = e.touches[0].clientY;
  }

  _onMove(e) {
    if (!this.startY || this.isRefreshing) return;

    const currentY = e.touches[0].clientY;
    this.pullDistance = currentY - this.startY;

    // 只处理下拉方向
    if (this.pullDistance <= 0) return;

    // ── 阻止原生滚动 ──
    e.preventDefault();

    // ── 阻尼效果：越拉越费劲 ──
    // 使用对数函数制造阻尼: actualDistance = maxPull * ln(1 + pull/maxPull)
    const dampened =
      this.maxPull * Math.log(1 + this.pullDistance / this.maxPull);

    this.container.style.transform = `translateY(${dampened}px)`;
    this.indicator.style.transform = `translateY(${dampened}px)`;
    this.indicator.textContent =
      dampened >= this.threshold ? "↑ 释放刷新" : "↓ 下拉刷新";
  }

  _onEnd() {
    if (this.pullDistance <= 0) {
      this.startY = 0;
      return;
    }

    const dampened =
      this.maxPull * Math.log(1 + this.pullDistance / this.maxPull);

    if (dampened >= this.threshold) {
      this.isRefreshing = true;
      this.indicator.textContent = "⟳ 刷新中...";
      this.container.style.transform = `translateY(${this.threshold}px)`;

      // 执行刷新回调
      this.onRefresh().then(() => {
        this._reset();
      });
    } else {
      this._reset();
    }

    this.startY = 0;
    this.pullDistance = 0;
  }

  _reset() {
    this.isRefreshing = false;
    this.container.style.transition = "transform 0.3s ease";
    this.container.style.transform = "";
    this.indicator.style.transform = "";
    this.indicator.textContent = "↓ 下拉刷新";

    setTimeout(() => {
      this.container.style.transition = "";
    }, 300);
  }
}

// ── 验证 ──
new PullToRefresh(document.getElementById("list"), async () => {
  await new Promise((r) => setTimeout(r, 1500)); // 模拟网络请求
  console.log("Refreshed!");
});
```

#### 3. 虚拟键盘弹出适配

```javascript
// ─────────────────────────────────────────────────
//  KeyboardAdapter — 虚拟键盘高度适配
// ─────────────────────────────────────────────────

class KeyboardAdapter {
  constructor() {
    // ── 方案 1: Visual Viewport API (现代浏览器) ──
    if (window.visualViewport) {
      this._useVisualViewport();
    } else {
      // ── 方案 2: resize 事件 fallback ──
      this._useResizeFallback();
    }
  }

  _useVisualViewport() {
    const viewport = window.visualViewport;
    let initialHeight = viewport.height;

    viewport.addEventListener("resize", () => {
      const keyboardHeight = initialHeight - viewport.height;

      if (keyboardHeight > 100) {
        // 键盘弹出
        document.documentElement.style.setProperty(
          "--keyboard-height",
          `${keyboardHeight}px`,
        );
        document.documentElement.style.setProperty(
          "--viewport-height",
          `${viewport.height}px`,
        );
      } else {
        // 键盘收起
        document.documentElement.style.removeProperty("--keyboard-height");
        document.documentElement.style.removeProperty("--viewport-height");
      }
    });
  }

  _useResizeFallback() {
    const originalHeight = window.innerHeight;

    window.addEventListener("resize", () => {
      const currentHeight = window.innerHeight;
      const diff = originalHeight - currentHeight;

      if (diff > 150) {
        // 键盘弹出 (阈值过滤工具栏等小变化)
        document.body.style.height = `${currentHeight}px`;
      } else {
        document.body.style.height = "";
      }
    });
  }
}

// CSS 配合使用:
// .chat-input {
//   position: fixed;
//   bottom: var(--keyboard-height, 0);
// }
// .scroll-area {
//   height: var(--viewport-height, 100vh);
// }
```

> **本质洞察**：移动端滚动的所有痛点都源于一个根本矛盾——**浏览器的 viewport 和原生 WebView 的 viewport 是两套不同的坐标系统**。`window.innerHeight` 是"布局视口"，`visualViewport.height` 才是"视觉视口"。iOS Safari 在键盘弹出时不改变布局视口但改变视觉视口，这导致了 `100vh` 的经典 bug。现代解法是用 `dvh`（Dynamic Viewport Height）或 Visual Viewport API，本质上是承认了"布局 ≠ 可见"这一事实。

---

## 质量指标

- **交互流畅度**：是否达到 60fps，复杂计算是否阻塞主线程。
- **状态一致性**：交互过程中状态机是否严谨，是否存在中间无响应状态。
- **边界鲁棒性**：异常操作（如快速切换、意外中断）时的系统恢复能力。
