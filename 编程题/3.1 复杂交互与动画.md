<!--
- [INPUT]: 浏览器事件模型 (Mouse/Touch Events), requestAnimationFrame, 碰撞检测原理
- [OUTPUT]: 高级交互组件的底层手写实现（手势管理器、动画引擎、拖拽排序）
- [POS]: 编程题/ 复杂场景专题，聚焦高交互细节与性能优化
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.1 复杂交互与动画

在前端领域，"交互"是用户触达业务的唯一媒介，而"动画"则是反馈质量的物理体现。**高级交互实现的本质，是建立一套从"原始事件流"到"语义化意图"的转换机制。**

---

### 3.1.1 手势识别系统 design (Gesture Manager) ⭐⭐⭐⭐

**现象**：HTML 只有原始的 `touchstart` / `mousedown`。
**本质**：通过"坐标位移"、"持续时间"和"多指距离"判断用户真实意图（点击、长按、滑动、缩放）。

#### 核心实现：语义化手势管理器

```javascript
// ─────────────────────────────────────────────────
//  GestureManager — 语义化手势抽象引擎
// ─────────────────────────────────────────────────

class GestureManager {
  constructor(element) {
    this.element = element;
    this.startTime = 0;
    this.startX = 0;
    this.startY = 0;
    this.longPressTimer = null;
    this.isPanning = false;

    this.init();
  }

  init() {
    this.element.addEventListener("touchstart", (e) => this.onStart(e), {
      passive: false,
    });
    this.element.addEventListener("touchmove", (e) => this.onMove(e), {
      passive: false,
    });
    this.element.addEventListener("touchend", (e) => this.onEnd(e));
  }

  onStart(e) {
    const touch = e.touches[0];
    this.startX = touch.clientX;
    this.startY = touch.clientY;
    this.startTime = Date.now();
    this.isPanning = false;

    // 长按判定：500ms 内无移动则触发
    this.longPressTimer = setTimeout(() => {
      this.dispatch("longpress", { x: this.startX, y: this.startY });
    }, 500);
  }

  onMove(e) {
    const touch = e.touches[0];
    const dx = touch.clientX - this.startX;
    const dy = touch.clientY - this.startY;

    // 移动超过 10px 判定为滑动，取消长按
    if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
      clearTimeout(this.longPressTimer);
      this.isPanning = true;
      this.dispatch("pan", { dx, dy });
    }
  }

  onEnd(e) {
    clearTimeout(this.longPressTimer);
    const duration = Date.now() - this.startTime;

    if (!this.isPanning && duration < 300) {
      this.dispatch("tap", { x: this.startX, y: this.startY });
    }
    this.isPanning = false;
  }

  dispatch(type, detail) {
    const event = new CustomEvent(type, { detail });
    this.element.dispatchEvent(event);
  }
}

// ── 验证 ──
/*
const box = document.querySelector('#box');
new GestureManager(box);

box.addEventListener('tap', (e) => console.log('Tap at:', e.detail));
box.addEventListener('longpress', (e) => console.log('Long Press!'));
box.addEventListener('pan', (e) => console.log('Moving:', e.detail.dx));
*/
```

> **本质洞察**：**手势是时间的函数**。所有的复杂手势都是在 `(x, y, t)` 三维坐标系下的状态转移。好的手势库应该通过状态机（FSM）来管理状态切换，避免 `if/else` 地狱。

---

### 3.1.2 复杂动画编排 (Animation Engine) ⭐⭐⭐

**现象**：`setTimeout` 动画卡顿，多个动画同步困难。
**本质**：利用 `requestAnimationFrame` 同步显示器刷新率，通过时间片比例映射数值状态。

#### 核心实现：简单补间动画类 (Tween)

```javascript
// ─────────────────────────────────────────────────
//  Animator — 基于 rAF 的高性能补间引擎
// ─────────────────────────────────────────────────

const Easing = {
  linear: (t) => t,
  easeInOutQuad: (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),
};

class Animator {
  constructor({ duration = 1000, easing = "linear", onUpdate, onComplete }) {
    this.duration = duration;
    this.easing = Easing[easing];
    this.onUpdate = onUpdate;
    this.onComplete = onComplete;
    this.startTime = null;
    this.requestId = null;
  }

  start() {
    this.startTime = performance.now();
    this.tick();
  }

  tick() {
    const now = performance.now();
    let elapsed = now - this.startTime;
    let progress = Math.min(elapsed / this.duration, 1);

    // 应用缓动函数映射
    const easedProgress = this.easing(progress);
    this.onUpdate(easedProgress);

    if (progress < 1) {
      this.requestId = requestAnimationFrame(() => this.tick());
    } else {
      this.onComplete?.();
    }
  }

  stop() {
    cancelAnimationFrame(this.requestId);
  }
}

// ── 验证 ──
/*
new Animator({
  duration: 800,
  easing: 'easeInOutQuad',
  onUpdate: (p) => {
    element.style.transform = `translateX(${p * 200}px)`;
  }
}).start();
*/
```

> **本质洞察**：**动画的本质是"进度的映射"**。进度 `[0, 1]` 经过 Easing 函数转换后，映射到像素、透明度或缩放。理解了这一层，你就能轻松实现"滚动驱动动画"——只需将滚动百分比作为进度传入即可。

---

### 3.1.3 拖拽排序系统 (Drag & Drop Logic) ⭐⭐⭐

**现象**：拖拽时物体乱跳，位置计算复杂。
**本质**：实时记录鼠标偏移量，并高频计算当前坐标落在哪个兄弟元素的"中轴线"范围。

#### 核心实现：拖拽占位符计算逻辑

```javascript
// ─────────────────────────────────────────────────
//  getDragAfterElement — 确定拖拽后的插入位置
// ─────────────────────────────────────────────────

function getDragAfterElement(container, y) {
  // 获取容器内所有非拖拽中的子元素
  const draggableElements = [
    ...container.querySelectorAll(".draggable:not(.dragging)"),
  ];

  return draggableElements.reduce(
    (closest, child) => {
      const box = child.getBoundingClientRect();
      // 计算鼠标 y 坐标与子元素中心点 y 坐标的距离
      const offset = y - (box.top + box.height / 2);

      // offset < 0 说明鼠标在子元素上半部分
      // 我们找最接近 0 的负值
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    },
    { offset: Number.NEGATIVE_INFINITY },
  ).element;
}

// ── 验证 ──
/*
container.addEventListener('dragover', e => {
  e.preventDefault();
  const afterElement = getDragAfterElement(container, e.clientY);
  const dragging = document.querySelector('.dragging');
  if (afterElement == null) {
    container.appendChild(dragging);
  } else {
    container.insertBefore(dragging, afterElement);
  }
});
*/
```

> **本质洞察**：**拖拽排序是"重塑 DOM 顺序"**。重点不在于移动视觉位置（那是 CSS 做的事），而在于何时何地执行 `insertBefore`。使用 `getBoundingClientRect` 进行碰撞检测是业界标准做法。

---

### 3.1.4 移动端滚动冲突 (Scroll Management) ⭐⭐⭐

**现象**：弹窗出现时，底层背景仍然可以滚动（滚动穿透）。
**本质**：浏览器默认行为触发。

#### 最佳实践：滚动穿透完美解决方案

```javascript
function toggleLockBody(lock) {
  if (lock) {
    // 方案 1：针对 PC 和部分移动端
    document.body.style.overflow = "hidden";

    // 方案 2：针对 iOS 万恶的橡皮筋（需记录位置）
    const scrollY = window.scrollY;
    document.body.style.position = "fixed";
    document.body.style.top = `-${scrollY}px`;
    document.body.setAttribute("data-scroll-y", scrollY);
  } else {
    const scrollY = document.body.getAttribute("data-scroll-y");
    document.body.style.position = "";
    document.body.style.top = "";
    window.scrollTo(0, parseInt(scrollY || "0"));
  }
}
```

> **本质洞察**：**iOS 的滚动是系统级行为**。仅仅设置 `overflow: hidden` 无法阻挡 WebKit 的橡皮筋弹性。只有通过 `fixed` 布局脱离标准文档流，才能彻底切断系统滚动信号。

---

## 质量指标

- **FPS (Frames Per Second)**：动画是否维持在 60fps。
- **Interactive Precision**：手势判定是否误触，拖拽插入是否灵敏。
- **Cross-Platform Consistency**：在不同系统下（尤其是 iOS）的表现一致性。
