<!--
- [INPUT]: 依赖 i18n 规范与 WCAG 标准
- [OUTPUT]: 国际化与无障碍最佳实践
- [POS]: 编程题模块 - 国际化与可访问性
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 4.9 国际化与可访问性

国际化 (i18n) 和可访问性 (a11y) 是产品走向全球化和全人群覆盖的两根支柱。

---

## 4.9.1 国际化 i18n ⭐⭐⭐

### 问题

- **文案管理**
- **动态切换**
- **复数/日期/货币**
- **RTL 布局**
- **文本长度差异**

### 1. 轻量 i18n 引擎

```javascript
// ─────────────────────────────────────────────────
//  I18nEngine — 轻量国际化引擎
// ─────────────────────────────────────────────────

class I18n {
  constructor(options = {}) {
    this.locale = options.defaultLocale || "zh-CN";
    this.messages = {}; // { "zh-CN": {...}, "en-US": {...} }
    this.listeners = [];
    this.fallbackLocale = options.fallback || "en-US";
  }

  // ── 加载翻译资源 ──────────────────────────────
  addMessages(locale, messages) {
    this.messages[locale] = { ...this.messages[locale], ...messages };
  }

  // ── 核心：翻译函数 t() ────────────────────────
  t(key, params = {}) {
    const message =
      this._resolve(this.locale, key) ||
      this._resolve(this.fallbackLocale, key) ||
      key; // 找不到就返回 key 本身

    // 插值替换：{name} → 实际值
    return message.replace(/\{(\w+)\}/g, (_, name) => {
      return params[name] !== undefined ? params[name] : `{${name}}`;
    });
  }

  // ── 嵌套 key 解析 "user.greeting" ─────────────
  _resolve(locale, key) {
    const messages = this.messages[locale];
    if (!messages) return null;

    return key.split(".").reduce((obj, k) => obj?.[k], messages);
  }

  // ── 动态切换语言 ──────────────────────────────
  setLocale(locale) {
    this.locale = locale;
    document.documentElement.lang = locale;
    // RTL 支持
    document.documentElement.dir = ["ar", "he", "fa"].some((l) =>
      locale.startsWith(l),
    )
      ? "rtl"
      : "ltr";
    this.listeners.forEach((fn) => fn(locale));
  }

  onChange(fn) {
    this.listeners.push(fn);
    return () => {
      this.listeners = this.listeners.filter((l) => l !== fn);
    };
  }
}

// ── 使用 ────────────────────────────────────────
const i18n = new I18n({ defaultLocale: "zh-CN" });

i18n.addMessages("zh-CN", {
  user: { greeting: "你好，{name}！" },
  items: { count: "{count} 个项目" },
});

i18n.addMessages("en-US", {
  user: { greeting: "Hello, {name}!" },
  items: { count: "{count} items" },
});

i18n.t("user.greeting", { name: "Linus" }); // "你好，Linus！"
```

### 2. 复数、日期、货币：Intl API

```javascript
// ─────────────────────────────────────────────────
//  Intl — 浏览器原生国际化 API
// ─────────────────────────────────────────────────

// ── 复数规则（不同语言复数规则差异极大） ────────
function pluralize(locale, count, forms) {
  const rules = new Intl.PluralRules(locale);
  const category = rules.select(count); // "zero"|"one"|"two"|"few"|"many"|"other"
  return forms[category] || forms.other;
}

pluralize("en-US", 1, { one: "1 item", other: "{n} items" }); // "1 item"
pluralize("en-US", 5, { one: "1 item", other: "{n} items" }); // "{n} items"
// 俄语有 one, few, many 三种！阿拉伯语有更多！

// ── 日期格式化 ──────────────────────────────────
function formatDate(date, locale) {
  return new Intl.DateTimeFormat(locale, {
    year: "numeric",
    month: "long",
    day: "numeric",
  }).format(date);
}

formatDate(new Date(), "zh-CN"); // "2026年2月17日"
formatDate(new Date(), "en-US"); // "February 17, 2026"
formatDate(new Date(), "ja-JP"); // "2026年2月17日"

// ── 货币格式化 ──────────────────────────────────
function formatCurrency(amount, locale, currency) {
  return new Intl.NumberFormat(locale, {
    style: "currency",
    currency,
  }).format(amount);
}

formatCurrency(1234.5, "zh-CN", "CNY"); // "¥1,234.50"
formatCurrency(1234.5, "en-US", "USD"); // "$1,234.50"
formatCurrency(1234.5, "ja-JP", "JPY"); // "￥1,235"（日元无小数）

// ── 相对时间 ────────────────────────────────────
function timeAgo(date, locale) {
  const rtf = new Intl.RelativeTimeFormat(locale, { numeric: "auto" });
  const diff = (date - Date.now()) / 1000;

  if (Math.abs(diff) < 60) return rtf.format(Math.round(diff), "second");
  if (Math.abs(diff) < 3600) return rtf.format(Math.round(diff / 60), "minute");
  if (Math.abs(diff) < 86400)
    return rtf.format(Math.round(diff / 3600), "hour");
  return rtf.format(Math.round(diff / 86400), "day");
}

timeAgo(Date.now() - 120000, "zh-CN"); // "2分钟前"
timeAgo(Date.now() - 120000, "en-US"); // "2 minutes ago"
```

### 3. RTL 布局与文本长度差异

```css
/* ─────────────────────────────────────────────────
   RTL 布局 — 从右到左语言适配
   ───────────────────────────────────────────────── */

/* 使用逻辑属性代替物理属性 */
.card {
  /* ❌ 只适配 LTR */
  /* margin-left: 16px; padding-right: 8px; */

  /* ✅ 自动适配 LTR 和 RTL */
  margin-inline-start: 16px;
  padding-inline-end: 8px;
  border-inline-start: 3px solid blue;
}

/* Flexbox 自动适配 RTL */
.nav {
  display: flex;
  /* RTL 模式下自动反转 */
  gap: 16px;
}

/* 文本长度差异处理 */
.button {
  /* 德语比英语长 30%，日语可能更短 */
  min-width: fit-content;
  padding: 8px 16px;
  white-space: nowrap;
  /* 不要用 width 定死 */
}
```

> **本质洞察**：i18n 的核心难点不在于翻译文案，而在于 **「语言差异的深度」**。英语的复数只有单/复数两种，俄语有 4 种，阿拉伯语有 6 种。德语文案比英语长 30%，中日韩却可能更短。RTL 语言颠覆了整个布局方向。`Intl` API 是浏览器内置的国际化引擎，它背后是 ICU 库 —— 全球最完善的国际化数据集。**不要自己造轮子格式化日期和货币**。

---

## 4.9.2 可访问性 A11Y ⭐⭐

### 要求

- **语义化 HTML**
- **ARIA 属性**
- **键盘导航**
- **屏幕阅读器**
- **颜色对比度**

### 1. 语义化 HTML 与 ARIA

```html
<!-- ─────────────────────────────────────────────────
     Semantic HTML — 语义优先，ARIA 补充
     ───────────────────────────────────────────────── -->

<!-- ❌ 糟糕的做法：全是 div，屏幕阅读器完全不理解 -->
<div class="nav">
  <div class="nav-item" onclick="goHome()">首页</div>
</div>
<div class="main">
  <div class="title">文章标题</div>
  <div class="content">正文内容...</div>
</div>

<!-- ✅ 语义化做法：每个标签都有含义 -->
<nav aria-label="主导航">
  <ul>
    <li><a href="/">首页</a></li>
    <li><a href="/about">关于</a></li>
  </ul>
</nav>

<main>
  <article>
    <h1>文章标题</h1>
    <p>正文内容...</p>
  </article>
</main>

<!-- ARIA 补充：当语义 HTML 不够用时 -->
<div
  role="dialog"
  aria-modal="true"
  aria-labelledby="dialog-title"
  aria-describedby="dialog-desc"
>
  <h2 id="dialog-title">确认删除</h2>
  <p id="dialog-desc">此操作不可撤销</p>
  <button autofocus>确定</button>
  <button>取消</button>
</div>

<!-- Live Region：动态内容更新通知屏幕阅读器 -->
<div aria-live="polite" aria-atomic="true">
  <!-- 内容变化后屏幕阅读器会自动读出 -->
  加载完毕，共 42 条结果
</div>
```

### 2. 键盘导航

```javascript
// ─────────────────────────────────────────────────
//  KeyboardNav — 键盘导航管理
// ─────────────────────────────────────────────────

class KeyboardNavigator {
  constructor(container, selector = '[role="menuitem"], a, button') {
    this.container = container;
    this.selector = selector;
    this._init();
  }

  _init() {
    this.container.addEventListener("keydown", (e) => {
      const items = [...this.container.querySelectorAll(this.selector)];
      const currentIdx = items.indexOf(document.activeElement);

      switch (e.key) {
        case "ArrowDown":
        case "ArrowRight":
          e.preventDefault();
          const next = (currentIdx + 1) % items.length;
          items[next]?.focus();
          break;

        case "ArrowUp":
        case "ArrowLeft":
          e.preventDefault();
          const prev = (currentIdx - 1 + items.length) % items.length;
          items[prev]?.focus();
          break;

        case "Home":
          e.preventDefault();
          items[0]?.focus();
          break;

        case "End":
          e.preventDefault();
          items[items.length - 1]?.focus();
          break;

        case "Escape":
          this.container
            .closest("[role='dialog']")
            ?.dispatchEvent(new CustomEvent("close"));
          break;
      }
    });
  }
}

// ── 焦点陷阱 (Focus Trap)：弹窗中焦点不外逃 ───
class FocusTrap {
  constructor(element) {
    this.element = element;
    this.previousFocus = document.activeElement;
  }

  activate() {
    const focusable = this.element.querySelectorAll(
      'a, button, input, select, textarea, [tabindex]:not([tabindex="-1"])',
    );
    const first = focusable[0];
    const last = focusable[focusable.length - 1];

    first?.focus();

    this.handler = (e) => {
      if (e.key !== "Tab") return;

      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault();
        last.focus();
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault();
        first.focus();
      }
    };

    this.element.addEventListener("keydown", this.handler);
  }

  deactivate() {
    this.element.removeEventListener("keydown", this.handler);
    this.previousFocus?.focus(); // 恢复之前的焦点
  }
}
```

### 3. 颜色对比度检测

```javascript
// ─────────────────────────────────────────────────
//  ContrastChecker — WCAG 对比度检测
// ─────────────────────────────────────────────────

function checkContrast(foreground, background) {
  const fgLum = relativeLuminance(foreground);
  const bgLum = relativeLuminance(background);

  const lighter = Math.max(fgLum, bgLum);
  const darker = Math.min(fgLum, bgLum);

  const ratio = (lighter + 0.05) / (darker + 0.05);

  return {
    ratio: ratio.toFixed(2),
    // WCAG 2.1 标准
    AA_normal: ratio >= 4.5, // 正常文本
    AA_large: ratio >= 3, // 大文本 (18px+)
    AAA_normal: ratio >= 7, // 增强
    AAA_large: ratio >= 4.5,
  };
}

function relativeLuminance([r, g, b]) {
  const [rs, gs, bs] = [r, g, b].map((c) => {
    c = c / 255;
    return c <= 0.03928 ? c / 12.92 : ((c + 0.055) / 1.055) ** 2.4;
  });
  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}

// checkContrast([255, 255, 255], [0, 0, 0])
// → { ratio: "21.00", AA_normal: true, AA_large: true, ... }

// checkContrast([255, 255, 255], [200, 200, 200])
// → { ratio: "1.16", AA_normal: false, ... } ← 不合格！
```

> **本质洞察**：可访问性的哲学是 **「Web 是为所有人设计的」**（Tim Berners-Lee）。语义化 HTML 不是"多余的工作"，而是 **信息的结构化** —— 它让屏幕阅读器、搜索引擎、爬虫都能理解你的页面。ARIA 是语义化 HTML 的补充，不是替代品 —— 能用 `<button>` 就不要用 `<div role="button">`。键盘导航是可访问性的第一道门：**如果你的网站不能仅用键盘操作，那你就排除了所有无法使用鼠标的人**。对比度不够则排除了色弱和弱视人群。每一条 a11y 规则背后都是一个真实的人群。

---

## 质量指标

- **Lighthouse 可访问性得分**：目标 ≥ 90 分。
- **键盘可达性**：所有交互元素能否仅用键盘触达与操作。
- **翻译覆盖率**：所有用户可见的文案是否都经过 i18n 处理。
