<!--
- [INPUT]: 依赖浏览器工作原理
- [OUTPUT]: 浏览器原理应用与优化实战
- [POS]: 编程题模块 - 浏览器原理
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 4.3 浏览器原理应用

浏览器不是"黑盒"，理解它的内部管线（Event Loop → Rendering Pipeline → Compositing）是性能优化的根基。

---

## 4.3.1 事件循环实战 ⭐⭐⭐⭐

### 必须掌握

- **宏任务/微任务执行顺序**
- **rAF 执行时机**
- **rIC 使用场景**
- **nextTick 原理**
- **setState 批量更新**

### 1. 经典输出题：彻底理解执行顺序

```javascript
// ─────────────────────────────────────────────────
//  EventLoop — 经典执行顺序分析
// ─────────────────────────────────────────────────

console.log("1. script start"); // ①同步

setTimeout(() => {
  console.log("2. setTimeout"); // ⑥宏任务
}, 0);

requestAnimationFrame(() => {
  console.log("3. rAF"); // ⑤渲染前（下一帧）
});

Promise.resolve()
  .then(() => {
    console.log("4. promise 1"); // ③微任务
  })
  .then(() => {
    console.log("5. promise 2"); // ④微任务（链式）
  });

console.log("6. script end"); // ②同步

// 输出顺序：
// 1. script start
// 6. script end
// 4. promise 1
// 5. promise 2
// 3. rAF            ← 在渲染前执行
// 2. setTimeout     ← 下一轮宏任务

// ── 执行模型 ────────────────────────────────────
// 一轮事件循环：
// [宏任务] → [清空所有微任务] → [rAF] → [渲染] → [rIC] → [下一个宏任务]
```

### 2. requestIdleCallback 实战

```javascript
// ─────────────────────────────────────────────────
//  rIC — 空闲时间任务调度（React Scheduler 原型）
// ─────────────────────────────────────────────────

class IdleTaskScheduler {
  constructor() {
    this.taskQueue = [];
    this.isRunning = false;
  }

  addTask(task, priority = "normal") {
    this.taskQueue.push({ task, priority });
    // 高优先级排前面
    this.taskQueue.sort((a, b) =>
      a.priority === "high" ? -1 : b.priority === "high" ? 1 : 0,
    );
    this._schedule();
  }

  _schedule() {
    if (this.isRunning) return;
    this.isRunning = true;

    requestIdleCallback((deadline) => this._process(deadline));
  }

  _process(deadline) {
    // 有剩余时间 且 有待处理任务
    while (deadline.timeRemaining() > 1 && this.taskQueue.length > 0) {
      const { task } = this.taskQueue.shift();
      task();
    }

    if (this.taskQueue.length > 0) {
      requestIdleCallback((deadline) => this._process(deadline));
    } else {
      this.isRunning = false;
    }
  }
}

// 使用：非关键任务在空闲时执行
const scheduler = new IdleTaskScheduler();
scheduler.addTask(() => analytics.send(data)); // 低优先级
scheduler.addTask(() => prefetchNextPage(), "high"); // 高优先级
```

### 3. Vue nextTick 原理

```javascript
// ─────────────────────────────────────────────────
//  nextTick — 微任务异步更新队列
// ─────────────────────────────────────────────────

const callbacks = [];
let pending = false;

function nextTick(cb) {
  callbacks.push(cb);
  if (!pending) {
    pending = true;
    // Promise.then 把 flush 推入微任务队列
    Promise.resolve().then(flushCallbacks);
  }
}

function flushCallbacks() {
  pending = false;
  const copies = callbacks.slice();
  callbacks.length = 0;
  copies.forEach((cb) => cb());
}

// ── 本质：把多次 setState 合并为一次 DOM 更新 ───
// state.a = 1;  → 入队
// state.b = 2;  → 入队
// state.c = 3;  → 入队
// 同步代码结束 → 微任务执行 → 一次性 patch DOM
```

> **本质洞察**：事件循环的本质是浏览器的 **"工作日程表"**。宏任务是"会议"，微任务是"会后立刻处理的邮件"，rAF 是"下班前必须签字的文件"，rIC 是"没事干时打扫的卫生"。理解这个优先级顺序，就理解了为什么 `Promise.then` 比 `setTimeout` 先执行——email 当然比下一场会议更紧急。

---

## 4.3.2 渲染原理应用 ⭐⭐⭐

### 优化依据

- **重排/重绘触发与优化**
- **合成层管理**
- **will-change 正确使用**
- **GPU 加速利弊**
- **Layout Thrashing 避免**

### 1. Layout Thrashing 与修复

```javascript
// ─────────────────────────────────────────────────
//  Layout Thrashing — 强制同步布局的灾难
// ─────────────────────────────────────────────────

// ❌ 错误写法：读写交替 → 每次读都触发强制布局
function badLayout(elements) {
  elements.forEach((el) => {
    const height = el.offsetHeight; // 读 → 触发布局
    el.style.height = height * 2 + "px"; // 写 → 标记脏
    // 下一次循环的 offsetHeight 又要重新布局！
  });
  // 100 个元素 = 100 次强制布局，性能灾难
}

// ✅ 正确写法：批量读，再批量写
function goodLayout(elements) {
  // Phase 1: 全部读完
  const heights = elements.map((el) => el.offsetHeight);

  // Phase 2: 全部写入（只触发一次布局）
  elements.forEach((el, i) => {
    el.style.height = heights[i] * 2 + "px";
  });
}

// ✅ 最佳实践：使用 requestAnimationFrame 分离读写
function bestLayout(elements) {
  // 读操作在当前帧
  const heights = elements.map((el) => el.offsetHeight);

  // 写操作推迟到下一帧
  requestAnimationFrame(() => {
    elements.forEach((el, i) => {
      el.style.height = heights[i] * 2 + "px";
    });
  });
}
```

### 2. 合成层与 GPU 加速

```css
/* ─────────────────────────────────────────────────
   合成层管理 — will-change 正确使用
   ───────────────────────────────────────────────── */

/* ✅ 正确：动画开始前提升合成层 */
.card:hover {
  will-change: transform;
}
.card:active {
  transform: scale(0.95);
  transition: transform 0.2s;
}

/* ❌ 错误：全局滥用（每个合成层消耗 GPU 内存） */
* {
  will-change: transform, opacity;
}

/* ✅ 高性能动画：只用 transform 和 opacity */
/* 这两个属性不触发重排重绘，纯 GPU 合成 */
.animate {
  transform: translateX(100px); /* ✅ 不触发 Layout */
  opacity: 0.5; /* ✅ 不触发 Layout */
  /* left: 100px; */ /* ❌ 触发 Layout + Paint */
}
```

```javascript
// ─────────────────────────────────────────────────
//  渲染管线示意
// ─────────────────────────────────────────────────

// JS → Style → Layout → Paint → Composite
//
// transform/opacity 变更：JS → Composite (跳过中间步骤)
// width/height 变更：JS → Style → Layout → Paint → Composite
// color/background 变更：JS → Style → Paint → Composite
//
// 性能优化核心：尽量让动画只走到 Composite 层
```

> **本质洞察**：浏览器的渲染管线是一条 **流水线**：`Style → Layout → Paint → Composite`。性能优化的第一原则是 **"跳过尽可能多的阶段"**。`transform` 和 `opacity` 之所以高效，是因为它们直接在 GPU 的合成阶段处理，完全跳过了 CPU 密集的 Layout 和 Paint。Layout Thrashing 之所以致命，是因为它 **强制浏览器在每次读操作前同步执行整条管线**，把原本"攒一批再算"的优化彻底击碎。

---

## 质量指标

- **执行顺序**：能否准确预测任意微任务/宏任务组合的输出。
- **性能直觉**：能否判断一行 CSS/JS 触发了管线的哪个阶段。
- **优化手段**：能否在 Performance 面板中识别并修复 Layout Thrashing。
