<!--
- [INPUT]: Window Error Listeners, Performance API, Beacon API, SourceMap Algorithms
- [OUTPUT]: 监控系统 SDK 设计要求，涵盖错误捕获、性能指标及埋点上报策略
- [POS]: 编程题/ 复杂场景专题，聚焦系统可观测深度与数据采集稳定性
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.7 监控与可观测性

监控 SDK 是系统在线上的"黑匣子"，它决定了我们在面对故障时是"盲目猜测"还是"精准打击"。

---

### 3.7.1 错误监控 SDK 开发 ⭐⭐⭐⭐

**要求：** 设计一个无死角捕获应用运行时错误的底层监控库。

- **核心技术指标：**
  - **JS 运行时错误**：通过 `window.onerror` 与 `error` 事件捕获处理各类异常。
  - **异步错误处理**：监听 `unhandledrejection` 处理未捕获的 Promise 异常。
  - **资源加载故障**：识别脚本、样式或图片加载失败的精准归因。
  - **接口稳定性劫持**：拦截并包装 `fetch` 与 `XHR`，捕获 HTTP 状态码与耗时。
  - **SourceMap 堆栈还原**：设计在服务端还原压缩代码真实堆栈的基础流程。
  - **错误指纹与聚合**：根据错误特征进行自动去重与指纹计算，防止报警风暴。
  - **行为记录 (Breadcrumbs)**：记录用户崩溃前的操作队列，实现场景回溯。

#### 1. 全链路错误捕获

```javascript
// ─────────────────────────────────────────────────
//  ErrorMonitor — 多维错误捕获引擎
// ─────────────────────────────────────────────────

class ErrorMonitor {
  constructor(options = {}) {
    this.dsn = options.dsn; // 上报地址
    this.breadcrumbs = []; // 用户行为面包屑
    this.maxBreadcrumbs = options.maxBreadcrumbs || 20;
    this.errorBuffer = new Map(); // 错误指纹去重
    this._initCapture();
  }

  // ── 1. JS 运行时错误 ──────────────────────────
  _initCapture() {
    // 同步错误
    window.addEventListener(
      "error",
      (event) => {
        if (event.target !== window) {
          // 资源加载失败（img/script/link）
          this._handleResourceError(event);
          return;
        }
        this._report({
          type: "js_error",
          message: event.message,
          stack: event.error?.stack,
          filename: event.filename,
          lineno: event.lineno,
          colno: event.colno,
        });
      },
      true,
    ); // 必须 capture 阶段，否则资源错误捕获不到

    // 2. 未捕获的 Promise 异常
    window.addEventListener("unhandledrejection", (event) => {
      this._report({
        type: "promise_error",
        message: event.reason?.message || String(event.reason),
        stack: event.reason?.stack,
      });
    });

    // 3. 劫持 fetch
    this._hijackFetch();

    // 4. 劫持 XMLHttpRequest
    this._hijackXHR();

    // 5. 用户行为追踪
    this._trackBreadcrumbs();
  }

  // ── 资源加载错误 ──────────────────────────────
  _handleResourceError(event) {
    const target = event.target;
    this._report({
      type: "resource_error",
      tag: target.tagName,
      src: target.src || target.href,
      message: `${target.tagName} 加载失败: ${target.src || target.href}`,
    });
  }

  // ── Fetch 劫持 ────────────────────────────────
  _hijackFetch() {
    const originalFetch = window.fetch;
    const self = this;

    window.fetch = function (...args) {
      const startTime = performance.now();
      const url = typeof args[0] === "string" ? args[0] : args[0]?.url;

      return originalFetch.apply(this, args).then(
        (response) => {
          const duration = performance.now() - startTime;
          self._addBreadcrumb("fetch", {
            url,
            status: response.status,
            duration,
          });

          if (!response.ok) {
            self._report({
              type: "http_error",
              url,
              status: response.status,
              duration,
            });
          }
          return response;
        },
        (error) => {
          self._report({
            type: "fetch_error",
            url,
            message: error.message,
          });
          throw error;
        },
      );
    };
  }

  // ── Breadcrumbs 面包屑 ────────────────────────
  _trackBreadcrumbs() {
    // 记录点击
    document.addEventListener(
      "click",
      (e) => {
        const target = e.target;
        this._addBreadcrumb("click", {
          tag: target.tagName,
          id: target.id,
          text: target.textContent?.slice(0, 50),
        });
      },
      true,
    );

    // 记录路由变化
    const originalPush = history.pushState;
    history.pushState = (...args) => {
      this._addBreadcrumb("navigation", { to: args[2] });
      return originalPush.apply(history, args);
    };
  }

  _addBreadcrumb(category, data) {
    this.breadcrumbs.push({
      category,
      data,
      timestamp: Date.now(),
    });
    if (this.breadcrumbs.length > this.maxBreadcrumbs) {
      this.breadcrumbs.shift();
    }
  }

  // ── 错误指纹去重 ──────────────────────────────
  _report(errorInfo) {
    const fingerprint = this._calcFingerprint(errorInfo);

    if (this.errorBuffer.has(fingerprint)) {
      this.errorBuffer.get(fingerprint).count++;
      return; // 去重：相同错误不重复上报
    }

    const payload = {
      ...errorInfo,
      fingerprint,
      breadcrumbs: [...this.breadcrumbs],
      timestamp: Date.now(),
      url: location.href,
      userAgent: navigator.userAgent,
    };

    this.errorBuffer.set(fingerprint, { payload, count: 1 });
    this._send(payload);
  }

  _calcFingerprint(error) {
    // 基于 message + stack 前三行 生成指纹
    const stackLines = (error.stack || "").split("\n").slice(0, 3).join("");
    const raw = `${error.type}:${error.message}:${stackLines}`;
    // 简单哈希
    let hash = 0;
    for (let i = 0; i < raw.length; i++) {
      hash = ((hash << 5) - hash + raw.charCodeAt(i)) | 0;
    }
    return hash.toString(36);
  }

  _send(payload) {
    // 使用 sendBeacon 保证页面关闭时也能发出
    const blob = new Blob([JSON.stringify(payload)], {
      type: "application/json",
    });
    navigator.sendBeacon(this.dsn, blob);
  }
}
```

> **本质洞察**：错误监控 SDK 的第一法则是 **「绝不能成为错误的来源」**。SDK 本身必须用 try-catch 把自己包裹得密不透风。第二法则是 **「指纹即身份」** —— 没有指纹去重，一个循环中的错误会在 1 秒内产生数万条告警，瞬间淹没整个监控系统。第三法则是 **「面包屑是最有价值的数据」** —— 错误堆栈告诉你"死在哪里"，面包屑告诉你"怎么走到那里的"。

---

### 3.7.2 性能监控 (Performance Core) ⭐⭐⭐

**要求：** 实现对用户核心感知指标的自动化采集与上报。

- **指标挑战：**
  - **Web Vitals 采集**：精准测量 FCP, LCP, CLS, FID 及最新的 INP 指标。
  - **长任务监听**：利用 `PerformanceObserver` 识别阻塞主线程的 Long Task（>50ms）。
  - **资源加载瀑布流**：分析关键资源（Bundle, Font）的加载耗时与优先级。
  - **自定义业务打点**：设计支持全链路时间戳打点的 API。

#### 1. Web Vitals 全自动采集

```javascript
// ─────────────────────────────────────────────────
//  PerfMonitor — 核心指标自动采集
// ─────────────────────────────────────────────────

class PerfMonitor {
  constructor(reporter) {
    this.reporter = reporter;
    this.metrics = {};
    this.customMarks = {};
  }

  init() {
    this._observeLCP();
    this._observeFID();
    this._observeCLS();
    this._observeFCP();
    this._observeINP();
    this._observeLongTasks();
    this._collectNavTiming();
  }

  // ── LCP: 最大内容绘制 ─────────────────────────
  _observeLCP() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      // 取最后一个 LCP entry（浏览器不断更新直到用户交互）
      const lastEntry = entries[entries.length - 1];
      this.metrics.lcp = lastEntry.startTime;
    });
    observer.observe({ type: "largest-contentful-paint", buffered: true });
  }

  // ── FID: 首次输入延迟 ─────────────────────────
  _observeFID() {
    const observer = new PerformanceObserver((list) => {
      const entry = list.getEntries()[0];
      // FID = 事件处理开始时间 - 事件触发时间
      this.metrics.fid = entry.processingStart - entry.startTime;
    });
    observer.observe({ type: "first-input", buffered: true });
  }

  // ── CLS: 累积布局偏移 ─────────────────────────
  _observeCLS() {
    let clsValue = 0;
    let sessionValue = 0;
    let sessionEntries = [];

    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
          // 会话窗口算法：5秒窗口，1秒间隔
          const firstEntry = sessionEntries[0];
          const lastEntry = sessionEntries[sessionEntries.length - 1];

          if (
            sessionValue &&
            entry.startTime - lastEntry.startTime < 1000 &&
            entry.startTime - firstEntry.startTime < 5000
          ) {
            sessionValue += entry.value;
            sessionEntries.push(entry);
          } else {
            sessionValue = entry.value;
            sessionEntries = [entry];
          }

          if (sessionValue > clsValue) {
            clsValue = sessionValue;
            this.metrics.cls = clsValue;
          }
        }
      }
    });
    observer.observe({ type: "layout-shift", buffered: true });
  }

  // ── INP: 交互到下一帧绘制延迟 ────────────────
  _observeINP() {
    const interactions = [];
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.interactionId) {
          interactions.push(entry.duration);
        }
      }
      // INP = P98 延迟
      if (interactions.length > 0) {
        interactions.sort((a, b) => b - a);
        const idx = Math.floor(interactions.length * 0.02);
        this.metrics.inp = interactions[idx] || interactions[0];
      }
    });
    observer.observe({ type: "event", buffered: true, durationThreshold: 16 });
  }

  // ── Long Tasks: 长任务检测 ────────────────────
  _observeLongTasks() {
    this.metrics.longTasks = [];
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.metrics.longTasks.push({
          duration: entry.duration,
          startTime: entry.startTime,
        });
      }
    });
    observer.observe({ type: "longtask", buffered: true });
  }

  // ── 自定义打点 API ────────────────────────────
  mark(name) {
    this.customMarks[name] = performance.now();
  }

  measure(name, startMark, endMark) {
    const start = this.customMarks[startMark];
    const end = endMark ? this.customMarks[endMark] : performance.now();
    return { name, duration: end - start };
  }
}
```

> **本质洞察**：性能监控的核心认识是 —— **用户体验不是一个数字，而是一个分布**。单看平均值毫无意义，P75/P90/P99 才能揭示真相。LCP 的均值 2 秒看起来不错，但如果 P99 是 15 秒，意味着每 100 个用户就有 1 个在等待 15 秒。**性能优化不是优化平均值，而是压缩长尾**。

---

### 3.7.3 埋点 SDK 与稳定性设计 ⭐⭐⭐

**要求：** 构建一个兼顾灵活性与上报稳定性的埋点数据采集引擎。

- **设计要求：**
  - **采集策略选择**：对比研究"声明式埋点"与"手动注入式埋点"的架构实现。
  - **自动化曝光检测**：基于 `IntersectionObserver` 的高性能元素可见度判定。
  - **上报稳定性保障**：
    - 优先使用 `navigator.sendBeacon` 解决页面卸载时的上报丢失。
    - 批量聚合上报策略，平衡 HTTP 请求频率与实时性。
    - 离线存储机制：利用 `IndexedDB` 暂存弱网环境下的数据。

#### 1. 埋点采集引擎

```javascript
// ─────────────────────────────────────────────────
//  TrackerSDK — 埋点采集与上报引擎
// ─────────────────────────────────────────────────

class TrackerSDK {
  constructor(config) {
    this.endpoint = config.endpoint;
    this.appId = config.appId;
    this.buffer = []; // 发送缓冲区
    this.flushInterval = config.flushInterval || 5000;
    this.maxBufferSize = config.maxBuffer || 20;
    this.globalProps = {}; // 全局属性（uid, session）

    this._startAutoFlush();
    this._bindPageUnload();
  }

  // ── 手动埋点 ──────────────────────────────────
  track(eventName, properties = {}) {
    const event = {
      event: eventName,
      appId: this.appId,
      timestamp: Date.now(),
      url: location.href,
      ...this.globalProps,
      properties,
    };
    this.buffer.push(event);

    // 缓冲区满，立即发送
    if (this.buffer.length >= this.maxBufferSize) {
      this.flush();
    }
  }

  // ── 声明式埋点：基于 data-* 属性自动采集 ──────
  enableAutoTrack() {
    document.addEventListener(
      "click",
      (e) => {
        const target = e.target.closest("[data-track]");
        if (!target) return;

        this.track(target.dataset.track, {
          trackLabel: target.dataset.trackLabel,
          trackValue: target.dataset.trackValue,
        });
      },
      true,
    );
  }

  // ── 自动曝光检测 ──────────────────────────────
  observeExposure(selector, eventName) {
    const observed = new WeakSet(); // 防止重复上报

    const io = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !observed.has(entry.target)) {
            observed.add(entry.target);
            this.track(eventName, {
              elementId: entry.target.id,
              elementText: entry.target.textContent?.slice(0, 30),
            });
          }
        });
      },
      { threshold: 0.5 }, // 50% 可见才算曝光
    );

    document.querySelectorAll(selector).forEach((el) => io.observe(el));
    return io; // 返回以便 disconnect
  }

  // ── 批量上报 ──────────────────────────────────
  flush() {
    if (this.buffer.length === 0) return;

    const batch = this.buffer.splice(0);
    const payload = JSON.stringify(batch);

    // 优先 sendBeacon（非阻塞，页面卸载安全）
    const sent = navigator.sendBeacon(this.endpoint, payload);

    if (!sent) {
      // 降级：存入 IndexedDB 留待恢复
      this._saveToOfflineStore(batch);
    }
  }

  // ── 离线兜底 ──────────────────────────────────
  async _saveToOfflineStore(events) {
    const db = await this._openDB();
    const tx = db.transaction("events", "readwrite");
    const store = tx.objectStore("events");
    events.forEach((e) => store.add(e));
  }

  async _retryOfflineEvents() {
    const db = await this._openDB();
    const tx = db.transaction("events", "readonly");
    const store = tx.objectStore("events");
    const allEvents = await store.getAll();

    if (allEvents.length > 0) {
      const payload = JSON.stringify(allEvents);
      const sent = navigator.sendBeacon(this.endpoint, payload);
      if (sent) {
        // 清除已发送的离线数据
        const clearTx = db.transaction("events", "readwrite");
        clearTx.objectStore("events").clear();
      }
    }
  }

  _openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open("TrackerOffline", 1);
      request.onupgradeneeded = () => {
        request.result.createObjectStore("events", { autoIncrement: true });
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  // ── 页面卸载时兜底发送 ────────────────────────
  _bindPageUnload() {
    window.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        this.flush();
      }
    });
  }

  _startAutoFlush() {
    setInterval(() => this.flush(), this.flushInterval);
    // 页面恢复时补发离线数据
    this._retryOfflineEvents();
  }
}
```

> **本质洞察**：埋点 SDK 的三层稳定性架构是 **「内存缓冲 → sendBeacon → IndexedDB」**。正常情况下数据在内存缓冲区批量发送（减少请求频率）；页面关闭时用 sendBeacon 做最后一搏（浏览器保证在后台完成发送）；弱网或失败时降级到 IndexedDB 持久化，等下次打开页面时补发。这三层构成了一个 **「无丢失上报管线」**，其设计思想与消息队列的持久化机制（内存 → WAL → 磁盘）完全同构。

---

## 质量指标

- **自愈性**：监控 SDK 本身是否会因为自身代码缺陷导致用户业务崩溃。
- **采集损耗**：监控逻辑对主线程 (Main Thread) 性能的侵入性评价。
- **数据准确性**：对移动端、弱网及极端环境下的上报成功率（P99）。
