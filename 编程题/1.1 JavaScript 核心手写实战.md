<!--
- [INPUT]: JavaScript 原型链、this 机制、闭包、递归、复杂对象处理
- [OUTPUT]: JavaScript 核心机制的手写实现与原理解析
- [POS]: 编程题/ 模块的基础专题，夯实语言底层认知
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.1 JavaScript 核心手写实战

在前端进阶的道路上，"手写实现"不仅是面试的必考项，更是深入理解语言规范（ECMAScript）的唯一捷径。**手写的本质是：拆解"语法糖"与"内置引擎"的黑盒，用最基础的逻辑复现语言的高级特性。**

---

### 1.1.1 原型与继承 (Prototype & Inheritance)

**现象**：JavaScript 对象可以访问不在自身属性上的方法（如 `toString`）。
**本质**：通过 `__proto__` 构成的单向链表进行属性查找。

| 题目                   | 难度 | 优先级 | 考察点                                     |
| :--------------------- | :--- | :----- | :----------------------------------------- |
| **new 操作符实现**     | ⭐⭐ | 必会   | 原型链关联、构造函数执行、返回对象判定     |
| **instanceof 实现**    | ⭐⭐ | 必会   | 递归或循环查找原型链 `__proto__`           |
| **Object.create 实现** | ⭐⭐ | 必会   | 临时构造函数法实现原型继承                 |
| **寄生组合继承**       | ⭐⭐ | 必会   | 组合继承与原型继承的终极融合，避开二次调用 |

#### 1. new 操作符实现

`new` 做了四件事：创建空对象 → 链接原型 → 执行构造函数 → 判断返回值。

```javascript
// ─────────────────────────────────────────────────
//  myNew — 手写 new 操作符
// ─────────────────────────────────────────────────

function myNew(Constructor, ...args) {
  // 1. 创建空对象，将其原型指向构造函数的 prototype
  const obj = Object.create(Constructor.prototype);

  // 2. 以新对象为 this 执行构造函数
  const result = Constructor.apply(obj, args);

  // 3. 如果构造函数返回了一个对象，则使用该对象；否则返回新创建的对象
  //    这是规范行为：new Foo() 如果 Foo 返回一个 object/function，就用它
  return result !== null &&
    (typeof result === "object" || typeof result === "function")
    ? result
    : obj;
}

// ── 验证 ──
function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype.greet = function () {
  return `I'm ${this.name}`;
};

const p = myNew(Person, "Linus", 55);
console.log(p.name); // 'Linus'
console.log(p.greet()); // "I'm Linus"
console.log(p instanceof Person); // true
```

> **本质洞察**：`new` 的第三步是最容易被忽略的——构造函数如果显式 `return {}` 会劫持结果。这不是 bug，是语言设计给"工厂模式"留的后门。

#### 2. instanceof 实现

沿着 `__proto__` 链向上爬，直到找到目标 `prototype` 或到达链终止（`null`）。

```javascript
// ─────────────────────────────────────────────────
//  myInstanceof — 手写 instanceof
// ─────────────────────────────────────────────────

function myInstanceof(instance, Constructor) {
  // 原始类型直接返回 false
  if (
    instance === null ||
    (typeof instance !== "object" && typeof instance !== "function")
  ) {
    return false;
  }

  let proto = Object.getPrototypeOf(instance);

  while (proto !== null) {
    if (proto === Constructor.prototype) return true;
    proto = Object.getPrototypeOf(proto); // 沿链上爬
  }

  return false; // 到达 null，链终止
}

// ── 验证 ──
console.log(myInstanceof(p, Person)); // true
console.log(myInstanceof(p, Object)); // true（原型链末端是 Object.prototype）
console.log(myInstanceof([], Array)); // true
console.log(myInstanceof("str", String)); // false（原始类型）
```

> **本质洞察**：`instanceof` 不检查"谁创建了你"，它检查的是"你的原型链上有没有我"。所以 `[] instanceof Object` 为 `true`——数组是对象的子民。

#### 3. Object.create 实现

用一个空构造函数做桥梁，将新对象的原型链指向目标对象。

```javascript
// ─────────────────────────────────────────────────
//  myObjectCreate — 手写 Object.create
// ─────────────────────────────────────────────────

function myObjectCreate(proto, propertyDescriptors) {
  if (
    proto !== null &&
    typeof proto !== "object" &&
    typeof proto !== "function"
  ) {
    throw new TypeError("Object prototype may only be an Object or null");
  }

  // 临时构造函数法：唯一目的是设置 prototype
  function F() {}
  F.prototype = proto;
  const obj = new F();

  // 如果传入了属性描述符，用 defineProperties 添加
  if (propertyDescriptors !== undefined) {
    Object.defineProperties(obj, propertyDescriptors);
  }

  // 处理 proto === null 的边界（纯净字典对象，无原型）
  if (proto === null) {
    Object.setPrototypeOf(obj, null);
  }

  return obj;
}

// ── 验证 ──
const base = {
  type: "base",
  hello() {
    return `hello from ${this.type}`;
  },
};
const child = myObjectCreate(base);
child.type = "child";
console.log(child.hello()); // "hello from child"
console.log(child instanceof base.constructor); // 继承关系成立

const nullProto = myObjectCreate(null);
console.log(Object.getPrototypeOf(nullProto)); // null（纯净字典）
```

> **本质洞察**：`Object.create(null)` 创建的是一个"无祖先"的纯净对象——没有 `toString`、没有 `hasOwnProperty`，干净到连 `{}` 都做不到。这是创建安全字典（如 HTTP header map）的唯一方式。

#### 4. 寄生组合继承

继承的终极形态——只调用一次父构造函数，完美链接原型。

```javascript
// ─────────────────────────────────────────────────
//  寄生组合继承 — 经典继承的终极形态
// ─────────────────────────────────────────────────

function inheritPrototype(Child, Parent) {
  // 关键：用 Object.create 而非 new Parent()
  // 避免二次调用父构造函数，不会产生多余的实例属性
  const prototype = Object.create(Parent.prototype);
  prototype.constructor = Child; // 修复 constructor 指向
  Child.prototype = prototype;
}

// ── 使用示例 ──
function Animal(name) {
  this.name = name;
  this.traits = ["living"]; // 引用类型属性，各实例独立
}
Animal.prototype.speak = function () {
  return `${this.name} makes a noise.`;
};

function Dog(name, breed) {
  Animal.call(this, name); // 借用构造函数：继承实例属性（只调用一次）
  this.breed = breed;
}
inheritPrototype(Dog, Animal); // 寄生式原型继承：继承方法

Dog.prototype.bark = function () {
  return `${this.name} barks!`;
};

// ── 验证 ──
const d1 = new Dog("Rex", "Husky");
const d2 = new Dog("Max", "Poodle");

console.log(d1.speak()); // "Rex makes a noise."
console.log(d1.bark()); // "Rex barks!"
console.log(d1 instanceof Dog); // true
console.log(d1 instanceof Animal); // true

d1.traits.push("loyal");
console.log(d1.traits); // ['living', 'loyal']
console.log(d2.traits); // ['living'] ← 引用类型不共享，完美隔离
```

**继承方案对比**：

| 方案             | 父构造函数调用次数 | 引用属性隔离 | 原型方法可继承 | 问题                   |
| ---------------- | :----------------: | :----------: | :------------: | ---------------------- |
| 原型链继承       |         1          |   ❌ 共享    |       ✅       | 引用类型被所有实例共享 |
| 借用构造函数     |         1          |   ✅ 隔离    |       ❌       | 方法在每个实例上重建   |
| 组合继承         |       **2**        |   ✅ 隔离    |       ✅       | 父构造函数被调用两次   |
| **寄生组合继承** |       **1**        |   ✅ 隔离    |       ✅       | **无**                 |

**哲学启示**：继承的本质是**"契约的传递"**。寄生组合继承通过切断构造函数的直接关联，实现了属性与方法的隔离复用。

---

### 1.1.2 函数增强 (Function Enhancements)

**现象**：`this` 的指向因调用方式而异，函数可以被拆解或组合。
**本质**：利用**闭包**持久化上下文，通过**高阶函数**实现逻辑转换。

| 题目                    | 难度 | 优先级 | 考察点                                    |
| :---------------------- | :--- | :----- | :---------------------------------------- |
| **call/apply 实现**     | ⭐⭐ | 必会   | `this` 隐式绑定（挂载到对象执行）         |
| **bind 实现（完整版）** | ⭐⭐ | 必会   | `this` 预留、柯里化支持、`new` 实例化兼容 |
| **函数柯里化 (Curry)**  | ⭐⭐ | 必会   | 闭包应用、递归参数收集、延迟执行          |
| **函数组合 (Compose)**  | ⭐⭐ | 掌握   | 从右向左的函数管道（Redux 原理）          |

#### 1. call/apply 实现

核心技巧：把函数临时挂载到目标对象上执行，利用 `obj.fn()` 的隐式绑定让 `this` 指向 `obj`。

```javascript
// ─────────────────────────────────────────────────
//  myCall / myApply — 手写 call 和 apply
// ─────────────────────────────────────────────────

Function.prototype.myCall = function (context, ...args) {
  // 1. context 为 null/undefined 时指向 globalThis
  context =
    context !== null && context !== undefined ? Object(context) : globalThis;

  // 2. 用 Symbol 避免属性名冲突
  const fnKey = Symbol("fn");
  context[fnKey] = this;

  // 3. 隐式绑定：obj.fn() → this 指向 obj
  const result = context[fnKey](...args);

  // 4. 清理临时属性
  delete context[fnKey];
  return result;
};

Function.prototype.myApply = function (context, argsArray = []) {
  context =
    context !== null && context !== undefined ? Object(context) : globalThis;
  const fnKey = Symbol("fn");
  context[fnKey] = this;
  const result = context[fnKey](...argsArray);
  delete context[fnKey];
  return result;
};

// ── 验证 ──
function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

const user = { name: "Linus" };
console.log(greet.myCall(user, "Hello", "!")); // "Hello, Linus!"
console.log(greet.myApply(user, ["Hi", "."])); // "Hi, Linus."
```

> **本质洞察**：`call` 和 `apply` 的全部魔法就是一个 `this` 的隐式绑定规则——`obj.fn()` 中的 `this` 永远指向 `.` 前面的对象。我们只是临时把函数挂上去，执行完再删掉。

#### 2. bind 实现（完整版）

`bind` 是 `call` 的惰性版本，但还要兼容 `new`——这是最容易被忽略的边界。

```javascript
// ─────────────────────────────────────────────────
//  myBind — 完整版 bind（支持柯里化 + new 兼容）
// ─────────────────────────────────────────────────

Function.prototype.myBind = function (context, ...outerArgs) {
  const originalFn = this;

  // 返回一个新函数（闭包持久化 context 和预置参数）
  function boundFn(...innerArgs) {
    // 关键判断：如果 boundFn 被 new 调用，this 是 boundFn 的实例
    // 此时应忽略 bind 的 context，让 this 指向新实例
    return originalFn.apply(
      this instanceof boundFn ? this : context,
      [...outerArgs, ...innerArgs], // 柯里化：合并两次参数
    );
  }

  // 继承原函数的原型，保证 new boundFn() 的实例能访问原型方法
  if (originalFn.prototype) {
    boundFn.prototype = Object.create(originalFn.prototype);
  }

  return boundFn;
};

// ── 验证 ──
function Point(x, y) {
  this.x = x;
  this.y = y;
}
Point.prototype.toString = function () {
  return `(${this.x}, ${this.y})`;
};

// 普通绑定 + 柯里化
const PointAt0 = Point.myBind(null, 0); // x 固定为 0
const p1 = new PointAt0(5);
console.log(p1.toString()); // "(0, 5)"
console.log(p1 instanceof Point); // true ← new 兼容

// this 绑定
const obj = { name: "test" };
function getName() {
  return this.name;
}
const bound = getName.myBind(obj);
console.log(bound()); // "test"
```

> **深度洞察**：`bind` 的实现是**闭包与原型链的交汇点**。它不仅要锁定 `this`，还要保证返回的函数在作为构造函数时，原型链不丢失。`this instanceof boundFn` 这行代码，就是在问："你是被 `new` 出来的，还是被普通调用的？"

#### 3. 函数柯里化 (Curry)

将 `f(a, b, c)` 转换为 `f(a)(b)(c)` 的过程——参数够了就执行，不够就继续收集。

```javascript
// ─────────────────────────────────────────────────
//  curry — 通用柯里化（支持任意参数个数）
// ─────────────────────────────────────────────────

function curry(fn) {
  return function curried(...args) {
    // 参数足够 → 立即执行
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    // 参数不够 → 返回新函数继续收集（闭包持久化已有参数）
    return function (...moreArgs) {
      return curried.apply(this, [...args, ...moreArgs]);
    };
  };
}

// ── 验证 ──
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1, 2, 3)); // 6  完整调用
console.log(curriedAdd(1)(2)(3)); // 6  逐一调用
console.log(curriedAdd(1, 2)(3)); // 6  部分应用
console.log(curriedAdd(1)(2, 3)); // 6  混合调用

// 实际应用：创建专用函数
const log = curry((level, timestamp, message) => {
  console.log(`[${level}] ${timestamp}: ${message}`);
});

const errorLog = log("ERROR"); // 固定级别
const todayErrorLog = errorLog("2026-02-17"); // 固定日期
todayErrorLog("Server crashed"); // 只需传消息
```

> **本质洞察**：柯里化的核心是 `fn.length`——函数声明时的形参个数。每次调用都在问同一个问题："攒够了吗？"如果够了，执行；如果不够，再返回一个闭包继续等。

#### 4. 函数组合 (Compose)

从右向左执行函数管道——Redux `compose` 的核心。

```javascript
// ─────────────────────────────────────────────────
//  compose — 函数组合（从右向左执行）
// ─────────────────────────────────────────────────

function compose(...fns) {
  // 边界：零个函数返回恒等函数，一个函数返回自身
  if (fns.length === 0) return (arg) => arg;
  if (fns.length === 1) return fns[0];

  // reduce 从左到右折叠，但执行时从右到左
  // f(g(h(x))) 的执行顺序：h → g → f
  return fns.reduce((composed, current) => {
    return (...args) => composed(current(...args));
  });
}

// 反向版：从左到右（也叫 pipe）
function pipe(...fns) {
  return compose(...fns.reverse());
}

// ── 验证 ──
const add10 = (x) => x + 10;
const multiply2 = (x) => x * 2;
const toString = (x) => `Result: ${x}`;

// compose：从右到左 → toString(multiply2(add10(5)))
const transform = compose(toString, multiply2, add10);
console.log(transform(5)); // "Result: 30"  (5+10=15, 15*2=30)

// pipe：从左到右（更符合人类阅读习惯）
const pipeline = pipe(add10, multiply2, toString);
console.log(pipeline(5)); // "Result: 30"

// Redux 中间件示例
const applyMiddleware = compose(withLogging, withAuth, withErrorHandling);
```

> **本质洞察**：`compose` 的精妙在于 `reduce` 的一步：`(composed, current) => (...args) => composed(current(...args))`。它把 N 个单一职责的函数折叠成一个函数链——这就是 Unix 管道哲学在 JavaScript 中的复现。

---

### 1.1.3 深拷贝与类型处理 (Cloning & Types)

**现象**：简单赋值会导致对象引用共享，修改 A 影响 B。
**本质**：递归遍历对象树，重建独立的内存空间。

#### 深拷贝 (Complete Edition) 必须处理的边界：

1.  **循环引用**：利用 `WeakMap` 存储已访问对象，解决栈溢出。
2.  **特殊对象类型**：
    - **可克隆类**：`Date`、`RegExp`、`Map`、`Set`、`Error`。
    - **不可克隆/特殊类**：`Function`（通常不克隆）、`Symbol`。
3.  **属性描述符**：是否需要保留 `enumerable`、`configurable`？
4.  **原型链保留**：克隆对象是否应继承原对象的原型？

#### 完整实现

```javascript
// ─────────────────────────────────────────────────
//  deepClone — 生产级深拷贝（处理所有边界）
// ─────────────────────────────────────────────────

function deepClone(source, cache = new WeakMap()) {
  // ── 基本类型 & null：直接返回 ──
  if (source === null || typeof source !== "object") {
    return source;
  }

  // ── 循环引用检测：已访问过则直接返回缓存 ──
  if (cache.has(source)) {
    return cache.get(source);
  }

  // ── 特殊对象类型处理 ──
  let cloned;

  // Date
  if (source instanceof Date) {
    return new Date(source.getTime());
  }

  // RegExp
  if (source instanceof RegExp) {
    return new RegExp(source.source, source.flags);
  }

  // Error
  if (source instanceof Error) {
    const err = new source.constructor(source.message);
    err.stack = source.stack;
    return err;
  }

  // Map
  if (source instanceof Map) {
    cloned = new Map();
    cache.set(source, cloned); // 先缓存再递归，防止循环引用
    source.forEach((val, key) => {
      cloned.set(deepClone(key, cache), deepClone(val, cache));
    });
    return cloned;
  }

  // Set
  if (source instanceof Set) {
    cloned = new Set();
    cache.set(source, cloned);
    source.forEach((val) => {
      cloned.add(deepClone(val, cache));
    });
    return cloned;
  }

  // ── 普通对象 & 数组 ──
  cloned = Array.isArray(source)
    ? []
    : Object.create(Object.getPrototypeOf(source));
  cache.set(source, cloned);

  // 遍历所有自有属性（包括 Symbol key 和不可枚举属性）
  const keys = [
    ...Object.getOwnPropertyNames(source),
    ...Object.getOwnPropertySymbols(source),
  ];

  for (const key of keys) {
    const descriptor = Object.getOwnPropertyDescriptor(source, key);
    if (descriptor.value !== undefined) {
      // 数据属性：递归克隆值
      Object.defineProperty(cloned, key, {
        ...descriptor,
        value: deepClone(descriptor.value, cache),
      });
    } else {
      // 访问器属性（getter/setter）：直接复制描述符
      Object.defineProperty(cloned, key, descriptor);
    }
  }

  return cloned;
}

// ── 验证 ──

// 1. 循环引用
const objA = { name: "A" };
const objB = { name: "B", ref: objA };
objA.ref = objB; // 循环引用 A → B → A
const clonedA = deepClone(objA);
console.log(clonedA.ref.ref === clonedA); // true（循环引用被正确重建）
console.log(clonedA !== objA); // true（不同引用）

// 2. 特殊类型
const complex = {
  date: new Date("2026-02-17"),
  regex: /hello/gi,
  map: new Map([["key", { nested: true }]]),
  set: new Set([1, 2, 3]),
  [Symbol("id")]: 42,
};
const cloned = deepClone(complex);
console.log(cloned.date.getTime() === complex.date.getTime()); // true
console.log(cloned.date !== complex.date); // true（独立实例）
console.log(cloned.regex.source === "hello"); // true
console.log(cloned.map.get("key").nested); // true
console.log(cloned.map.get("key") !== complex.map.get("key")); // true（深克隆）

// 3. 原型链保留
function Foo() {
  this.x = 1;
}
Foo.prototype.getX = function () {
  return this.x;
};
const foo = new Foo();
const clonedFoo = deepClone(foo);
console.log(clonedFoo.getX()); // 1
console.log(clonedFoo instanceof Foo); // true（原型链保留）
```

**深拷贝方案对比**：

| 方案                           | 循环引用 | Date/RegExp | Map/Set | Symbol Key | 原型链  | 性能  |
| ------------------------------ | :------: | :---------: | :-----: | :--------: | :-----: | ----- |
| `JSON.parse(JSON.stringify())` | ❌ 崩溃  |   ❌ 丢失   | ❌ 丢失 |  ❌ 丢失   | ❌ 丢失 | 🟢 快 |
| `structuredClone()`            |    ✅    |     ✅      |   ✅    |  ❌ 丢失   | ❌ 丢失 | 🟢 快 |
| `lodash.cloneDeep`             |    ✅    |     ✅      |   ✅    |     ✅     |   ✅    | 🟡 中 |
| **手写 deepClone**             |    ✅    |     ✅      |   ✅    |     ✅     |   ✅    | 🟡 中 |

**哲学启示**：深拷贝是**"灵魂的克隆"**。但在工程实践中，应警惕"过度克隆"，利用不可变数据库（Immutable.js）或结构共享（Immer）往往比纯粹的深拷贝更优雅。

> `JSON.parse(JSON.stringify())` 能活到今天，不是因为它好，是因为 90% 的业务场景里你根本不需要考虑那些边界。但面试官考的不是你会不会用它，而是你**知不知道它在哪里会死**。

---

## 质量指标

- **幂等性**：多次执行结果是否符合预期。
- **健壮性**：空值（null/undefined）及异常类型的防御性编程。
- **简洁性**：能否用最少的行数实现规范的核心逻辑。
