<!--
- [INPUT]: JavaScript 原型链、this 机制、闭包、递归、复杂对象处理
- [OUTPUT]: JavaScript 核心机制的手写实现与原理解析
- [POS]: 编程题/ 模块的基础专题，夯实语言底层认知
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 1.1 JavaScript 核心手写实战

在前端进阶的道路上，“手写实现”不仅是面试的必考项，更是深入理解语言规范（ECMAScript）的唯一捷径。**手写的本质是：拆解“语法糖”与“内置引擎”的黑盒，用最基础的逻辑复现语言的高级特性。**

---

### 1.1.1 原型与继承 (Prototype & Inheritance)

**现象**：JavaScript 对象可以访问不在自身属性上的方法（如 `toString`）。
**本质**：通过 `__proto__` 构成的单向链表进行属性查找。

| 题目 | 难度 | 优先级 | 考察点 |
| :--- | :--- | :--- | :--- |
| **new 操作符实现** | ⭐⭐ | 必会 | 原型链关联、构造函数执行、返回对象判定 |
| **instanceof 实现** | ⭐⭐ | 必会 | 递归或循环查找原型链 `__proto__` |
| **Object.create 实现** | ⭐⭐ | 必会 | 临时构造函数法实现原型继承 |
| **寄生组合继承** | ⭐⭐ | 必会 | 组合继承与原型继承的终极融合，避开二次调用 |

**哲学启示**：继承的本质是**“契约的传递”**。寄生组合继承通过切断构造函数的直接关联，实现了属性与方法的隔离复用。

---

### 1.1.2 函数增强 (Function Enhancements)

**现象**：`this` 的指向因调用方式而异，函数可以被拆解或组合。
**本质**：利用**闭包**持久化上下文，通过**高阶函数**实现逻辑转换。

| 题目 | 难度 | 优先级 | 考察点 |
| :--- | :--- | :--- | :--- |
| **call/apply 实现** | ⭐⭐ | 必会 | `this` 隐式绑定（挂载到对象执行） |
| **bind 实现（完整版）** | ⭐⭐ | 必会 | `this` 预留、柯里化支持、`new` 实例化兼容 |
| **函数柯里化 (Curry)** | ⭐⭐ | 必会 | 闭包应用、递归参数收集、延迟执行 |
| **函数组合 (Compose)** | ⭐⭐ | 掌握 | 从右向左的函数管道（Redux 原理） |

**深度洞察**：`bind` 的实现是闭包与原型链的交汇点。它不仅要锁定 `this`，还要保证返回的函数在作为构造函数时，原型链不丢失。

---

### 1.1.3 深拷贝与类型处理 (Cloning & Types)

**现象**：简单赋值会导致对象引用共享，修改 A 影响 B。
**本质**：递归遍历对象树，重建独立的内存空间。

#### 深拷贝 (Complete Edition) 必须处理的边界：
1.  **循环引用**：利用 `WeakMap` 存储已访问对象，解决栈溢出。
2.  **特殊对象类型**：
    *   **可克隆类**：`Date`、`RegExp`、`Map`、`Set`、`Error`。
    *   **不可克隆/特殊类**：`Function`（通常不克隆）、`Symbol`。
3.  **属性描述符**：是否需要保留 `enumerable`、`configurable`？
4.  **原型链保留**：克隆对象是否应继承原对象的原型？

**哲学启示**：深拷贝是**“灵魂的克隆”**。但在工程实践中，应警惕“过度克隆”，利用不可变数据库（Immutable.js）或结构共享（Immer）往往比纯粹的深拷贝更优雅。

---

## 质量指标

*   **幂等性**：多次执行结果是否符合预期。
*   **健壮性**：空值（null/undefined）及异常类型的防御性编程。
*   **简洁性**：能否用最少的行数实现规范的核心逻辑。
