<!--
- [INPUT]: 前端大数据渲染、长列表优化、多线程、时间分片
- [OUTPUT]: 针对 10 万级数据的渲染与计算性能优化方案集
- [POS]: 编程题/ 模块的核心专题，解决前端性能瓶颈与渲染限制
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 2.3 大数据与性能场景深度剖析

在前端应用进入"桌面级"或"工业级"时代的背景下，处理大数据量（10万级以上）不再是可选项，而是核心竞争力的体现。**性能优化的本质是：如何在受限的硬件资源（单线程、有限内存）中，通过时间分片、空间置换、按需渲染来模拟"无限能力"。**

---

### 2.3.1 虚拟滚动 (Virtual Scroll) ⭐⭐⭐⭐

**现象**：DOM 节点过多会导致浏览器重绘重排极其缓慢，甚至内存崩溃。
**本质**：仅渲染可视区域（Viewport）内的 DOM，通过 `Transform` 或 `Padding` 模拟滚动条真实高度。

#### 实现策略对比

| 类型               | 难度       | 核心思路                                 | 挑战                 |
| :----------------- | :--------- | :--------------------------------------- | :------------------- |
| **定高虚拟列表**   | ⭐⭐⭐     | `scrollTop / itemHeight` 计算起止索引    | 简单稳定             |
| **不定高虚拟列表** | ⭐⭐⭐⭐⭐ | **预估高度 + 缓存高度 + 动态修正偏移量** | 滚动条跳动、频繁测量 |
| **虚拟表格**       | ⭐⭐⭐⭐   | **横向 + 纵向双轴虚拟化**                | 固定头/列的同步逻辑  |

**关键挑战**：

1.  **Buffer 区域设计**：预留 1-2 屏缓冲区，防止滚动过快导致的瞬时白屏。
2.  **搜索跳转**：在大数据量下，如何精准定位到未渲染节点的 `scrollTop`。
3.  **动态加载**：结合 IntersectionObserver 实现滚动加载（Infinite Scroll）。

#### 代码实现：定高虚拟列表

> 哲学本质：**空间换时间的极致——不渲染看不见的东西。** 10 万个 DOM 节点和 20 个 DOM 节点对用户来说毫无区别，但对浏览器来说是天壤之别。

```typescript
/**
 * FixedHeightVirtualList — 定高虚拟列表核心引擎
 *
 * 架构三要素：
 * 1. 外层容器 (container) — 固定高度，overflow:auto，承载真实滚动
 * 2. 占位元素 (phantom)  — 撑开总高度，欺骗滚动条
 * 3. 渲染区域 (content)  — transform 偏移，只渲染可见项 + 缓冲区
 */

interface VirtualListConfig {
  container: HTMLElement;
  itemHeight: number; // 每项固定高度
  totalItems: number; // 总数据量
  bufferCount?: number; // 上下缓冲区项数
  renderItem: (index: number) => HTMLElement;
}

class FixedHeightVirtualList {
  private container: HTMLElement;
  private phantom: HTMLElement;
  private content: HTMLElement;
  private itemHeight: number;
  private totalItems: number;
  private bufferCount: number;
  private renderItem: (index: number) => HTMLElement;
  private visibleCount: number;

  constructor(config: VirtualListConfig) {
    this.container = config.container;
    this.itemHeight = config.itemHeight;
    this.totalItems = config.totalItems;
    this.bufferCount = config.bufferCount ?? 5;
    this.renderItem = config.renderItem;

    // ---- 计算可见项数 ----
    this.visibleCount = Math.ceil(
      this.container.clientHeight / this.itemHeight,
    );

    // ---- 构造 DOM 骨架 ----
    this.phantom = document.createElement("div");
    this.phantom.style.height = `${this.totalItems * this.itemHeight}px`;

    this.content = document.createElement("div");
    this.content.style.position = "relative";

    this.container.style.overflow = "auto";
    this.container.style.position = "relative";
    this.container.appendChild(this.phantom);
    this.container.appendChild(this.content);

    // ---- 事件绑定 ----
    this.container.addEventListener("scroll", this.onScroll);
    this.render(0);
  }

  /**
   * 核心算法：scrollTop → startIndex → 渲染
   *
   * 计算公式极简，这就是定高的优势：
   *   startIndex = floor(scrollTop / itemHeight) - buffer
   *   endIndex   = startIndex + visibleCount + 2 * buffer
   */
  private onScroll = () => {
    const scrollTop = this.container.scrollTop;
    const startIndex = Math.floor(scrollTop / this.itemHeight);
    this.render(startIndex);
  };

  private render(rawStart: number) {
    // ---- 计算安全边界 ----
    const start = Math.max(0, rawStart - this.bufferCount);
    const end = Math.min(
      this.totalItems,
      rawStart + this.visibleCount + this.bufferCount,
    );

    // ---- 偏移量：将 content 平移到正确位置 ----
    const offsetY = start * this.itemHeight;
    this.content.style.transform = `translateY(${offsetY}px)`;

    // ---- 清空并重绘可见区域 ----
    this.content.innerHTML = "";
    for (let i = start; i < end; i++) {
      const el = this.renderItem(i);
      el.style.height = `${this.itemHeight}px`;
      this.content.appendChild(el);
    }
  }

  /** 销毁实例，释放事件 */
  destroy() {
    this.container.removeEventListener("scroll", this.onScroll);
    this.content.remove();
    this.phantom.remove();
  }
}

// ========== 使用示例 ==========
const list = new FixedHeightVirtualList({
  container: document.getElementById("list-container")!,
  itemHeight: 50,
  totalItems: 100_000,
  bufferCount: 5,
  renderItem(index) {
    const div = document.createElement("div");
    div.className = "list-item";
    div.textContent = `Item #${index}`;
    return div;
  },
});
```

#### 代码实现：不定高虚拟列表

> 难度跃升的根源：**没有固定高度，就没有数学确定性。** 必须引入"预估-测量-修正"三阶段循环。

```typescript
/**
 * DynamicHeightVirtualList — 不定高虚拟列表
 *
 * 核心策略：
 * 1. 首次渲染使用 estimatedHeight 预估每项高度
 * 2. 渲染后通过 ResizeObserver 实测，缓存真实高度
 * 3. 用前缀和数组做二分查找，精确定位 scrollTop → startIndex
 */

interface PositionCache {
  index: number;
  top: number;
  bottom: number;
  height: number;
}

class DynamicHeightVirtualList {
  private container: HTMLElement;
  private content: HTMLElement;
  private phantom: HTMLElement;
  private estimatedHeight: number;
  private positions: PositionCache[] = [];
  private totalItems: number;
  private renderItem: (index: number) => HTMLElement;
  private observer: ResizeObserver;

  constructor(config: {
    container: HTMLElement;
    estimatedHeight: number;
    totalItems: number;
    renderItem: (index: number) => HTMLElement;
  }) {
    this.container = config.container;
    this.estimatedHeight = config.estimatedHeight;
    this.totalItems = config.totalItems;
    this.renderItem = config.renderItem;

    // ---- 初始化位置缓存（全部用预估值） ----
    this.initPositions();

    // ---- 构造 DOM ----
    this.phantom = document.createElement("div");
    this.updatePhantomHeight();

    this.content = document.createElement("div");
    this.content.style.position = "relative";

    this.container.style.overflow = "auto";
    this.container.appendChild(this.phantom);
    this.container.appendChild(this.content);

    // ---- ResizeObserver：渲染后修正真实高度 ----
    this.observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const el = entry.target as HTMLElement;
        const index = Number(el.dataset.index);
        const measuredHeight = entry.contentRect.height;

        if (this.positions[index].height !== measuredHeight) {
          this.updatePositionFrom(index, measuredHeight);
        }
      }
      this.updatePhantomHeight();
    });

    this.container.addEventListener("scroll", this.onScroll);
    this.renderRange(0);
  }

  /** 用预估高度初始化所有位置 */
  private initPositions() {
    this.positions = Array.from({ length: this.totalItems }, (_, i) => ({
      index: i,
      top: i * this.estimatedHeight,
      bottom: (i + 1) * this.estimatedHeight,
      height: this.estimatedHeight,
    }));
  }

  /** 从第 index 项开始，级联更新后续所有项的 top/bottom */
  private updatePositionFrom(index: number, newHeight: number) {
    this.positions[index].height = newHeight;
    this.positions[index].bottom = this.positions[index].top + newHeight;

    for (let i = index + 1; i < this.totalItems; i++) {
      this.positions[i].top = this.positions[i - 1].bottom;
      this.positions[i].bottom =
        this.positions[i].top + this.positions[i].height;
    }
  }

  private updatePhantomHeight() {
    const totalHeight = this.positions[this.totalItems - 1]?.bottom ?? 0;
    this.phantom.style.height = `${totalHeight}px`;
  }

  /**
   * 二分查找：scrollTop → startIndex
   *
   * positions 是有序数组（bottom 单调递增），
   * 找到第一个 bottom > scrollTop 的项即为起始项。
   */
  private findStartIndex(scrollTop: number): number {
    let low = 0;
    let high = this.totalItems - 1;

    while (low <= high) {
      const mid = (low + high) >>> 1;
      if (this.positions[mid].bottom <= scrollTop) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return low;
  }

  private onScroll = () => {
    const scrollTop = this.container.scrollTop;
    const startIndex = this.findStartIndex(scrollTop);
    this.renderRange(startIndex);
  };

  private renderRange(start: number) {
    const viewportHeight = this.container.clientHeight;
    const scrollTop = this.container.scrollTop;
    const buffer = 5;

    const safeStart = Math.max(0, start - buffer);
    let end = start;
    while (
      end < this.totalItems &&
      this.positions[end].top < scrollTop + viewportHeight
    ) {
      end++;
    }
    const safeEnd = Math.min(this.totalItems, end + buffer);

    // ---- 偏移 content 到起始项位置 ----
    this.content.style.transform = `translateY(${this.positions[safeStart].top}px)`;

    // ---- 渲染 + 观测 ----
    this.content.innerHTML = "";
    for (let i = safeStart; i < safeEnd; i++) {
      const el = this.renderItem(i);
      el.dataset.index = String(i);
      this.observer.observe(el);
      this.content.appendChild(el);
    }
  }

  destroy() {
    this.observer.disconnect();
    this.container.removeEventListener("scroll", this.onScroll);
  }
}
```

---

### 2.3.2 大数据表格复杂交互 ⭐⭐⭐⭐

**现象**：Excel 级别的表格，不仅要快，还要能像原生软件一样编辑、拖拽、合并。
**本质**：数据模型（Model）与渲染视图（View）的完全解耦。

#### 核心功能清单

- **布局增强**：固定首行/首列、单元格动态合并（Span）。
- **原子化编辑**：单个单元格进入编辑模式，不触发整表重绘。
- **高级筛选**：多维排序、模糊匹配、树形数据收纳。
- **极致交互**：区域选中（Selection）、拖拽排版（Drag & Drop）、Ctrl+C/V 剪切板同步。

#### 代码实现：高性能虚拟表格引擎

> 哲学本质：**Model 和 View 的彻底解耦——数据是真理，DOM 是谎言。** 表格的数据模型可以有百万行，但 DOM 永远只有屏幕上那几十个格子。

```typescript
/**
 * VirtualTable — 双轴虚拟化表格引擎
 *
 * 架构分层：
 * 1. DataModel     — 纯数据层，持有全量数据，负责排序/筛选/合并
 * 2. ViewportCalc  — 视口计算，决定当前渲染哪些行和列
 * 3. RenderEngine  — 渲染引擎，仅操作可见 DOM
 * 4. InteractionMgr — 交互管理，编辑/选区/剪切板
 */

// ================ 数据模型层 ================

type CellValue = string | number | boolean | null;
type SortDirection = "asc" | "desc" | "none";

interface ColumnDef {
  key: string;
  label: string;
  width: number;
  sortable?: boolean;
  editable?: boolean;
  fixed?: "left" | "right"; // 固定列
}

interface CellPosition {
  row: number;
  col: number;
}

interface SpanRule {
  row: number;
  col: number;
  rowSpan: number;
  colSpan: number;
}

class DataModel {
  private rawData: CellValue[][];
  private sortedIndices: number[]; // 排序后的索引映射
  private filterFn: ((row: CellValue[]) => boolean) | null = null;

  constructor(data: CellValue[][]) {
    this.rawData = data;
    this.sortedIndices = data.map((_, i) => i);
  }

  get rowCount() {
    return this.sortedIndices.length;
  }

  getCell(row: number, col: number): CellValue {
    return this.rawData[this.sortedIndices[row]][col];
  }

  setCell(row: number, col: number, value: CellValue) {
    this.rawData[this.sortedIndices[row]][col] = value;
  }

  /**
   * 排序：不移动原始数据，只重建索引映射
   *
   * 这是 "Model 不变，View 变" 的核心体现
   */
  sort(colIndex: number, direction: SortDirection) {
    if (direction === "none") {
      this.sortedIndices = this.rawData.map((_, i) => i);
      return;
    }

    const mul = direction === "asc" ? 1 : -1;
    this.sortedIndices.sort((a, b) => {
      const va = this.rawData[a][colIndex];
      const vb = this.rawData[b][colIndex];
      if (va == null) return 1;
      if (vb == null) return -1;
      return va < vb ? -mul : va > vb ? mul : 0;
    });
  }

  /** 筛选：同样只操作索引 */
  filter(fn: ((row: CellValue[]) => boolean) | null) {
    this.filterFn = fn;
    this.sortedIndices = this.rawData
      .map((row, i) => (!fn || fn(row) ? i : -1))
      .filter((i) => i !== -1);
  }
}

// ================ 视口计算层 ================

interface ViewportRange {
  startRow: number;
  endRow: number;
  startCol: number;
  endCol: number;
  offsetX: number;
  offsetY: number;
}

class ViewportCalc {
  constructor(
    private columns: ColumnDef[],
    private rowHeight: number,
    private viewportWidth: number,
    private viewportHeight: number,
    private buffer: number = 3,
  ) {}

  /** 根据 scrollTop/scrollLeft 计算可见区域 */
  calc(scrollTop: number, scrollLeft: number, rowCount: number): ViewportRange {
    // ---- 纵轴 ----
    const rawStartRow = Math.floor(scrollTop / this.rowHeight);
    const startRow = Math.max(0, rawStartRow - this.buffer);
    const visibleRows = Math.ceil(this.viewportHeight / this.rowHeight);
    const endRow = Math.min(rowCount, rawStartRow + visibleRows + this.buffer);

    // ---- 横轴：累加列宽 ----
    let accWidth = 0;
    let startCol = 0;
    let endCol = this.columns.length;

    for (let i = 0; i < this.columns.length; i++) {
      if (accWidth + this.columns[i].width < scrollLeft) {
        startCol = i;
      }
      accWidth += this.columns[i].width;
      if (accWidth > scrollLeft + this.viewportWidth) {
        endCol = i + 1;
        break;
      }
    }
    startCol = Math.max(0, startCol - this.buffer);
    endCol = Math.min(this.columns.length, endCol + this.buffer);

    return {
      startRow,
      endRow,
      startCol,
      endCol,
      offsetX: this.columns.slice(0, startCol).reduce((s, c) => s + c.width, 0),
      offsetY: startRow * this.rowHeight,
    };
  }

  get totalWidth() {
    return this.columns.reduce((s, c) => s + c.width, 0);
  }
}

// ================ 交互管理层 ================

class InteractionManager {
  private editingCell: CellPosition | null = null;
  private selection: { start: CellPosition; end: CellPosition } | null = null;

  /** 进入单元格编辑模式 — 原子化，不触发整表重绘 */
  startEdit(pos: CellPosition, cellEl: HTMLElement, currentValue: CellValue) {
    this.editingCell = pos;
    const input = document.createElement("input");
    input.value = String(currentValue ?? "");
    input.className = "cell-editor";

    input.addEventListener("blur", () => {
      this.editingCell = null;
      input.remove();
    });

    cellEl.innerHTML = "";
    cellEl.appendChild(input);
    input.focus();
    return input;
  }

  /** 区域选中 — 按住 Shift 拖拽 */
  setSelection(start: CellPosition, end: CellPosition) {
    this.selection = { start, end };
  }

  /** Ctrl+C — 将选区数据写入剪切板 */
  async copyToClipboard(model: DataModel) {
    if (!this.selection) return;
    const { start, end } = this.selection;

    const rows: string[] = [];
    for (let r = start.row; r <= end.row; r++) {
      const cells: string[] = [];
      for (let c = start.col; c <= end.col; c++) {
        cells.push(String(model.getCell(r, c) ?? ""));
      }
      rows.push(cells.join("\t")); // TSV 格式，兼容 Excel
    }

    await navigator.clipboard.writeText(rows.join("\n"));
  }

  get currentEdit() {
    return this.editingCell;
  }
  get currentSelection() {
    return this.selection;
  }
}
```

**架构启示**：真正的大数据表格不是在 DOM 上做文章，而是在数据模型上建立秩序。数据排序不移动数据本身，只重建索引映射；筛选不删除数据，只隐藏索引。**DOM 是数据投影的幻影，数据模型才是唯一的真理。**

---

### 2.3.3 时间分片渲染 (Time Slicing) ⭐⭐⭐

**现象**：初始化渲染 1 万个 DOM 会导致主线程阻塞，页面彻底卡死（卡顿时间 > 50ms）。
**本质**：利用浏览器"呼吸"的间隙，将长任务切碎，分批执行。

#### 实现方式演进

1.  **requestIdleCallback**：在浏览器空闲时执行（最优雅，但兼容性/稳定性一般）。
2.  **requestAnimationFrame (rAF)**：配合每帧渲染频率，逐帧渲染（视觉平滑度高）。
3.  **setTimeout (0)**：将任务推入宏任务队列（最通用，但精度受限）。
4.  **React Fiber 模式**：通过任务优先级调度，让高优先级任务（如输入）先行。

#### 代码实现：三种时间分片策略

> 哲学本质：**与时间合作，而非对抗。** 浏览器主线程是条单车道，你不能让一辆卡车堵死它。把卡车的货拆成小包裹，让救护车（用户输入）随时可以插队通过。

```typescript
/**
 * TimeSlicing — 时间分片渲染引擎
 *
 * 将 N 个任务切片为每帧 chunkSize 个执行，
 * 确保每帧工作时间 < 16ms，不阻塞用户交互。
 */

// ============ 方案 1: requestIdleCallback ============
// 最优雅：浏览器说"我闲了"，你才干活

function renderWithIdleCallback(
  items: unknown[],
  renderFn: (item: unknown, index: number) => void,
): Promise<void> {
  return new Promise((resolve) => {
    let index = 0;

    function work(deadline: IdleDeadline) {
      // deadline.timeRemaining() 返回当前帧剩余毫秒
      // 只在浏览器真正空闲时干活
      while (index < items.length && deadline.timeRemaining() > 1) {
        renderFn(items[index], index);
        index++;
      }

      if (index < items.length) {
        requestIdleCallback(work); // 下次空闲继续
      } else {
        resolve();
      }
    }

    requestIdleCallback(work);
  });
}

// ============ 方案 2: requestAnimationFrame ============
// 最平滑：每一帧渲染固定数量，视觉上丝滑流畅

function renderWithRAF(
  items: unknown[],
  renderFn: (item: unknown, index: number) => void,
  chunkSize: number = 20,
): Promise<void> {
  return new Promise((resolve) => {
    let index = 0;

    function frame() {
      // 每帧最多渲染 chunkSize 个
      const end = Math.min(index + chunkSize, items.length);

      for (; index < end; index++) {
        renderFn(items[index], index);
      }

      if (index < items.length) {
        requestAnimationFrame(frame); // 下一帧继续
      } else {
        resolve();
      }
    }

    requestAnimationFrame(frame);
  });
}

// ============ 方案 3: 基于时间预算的自适应分片 ============
// 最智能：不固定数量，而是固定时间预算

function renderWithTimeBudget(
  items: unknown[],
  renderFn: (item: unknown, index: number) => void,
  budgetMs: number = 8, // 每帧预算 8ms，留余量给浏览器
): Promise<void> {
  return new Promise((resolve) => {
    let index = 0;

    function chunk() {
      const start = performance.now();

      // 在时间预算内尽可能多地干活
      while (index < items.length && performance.now() - start < budgetMs) {
        renderFn(items[index], index);
        index++;
      }

      if (index < items.length) {
        // 用 MessageChannel 代替 setTimeout(0)
        // 因为 setTimeout 有 4ms 最小延迟限制
        const channel = new MessageChannel();
        channel.port1.onmessage = chunk;
        channel.port2.postMessage(null);
      } else {
        resolve();
      }
    }

    chunk();
  });
}

// ============ 方案 4: 可取消的调度器 ============
// 实战必备：支持中途取消（如用户切换页面）

class TaskScheduler {
  private aborted = false;
  private taskId: number | null = null;

  schedule<T>(
    items: T[],
    process: (item: T) => void,
    chunkSize = 16,
  ): Promise<"done" | "aborted"> {
    this.aborted = false;

    return new Promise((resolve) => {
      let i = 0;

      const step = () => {
        if (this.aborted) {
          resolve("aborted");
          return;
        }

        const end = Math.min(i + chunkSize, items.length);
        for (; i < end; i++) {
          process(items[i]);
        }

        if (i < items.length) {
          this.taskId = requestAnimationFrame(step);
        } else {
          resolve("done");
        }
      };

      this.taskId = requestAnimationFrame(step);
    });
  }

  abort() {
    this.aborted = true;
    if (this.taskId !== null) {
      cancelAnimationFrame(this.taskId);
    }
  }
}

// ========== 使用示例 ==========
const container = document.getElementById("app")!;
const items = Array.from({ length: 100_000 }, (_, i) => `Item ${i}`);

// rAF 方案：每帧渲染 50 个
await renderWithRAF(
  items,
  (item, i) => {
    const div = document.createElement("div");
    div.textContent = String(item);
    container.appendChild(div);
  },
  50,
);

// 时间预算方案：每次最多用 8ms
await renderWithTimeBudget(
  items,
  (item) => {
    const div = document.createElement("div");
    div.textContent = String(item);
    container.appendChild(div);
  },
  8,
);
```

**方案选择决策树**：

- 兼容性优先 → `setTimeout(0)` 或 `MessageChannel`
- 视觉平滑优先 → `requestAnimationFrame`
- 资源友好优先 → `requestIdleCallback`
- 生产环境 → **时间预算 + 可取消调度器**（最灵活）

---

### 2.3.4 Worker 多线程计算处理 ⭐⭐⭐

**现象**：大数据量的复杂计算（如 10 万行数据的统计、加密、排序）导致 UI 假死。
**本质**：开辟独立于主线程的运行环境（Web Worker），释放 UI 响应力。

#### 核心优化点

- **通信 Promise 化**：封装 Worker 消息传递，使其支持 `await worker.calculate(data)` 模式。
- **零拷贝传输 (Transferable Objects)**：使用 `ArrayBuffer` 等对象，避免数据序列化的内存开销。
- **Worker 池管理**：复用 Worker 实例，防止频繁创建/销毁带来的系统开销。

#### 代码实现：Worker 通信封装 + 线程池

> 哲学本质：**分治法在线程维度的终极体现。** 主线程是 CEO，只管调度和汇报；Worker 是流水线工人，闷头算就完事了。CEO 永远不应该亲自拧螺丝。

```typescript
// ================ 1. Promise 化 Worker 通信 ================

/**
 * PromiseWorker — 将 Worker 的消息回调范式转化为 async/await
 *
 * 核心机制：
 * 每个请求携带唯一 ID，响应时通过 ID 匹配 resolve/reject
 */
class PromiseWorker {
  private worker: Worker;
  private pending = new Map<
    string,
    {
      resolve: (v: unknown) => void;
      reject: (e: Error) => void;
    }
  >();
  private idCounter = 0;

  constructor(worker: Worker) {
    this.worker = worker;

    this.worker.onmessage = (e) => {
      const { id, result, error } = e.data;
      const handler = this.pending.get(id);
      if (!handler) return;

      this.pending.delete(id);
      error ? handler.reject(new Error(error)) : handler.resolve(result);
    };

    this.worker.onerror = (e) => {
      // 全局错误：拒绝所有等待中的 Promise
      for (const [id, handler] of this.pending) {
        handler.reject(new Error(e.message));
      }
      this.pending.clear();
    };
  }

  /** 发送任务并等待结果 */
  send<T>(
    type: string,
    payload: unknown,
    transfer?: Transferable[],
  ): Promise<T> {
    const id = `msg_${++this.idCounter}`;

    return new Promise((resolve, reject) => {
      this.pending.set(id, {
        resolve: resolve as (v: unknown) => void,
        reject,
      });

      this.worker.postMessage({ id, type, payload }, transfer ?? []);
    });
  }

  terminate() {
    this.worker.terminate();
    for (const handler of this.pending.values()) {
      handler.reject(new Error("Worker terminated"));
    }
    this.pending.clear();
  }
}

// ================ 2. Worker 线程内部代码 ================
// 文件: compute.worker.ts

/*
self.onmessage = (e: MessageEvent) => {
  const { id, type, payload } = e.data;

  try {
    let result: unknown;

    switch (type) {
      case 'sort':
        // 对大数据排序 — 主线程不会卡
        result = (payload as number[]).slice().sort((a, b) => a - b);
        break;

      case 'aggregate':
        // 10 万行数据的统计聚合
        const data = payload as number[];
        const sum = data.reduce((s, v) => s + v, 0);
        result = {
          sum,
          avg: sum / data.length,
          max: Math.max(...data),
          min: Math.min(...data),
          count: data.length,
        };
        break;

      case 'search':
        // 全文模糊搜索
        const { items, keyword } = payload as {
          items: string[];
          keyword: string;
        };
        const lower = keyword.toLowerCase();
        result = items.filter((item) =>
          item.toLowerCase().includes(lower)
        );
        break;

      default:
        throw new Error(`Unknown task type: ${type}`);
    }

    self.postMessage({ id, result });
  } catch (err) {
    self.postMessage({ id, error: (err as Error).message });
  }
};
*/

// ================ 3. Worker 线程池 ================

/**
 * WorkerPool — 固定大小线程池
 *
 * 设计原则：
 * 1. 池大小 = navigator.hardwareConcurrency（CPU 核心数）
 * 2. 轮询分配任务（Round Robin）
 * 3. 支持过载排队（当所有 Worker 都忙时）
 */
class WorkerPool {
  private workers: PromiseWorker[];
  private queue: Array<{
    type: string;
    payload: unknown;
    transfer?: Transferable[];
    resolve: (v: unknown) => void;
    reject: (e: Error) => void;
  }> = [];
  private activeCount = 0;
  private robin = 0;

  constructor(
    workerUrl: string | URL,
    poolSize: number = navigator.hardwareConcurrency || 4,
  ) {
    this.workers = Array.from(
      { length: poolSize },
      () => new PromiseWorker(new Worker(workerUrl, { type: "module" })),
    );
  }

  /** 提交任务 — 自动调度 */
  async exec<T>(
    type: string,
    payload: unknown,
    transfer?: Transferable[],
  ): Promise<T> {
    // Round Robin 选择 Worker
    const worker = this.workers[this.robin % this.workers.length];
    this.robin++;
    return worker.send<T>(type, payload, transfer);
  }

  /** 销毁所有 Worker */
  terminate() {
    this.workers.forEach((w) => w.terminate());
    this.workers = [];
  }
}

// ================ 4. 零拷贝传输示例 ================

/**
 * Transferable Objects — 零拷贝的关键
 *
 * 结构化克隆（默认）：深拷贝整个数据，100MB 数据 = 200MB 内存峰值
 * Transferable 转移：所有权转移，不拷贝，0 额外内存
 *
 * 代价：转移后原线程无法再访问该数据
 */
async function sortLargeArray(pool: WorkerPool, data: Float64Array) {
  // 将 ArrayBuffer 的所有权转移给 Worker（零拷贝）
  const buffer = data.buffer;
  const result = await pool.exec<ArrayBuffer>(
    "sort-buffer",
    buffer,
    [buffer], // ← 第三个参数：transferable 列表
  );

  // data.buffer 现在是 detached 状态，不可再访问
  // console.log(data[0]); // TypeError!

  return new Float64Array(result);
}

// ========== 使用示例 ==========
const pool = new WorkerPool(new URL("./compute.worker.ts", import.meta.url));

// 统计 10 万行数据 — UI 完全不卡
const stats = await pool.exec(
  "aggregate",
  Array.from({ length: 100_000 }, () => Math.random() * 1000),
);
console.log(stats); // { sum, avg, max, min, count }

// 排序大数组 — 零拷贝传输
const arr = new Float64Array(1_000_000);
crypto.getRandomValues(new Uint32Array(arr.buffer));
const sorted = await sortLargeArray(pool, arr);
```

---

### 2.3.5 长列表双向无限加载 ⭐⭐⭐

**现象**：社交媒体信息流，向上翻看历史、向下刷新未来。
**本质**：动态窗口的管理与滚动位置的补偿。

#### 核心算法

1.  **双向触发**：设置上/下两个哨兵（Sentinel）节点。
2.  **位置补偿**：向上加载更多后，必须手动调整 `scrollTop`，防止用户视角突跳（Scroll Anchoring）。
3.  **内存回收**：卸载远离视口的数据（Unmounting），仅保留当前窗口及缓冲区的状态，防止内存持续膨胀。

#### 代码实现：双向无限加载引擎

> 哲学本质：**有限模拟无限。** 信息流在概念上是无穷的，但人类视觉窗口永远只有屏幕那么大。用一个滑动窗口在无穷数据集上移动，配合滚动位置补偿制造"一切都在"的幻觉。

```typescript
/**
 * BidirectionalInfiniteList — 双向无限加载
 *
 * 核心难点：
 * 1. 向上加载时的 scrollTop 补偿 — 不补偿就会视角跳动
 * 2. 内存回收 — 无限加载 = 无限内存膨胀，必须卸载远端数据
 * 3. 加载状态管理 — 防止重复触发
 */

interface LoadResult<T> {
  items: T[];
  hasMore: boolean;
}

interface InfiniteListConfig<T> {
  container: HTMLElement;
  loadPrev: (cursor: string | null) => Promise<LoadResult<T>>;
  loadNext: (cursor: string | null) => Promise<LoadResult<T>>;
  renderItem: (item: T) => HTMLElement;
  getCursor: (item: T) => string;
  maxCachedItems?: number; // 内存中最多保留的项数
  threshold?: number; // 触发加载的距离阈值 (px)
}

class BidirectionalInfiniteList<T> {
  private container: HTMLElement;
  private list: HTMLElement;
  private topSentinel: HTMLElement;
  private bottomSentinel: HTMLElement;
  private observer: IntersectionObserver;

  private items: T[] = [];
  private loadingUp = false;
  private loadingDown = false;
  private hasMoreUp = true;
  private hasMoreDown = true;
  private maxCached: number;
  private config: InfiniteListConfig<T>;

  constructor(config: InfiniteListConfig<T>) {
    this.config = config;
    this.container = config.container;
    this.maxCached = config.maxCachedItems ?? 500;

    // ---- 构造 DOM 结构 ----
    this.list = document.createElement("div");
    this.list.className = "infinite-list";

    this.topSentinel = this.createSentinel("top");
    this.bottomSentinel = this.createSentinel("bottom");

    this.container.appendChild(this.topSentinel);
    this.container.appendChild(this.list);
    this.container.appendChild(this.bottomSentinel);

    // ---- IntersectionObserver 监听哨兵 ----
    this.observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (!entry.isIntersecting) continue;

          if (entry.target === this.topSentinel) {
            this.handleLoadUp();
          } else if (entry.target === this.bottomSentinel) {
            this.handleLoadDown();
          }
        }
      },
      {
        root: this.container,
        rootMargin: `${config.threshold ?? 200}px 0px`,
      },
    );

    this.observer.observe(this.topSentinel);
    this.observer.observe(this.bottomSentinel);
  }

  /** 初始加载 */
  async init() {
    await this.handleLoadDown();
  }

  // ============ 向下加载 ============

  private async handleLoadDown() {
    if (this.loadingDown || !this.hasMoreDown) return;
    this.loadingDown = true;
    this.bottomSentinel.textContent = "加载中...";

    const cursor =
      this.items.length > 0
        ? this.config.getCursor(this.items[this.items.length - 1])
        : null;

    const { items, hasMore } = await this.config.loadNext(cursor);
    this.hasMoreDown = hasMore;
    this.items.push(...items);

    // ---- 渲染新项 ----
    const fragment = document.createDocumentFragment();
    for (const item of items) {
      fragment.appendChild(this.config.renderItem(item));
    }
    this.list.appendChild(fragment);

    // ---- 内存回收：裁剪顶部 ----
    this.trimTop();

    this.loadingDown = false;
    this.bottomSentinel.textContent = hasMore ? "" : "没有更多了";
  }

  // ============ 向上加载（核心难点） ============

  private async handleLoadUp() {
    if (this.loadingUp || !this.hasMoreUp) return;
    this.loadingUp = true;
    this.topSentinel.textContent = "加载历史...";

    const cursor =
      this.items.length > 0 ? this.config.getCursor(this.items[0]) : null;

    const { items, hasMore } = await this.config.loadPrev(cursor);
    this.hasMoreUp = hasMore;

    // ===== 关键：滚动位置补偿 =====
    // 记录下当前滚动高度
    const prevScrollHeight = this.container.scrollHeight;

    // 将新数据插入到头部
    this.items.unshift(...items);

    // 渲染到 DOM 的最前面
    const fragment = document.createDocumentFragment();
    for (const item of items) {
      fragment.appendChild(this.config.renderItem(item));
    }
    this.list.prepend(fragment);

    // 补偿：新增内容的高度差加到 scrollTop，视角不变
    const heightDelta = this.container.scrollHeight - prevScrollHeight;
    this.container.scrollTop += heightDelta;

    // ---- 内存回收：裁剪底部 ----
    this.trimBottom();

    this.loadingUp = false;
    this.topSentinel.textContent = hasMore ? "" : "到顶了";
  }

  // ============ 内存回收 ============

  /**
   * 当缓存项超过阈值时，裁剪远端数据
   *
   * 这是"有限模拟无限"的代价 —— 你必须遗忘
   */
  private trimTop() {
    if (this.items.length <= this.maxCached) return;
    const excess = this.items.length - this.maxCached;

    // 移除数据
    this.items.splice(0, excess);

    // 移除对应 DOM 并记录高度变化
    const nodes = Array.from(this.list.children);
    let removedHeight = 0;
    for (let i = 0; i < excess && i < nodes.length; i++) {
      removedHeight += (nodes[i] as HTMLElement).offsetHeight;
      nodes[i].remove();
    }

    // 补偿 scrollTop
    this.container.scrollTop -= removedHeight;
    this.hasMoreUp = true; // 被裁剪了，所以"还有更多"
  }

  private trimBottom() {
    if (this.items.length <= this.maxCached) return;
    const excess = this.items.length - this.maxCached;

    this.items.splice(this.items.length - excess, excess);

    const nodes = Array.from(this.list.children);
    for (let i = 0; i < excess; i++) {
      nodes[nodes.length - 1 - i]?.remove();
    }

    this.hasMoreDown = true;
  }

  private createSentinel(position: string): HTMLElement {
    const el = document.createElement("div");
    el.className = `sentinel sentinel-${position}`;
    el.style.height = "1px";
    return el;
  }

  destroy() {
    this.observer.disconnect();
    this.list.remove();
    this.topSentinel.remove();
    this.bottomSentinel.remove();
  }
}

// ========== 使用示例 ==========
interface FeedItem {
  id: string;
  content: string;
  timestamp: number;
}

const feed = new BidirectionalInfiniteList<FeedItem>({
  container: document.getElementById("feed")!,
  maxCachedItems: 200,
  threshold: 300,

  async loadNext(cursor) {
    const res = await fetch(`/api/feed?after=${cursor ?? ""}&limit=20`);
    const data = await res.json();
    return { items: data.items, hasMore: data.hasMore };
  },

  async loadPrev(cursor) {
    const res = await fetch(`/api/feed?before=${cursor ?? ""}&limit=20`);
    const data = await res.json();
    return { items: data.items, hasMore: data.hasMore };
  },

  renderItem(item) {
    const el = document.createElement("article");
    el.className = "feed-item";
    el.innerHTML = `
      <p>${item.content}</p>
      <time>${new Date(item.timestamp).toLocaleString()}</time>
    `;
    return el;
  },

  getCursor: (item) => item.id,
});

await feed.init();
```

---

## 哲学启示

大数据优化遵循 **"懒 (Lazy)"** 字诀：懒加载、懒渲染、懒计算。不要试图挑战硬件的物理限制，而要学会欺骗人类的感知器官。

**三层认知跃迁**：

1. **现象层（How to fix）**：用虚拟滚动解决 DOM 过多，用 Worker 解决计算阻塞，用时间分片解决渲染卡顿。
2. **本质层（Why it breaks）**：浏览器是单线程的——这不是 Bug，是设计。所有性能问题的根源都是在有限资源上做无限的事。
3. **哲学层（How to design it right）**：**不渲染 > 延迟渲染 > 立即渲染。** 最优的代码不是跑得最快的代码，而是根本不需要执行的代码。
