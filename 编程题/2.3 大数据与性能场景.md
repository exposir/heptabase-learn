<!--
- [INPUT]: 前端大数据渲染、长列表优化、多线程、时间分片
- [OUTPUT]: 针对 10 万级数据的渲染与计算性能优化方案集
- [POS]: 编程题/ 模块的核心专题，解决前端性能瓶颈与渲染限制
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 2.3 大数据与性能场景深度剖析

在前端应用进入“桌面级”或“工业级”时代的背景下，处理大数据量（10万级以上）不再是可选项，而是核心竞争力的体现。**性能优化的本质是：如何在受限的硬件资源（单线程、有限内存）中，通过时间分片、空间置换、按需渲染来模拟“无限能力”。**

---

### 2.3.1 虚拟滚动 (Virtual Scroll) ⭐⭐⭐⭐

**现象**：DOM 节点过多会导致浏览器重绘重排极其缓慢，甚至内存崩溃。
**本质**：仅渲染可视区域（Viewport）内的 DOM，通过 `Transform` 或 `Padding` 模拟滚动条真实高度。

#### 实现策略对比

| 类型 | 难度 | 核心思路 | 挑战 |
| :--- | :--- | :--- | :--- |
| **定高虚拟列表** | ⭐⭐⭐ | `scrollTop / itemHeight` 计算起止索引 | 简单稳定 |
| **不定高虚拟列表** | ⭐⭐⭐⭐⭐ | **预估高度 + 缓存高度 + 动态修正偏移量** | 滚动条跳动、频繁测量 |
| **虚拟表格** | ⭐⭐⭐⭐ | **横向 + 纵向双轴虚拟化** | 固定头/列的同步逻辑 |

**关键挑战**：
1.  **Buffer 区域设计**：预留 1-2 屏缓冲区，防止滚动过快导致的瞬时白屏。
2.  **搜索跳转**：在大数据量下，如何精准定位到未渲染节点的 `scrollTop`。
3.  **动态加载**：结合 IntersectionObserver 实现滚动加载（Infinite Scroll）。

---

### 2.3.2 大数据表格复杂交互 ⭐⭐⭐⭐

**现象**：Excel 级别的表格，不仅要快，还要能像原生软件一样编辑、拖拽、合并。
**本质**：数据模型（Model）与渲染视图（View）的完全解耦。

#### 核心功能清单
*   **布局增强**：固定首行/首列、单元格动态合并（Span）。
*   **原子化编辑**：单个单元格进入编辑模式，不触发整表重绘。
*   **高级筛选**：多维排序、模糊匹配、树形数据收纳。
*   **极致交互**：区域选中（Selection）、拖拽排版（Drag & Drop）、Ctrl+C/V 剪切板同步。

---

### 2.3.3 时间分片渲染 (Time Slicing) ⭐⭐⭐

**现象**：初始化渲染 1 万个 DOM 会导致主线程阻塞，页面彻底卡死（卡顿时间 > 50ms）。
**本质**：利用浏览器“呼吸”的间隙，将长任务切碎，分批执行。

#### 实现方式演进
1.  **requestIdleCallback**：在浏览器空闲时执行（最优雅，但兼容性/稳定性一般）。
2.  **requestAnimationFrame (rAF)**：配合每帧渲染频率，逐帧渲染（视觉平滑度高）。
3.  **setTimeout (0)**：将任务推入宏任务队列（最通用，但精度受限）。
4.  **React Fiber 模式**：通过任务优先级调度，让高优先级任务（如输入）先行。

---

### 2.3.4 Worker 多线程计算处理 ⭐⭐⭐

**现象**：大数据量的复杂计算（如 10 万行数据的统计、加密、排序）导致 UI 假死。
**本质**：开辟独立于主线程的运行环境（Web Worker），释放 UI 响应力。

#### 核心优化点
*   **通信 Promise 化**：封装 Worker 消息传递，使其支持 `await worker.calculate(data)` 模式。
*   **零拷贝传输 (Transferable Objects)**：使用 `ArrayBuffer` 等对象，避免数据序列化的内存开销。
*   **Worker 池管理**：复用 Worker 实例，防止频繁创建/销毁带来的系统开销。

---

### 2.3.5 长列表双向无限加载 ⭐⭐⭐

**现象**：社交媒体信息流，向上翻看历史、向下刷新未来。
**本质**：动态窗口的管理与滚动位置的补偿。

#### 核心算法
1.  **双向触发**：设置上/下两个哨兵（Sentinel）节点。
2.  **位置补偿**：向上加载更多后，必须手动调整 `scrollTop`，防止用户视角突跳（Scroll Anchoring）。
3.  **内存回收**：卸载远离视口的数据（Unmounting），仅保留当前窗口及缓冲区的状态，防止内存持续膨胀。

---

## 哲学启示

大数据优化遵循 **“懒 (Lazy)”** 字诀：懒加载、懒渲染、懒计算。不要试图挑战硬件的物理限制，而要学会欺骗人类的感知器官。
