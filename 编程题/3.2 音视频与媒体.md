<!--
- [INPUT]: HTML5 Video API, MediaSource Extensions (MSE), WebRTC 1.0, Canvas Pixel Manipulation
- [OUTPUT]: 现代多媒体场景的底层实战（播放器状态机、WebRTC 信令流、像素级滤镜）
- [POS]: 编程题/ 复杂场景专题，涵盖流媒体与图形学基础
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.2 音视频与媒体

在 Web 环境下，音视频不再仅仅是 `<video>` 标签，而是涉及**流式传输、实时通信与 GPU 加速**的复杂工程综合体。

---

### 3.2.1 视频播放器状态机 (Video Player FSM) ⭐⭐⭐

**现象**：播放器状态转换逻辑混乱，各种 `loading` 与 `error` 状态冲突。
**本质**：通过有限状态机（FSM）严格定义 `IDLE`, `LOADING`, `PLAYING`, `PAUSED`, `ERROR` 之间的跳转。

#### 核心实现：极简播放器控制器

```javascript
// ─────────────────────────────────────────────────
//  PlayerFSM — 视频播放器状态管理器
// ─────────────────────────────────────────────────

class PlayerController {
  constructor(videoElement) {
    this.video = videoElement;
    this.status = "IDLE"; // IDLE | LOADING | PLAYING | PAUSED | ERROR

    this.init();
  }

  init() {
    this.video.onwaiting = () => this.transition("LOADING");
    this.video.onplaying = () => this.transition("PLAYING");
    this.video.onpause = () => this.transition("PAUSED");
    this.video.onerror = () => this.transition("ERROR");
  }

  transition(nextStatus) {
    console.log(`[Player] ${this.status} -> ${nextStatus}`);

    // 状态守卫：如果是错误状态，除非重置否则不能乱动
    if (this.status === "ERROR" && nextStatus !== "LOADING") return;

    this.status = nextStatus;
    this.updateUI();
  }

  play() {
    if (this.status === "ERROR") this.video.load();
    this.video.play().catch((e) => this.transition("ERROR"));
  }

  updateUI() {
    // 根据状态控制播放/暂停按钮、Loading 动画的显示隐藏
    // const loadingSpinner = document.querySelector('.spinner');
    // loadingSpinner.style.display = (this.status === 'LOADING') ? 'block' : 'none';
  }
}
```

> **本质洞察**：**UI 是状态的投影**。不要在每个事件回调里操作 DOM，而应该通过 `transition` 修改唯一状态，再在 `updateUI` 中统一处理显示逻辑。

---

### 3.2.2 WebRTC 实时通信流程 (WebRTC Flow) ⭐⭐⭐⭐

**现象**：P2P 连接建立失败，不理解信令过程。
**本质**：通过中间人（信令服务器）交换 **SDP (意图描述)** 和 **ICE Candidates (路径描述)**。

#### 核心实现：P2P 握手伪代码逻辑

```javascript
// ─────────────────────────────────────────────────
//  WebRTC Handshake — A 端与 B 端的握手契约
// ─────────────────────────────────────────────────

async function setupP2P(isCaller) {
  const peer = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
  });

  // 1. 监听网络路径发现 (ICE)
  peer.onicecandidate = (e) => {
    if (e.candidate) sendToRemote("candidate", e.candidate);
  };

  // 2. A 端发起 Offer
  if (isCaller) {
    const offer = await peer.createOffer();
    await peer.setLocalDescription(offer);
    sendToRemote("offer", offer);
  }

  // 3. 处理信令消息
  onReceiveFromRemote(async (type, data) => {
    if (type === "offer") {
      await peer.setRemoteDescription(data);
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);
      sendToRemote("answer", answer);
    } else if (type === "answer") {
      await peer.setRemoteDescription(data);
    } else if (type === "candidate") {
      await peer.addIceCandidate(data);
    }
  });
}
```

> **本质洞察**：**WebRTC 连接就像打电话**。Offer 是"拨号"，Answer 是"接听"，ICE 是"确认信号频率与线路"。两端必须都达成 `setLocalDescription` 和 `setRemoteDescription` 的对称平衡，数据隧道才算打通。

---

### 3.2.3 像素级图像处理 (Pixel Manipulation) ⭐⭐⭐

**现象**：Canvas 绘图只是画形状，不理解滤镜原理。
**本质**：操作 `ImageData.data` 这个巨大的 `Uint8ClampedArray`，按 `[R, G, B, A]` 的步长遍历遍历像素。

#### 核心实现：灰度滤镜算法

```javascript
// ─────────────────────────────────────────────────
//  applyGrayscale — 像素级灰度转换
// ─────────────────────────────────────────────────

function applyGrayscale(canvas) {
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data; // [r1, g1, b1, a1, r2, g2, b2, a2...]

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];

    // 经典亮度加权公式：Y = 0.299R + 0.587G + 0.114B
    const gray = 0.299 * r + 0.587 * g + 0.114 * b;

    data[i] = data[i + 1] = data[i + 2] = gray;
    // data[i+3] 是 alpha 通道，通常保持不变
  }

  ctx.putImageData(imageData, 0, 0);
}
```

> **本质洞察**：**数字图像是纯粹的数学矩阵**。每一个像素都是内存中的一个坐标点。当你理解了 `ImageData` 的内存布局，你就掌握了编写图像压缩、裁剪、抠图（绿幕算法）甚至是 WebGL 着色器的基础。

---

## 质量指标

- **Stability**：状态机是否能应对极端的网络延迟与断网重连。
- **Latency**：WebRTC 建立连接的时间（P95 指标）。
- **Computation Efficiency**：大尺寸图片的像素遍历是否引起主线程阻塞（是否需要使用 Web Worker 或 OffscreenCanvas）。
