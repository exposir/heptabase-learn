<!--
- [INPUT]: 依赖移动端浏览器特性
- [OUTPUT]: 移动端兼容性与调试技巧
- [POS]: 编程题模块 - 移动端专项
- [PROTOCOL]: 变更时更新此头部，然后检查 /CLAUDE.md
-->

# 4.6 移动端专项

移动端开发的挑战不在于"能不能跑"，而在于"体验是否丝滑"。触控、键盘、软件行为的碎片化是永恒主题。

---

## 4.6.1 经典兼容性问题 ⭐⭐⭐

| 问题           | 解决方案                   |
| :------------- | :------------------------- |
| **1px 边框**   | transform scale / viewport |
| **安全区域**   | env(safe-area-inset-\*)    |
| **iOS 键盘**   | scrollIntoView / 布局监听  |
| **300ms 延迟** | touch-action / fastclick   |
| **滚动穿透**   | 多种方案对比               |

### 1. 1px 边框问题

```css
/* ─────────────────────────────────────────────────
   1px 物理像素边框 — DPR 适配
   ───────────────────────────────────────────────── */

/* 方案一：transform scale（最通用） */
.border-1px {
  position: relative;
}
.border-1px::after {
  content: "";
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 1px;
  background: #e5e5e5;
  transform: scaleY(0.5); /* 2x 屏幕缩放到真实 1px */
}

/* 方案二：viewport 设置（全局方案） */
/* <meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5"> */
/* 缺点：所有尺寸都要乘以 2 */

/* 方案三：border-image + SVG */
.border-svg {
  border: 1px solid transparent;
  border-image: url("data:image/svg+xml,...") 2 stretch;
}
```

### 2. iOS 安全区域适配

```css
/* ─────────────────────────────────────────────────
   Safe Area — iPhone X 以上刘海/底部横条适配
   ───────────────────────────────────────────────── */

/* 必须先声明 viewport-fit=cover */
/* <meta name="viewport" content="viewport-fit=cover"> */

.header {
  /* 顶部：避开刘海 */
  padding-top: env(safe-area-inset-top);
}

.footer-bar {
  /* 底部固定栏：避开 Home Indicator */
  padding-bottom: env(safe-area-inset-bottom);
  /* 兜底（不支持 env 的旧设备） */
  padding-bottom: constant(safe-area-inset-bottom);
}

/* 通用安全区容器 */
.safe-area {
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
}
```

### 3. iOS 键盘弹出问题

```javascript
// ─────────────────────────────────────────────────
//  KeyboardManager — iOS 键盘弹出事件处理
// ─────────────────────────────────────────────────

class KeyboardManager {
  constructor() {
    this.originalHeight = window.innerHeight;
    this.isKeyboardOpen = false;
    this._init();
  }

  _init() {
    // iOS 下 window.resize 可以检测键盘弹出
    const isIOS = /iPhone|iPad/.test(navigator.userAgent);

    if (isIOS) {
      // iOS 方案：通过 visualViewport API
      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", () => {
          const currentHeight = window.visualViewport.height;
          this.isKeyboardOpen = currentHeight < this.originalHeight * 0.75;

          if (this.isKeyboardOpen) {
            this._onKeyboardShow(this.originalHeight - currentHeight);
          } else {
            this._onKeyboardHide();
          }
        });
      }
    } else {
      // Android 方案：通过 resize 事件
      window.addEventListener("resize", () => {
        const currentHeight = window.innerHeight;
        this.isKeyboardOpen = currentHeight < this.originalHeight * 0.75;
      });
    }
  }

  _onKeyboardShow(keyboardHeight) {
    // 聚焦元素滚动到可视区域
    const activeEl = document.activeElement;
    if (activeEl && activeEl.tagName === "INPUT") {
      setTimeout(() => {
        activeEl.scrollIntoView({
          behavior: "smooth",
          block: "center",
        });
      }, 300);
    }
  }

  _onKeyboardHide() {
    // iOS 键盘收起后可能页面不回弹
    window.scrollTo(0, 0);
  }
}
```

### 4. 滚动穿透解决方案

```javascript
// ─────────────────────────────────────────────────
//  ScrollLock — 弹窗滚动穿透
// ─────────────────────────────────────────────────

class ScrollLock {
  constructor() {
    this.scrollTop = 0;
  }

  // 方案一：body fixed（最可靠）
  lock() {
    this.scrollTop = window.scrollY;
    document.body.style.cssText = `
      position: fixed;
      top: -${this.scrollTop}px;
      left: 0;
      right: 0;
      overflow: hidden;
    `;
  }

  unlock() {
    document.body.style.cssText = "";
    window.scrollTo(0, this.scrollTop);
  }

  // 方案二：overscroll-behavior（现代浏览器）
  // .modal { overscroll-behavior: contain; }

  // 方案三：touchmove 阻止（内容不需要滚动时）
  lockTouch(el) {
    const handler = (e) => e.preventDefault();
    el.addEventListener("touchmove", handler, { passive: false });
    return () => el.removeEventListener("touchmove", handler);
  }
}
```

> **本质洞察**：移动端兼容性问题的根源是 **"Web 标准诞生于桌面时代"**。1px 问题是因为 CSS 像素 ≠ 物理像素，300ms 延迟是因为浏览器要等待判断双击缩放。每个"兼容性 Hack"背后都有一个 **历史债务**。理解"为什么会有这个问题"比记住"怎么解决"更重要。

---

## 4.6.2 Hybrid 调试 ⭐⭐⭐

### 方法

- **Android Chrome 远程调试**
- **iOS Safari 调试**
- **Charles 抓包**
- **vConsole/eruda**

### 1. 调试方案全景

```javascript
// ─────────────────────────────────────────────────
//  MobileDebugKit — 移动端调试工具集成
// ─────────────────────────────────────────────────

class MobileDebugKit {
  constructor() {
    this.isDebug = this._checkDebugMode();
  }

  _checkDebugMode() {
    // URL 参数、Cookie、或构建环境判断
    return (
      location.search.includes("debug=1") ||
      document.cookie.includes("debug=1") ||
      process.env.NODE_ENV === "development"
    );
  }

  // ── 注入 vConsole / eruda ────────────────────
  async injectConsole(type = "vconsole") {
    if (!this.isDebug) return;

    if (type === "vconsole") {
      const VConsole = await import("vconsole");
      new VConsole.default();
    } else {
      const eruda = await import("eruda");
      eruda.default.init();
    }
  }

  // ── 抓包调试：打印所有网络请求 ────────────────
  enableNetworkLog() {
    if (!this.isDebug) return;

    const origFetch = window.fetch;
    window.fetch = async (...args) => {
      const url = typeof args[0] === "string" ? args[0] : args[0]?.url;
      const start = performance.now();

      try {
        const res = await origFetch.apply(this, args);
        console.log(
          `[NET] ${res.status} ${url} ${(performance.now() - start).toFixed(0)}ms`,
        );
        return res;
      } catch (e) {
        console.error(`[NET] FAIL ${url}`, e);
        throw e;
      }
    };
  }
}

// 调试流程速查：
// Android: chrome://inspect → 连接 USB → 远程 DevTools
// iOS: Safari → Develop → [设备名] → [WebView]
// 抓包: Charles → SSL Proxy → 安装证书到设备
// 无USB: vConsole/eruda → URL 加 ?debug=1
```

> **本质洞察**：移动端调试的核心挑战是 **"触不可及"** —— 你不能在手机上打开 DevTools。所有调试方案本质上都在做一件事：**把调试能力投射到可控的环境中**。远程调试是把 DevTools 投射到电脑上，vConsole 是把控制台投射到页面上，Charles 是把网络请求投射到代理服务器上。

---

## 质量指标

- **兼容覆盖率**：适配方案覆盖了多少机型和操作系统版本。
- **调试效率**：从发现问题到定位原因的平均时间。
- **体验一致性**：不同设备上的视觉和交互差异程度。
