<!--
- [INPUT]: Browser Range/Selection API, DOM Structure, Collaborative Algorithms (OT/CRDT)
- [OUTPUT]: 编辑器架构设计、自定义 Block 实现及协同同步策略要求
- [POS]: 编程题/ 复杂场景专题，聚焦富文本处理与协同编辑
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 3.3 编辑器场景

编辑器是前端开发中最复杂的应用形式之一，它集成了数据结构、DOM 操作、事件管理及复杂的状态同步算法。

---

### 3.3.1 富文本编辑器 (Rich Text Editor) ⭐⭐⭐⭐⭐

**要求：** 设计并实现一个基于 L0/L1 层的富文本编辑器核心逻辑。

- **核心挑战：**
  - **数据模型设计**：由 DOM 驱动 (ContentEditable) 还是由数据驱动 (Model-driven) 的权衡。
  - **Selection/Range API**：跨节点的选区计算、光标定位与样式应用。
  - **自定义 Block**：如何插入并管理非文本内容（如图片、卡片）。
  - **粘贴处理**：HTML 清洗 (Sanitize) 与格式解析。
  - **协同编辑**：OT (Operational Transformation) 或 CRDT 算法的应用。

#### 1. 数据驱动架构 (Model-driven)

现代编辑器（如 VSCode, Slate, Quill）不再直接操作 DOM，而是通过一个 JSON 数据结构映射到 DOM。

```javascript
// ─────────────────────────────────────────────────
//  EditorModel — 简化的数据驱动编辑器内核
// ─────────────────────────────────────────────────

const initialState = [
  {
    type: "paragraph",
    children: [{ text: "Hello " }, { text: "World", bold: true }],
  },
  { type: "image", url: "https://...", children: [{ text: "" }] },
];

class SimpleEditor {
  constructor(root, data = initialState) {
    this.root = root;
    this.model = data;
    this.render();
  }

  // ── 渲染层：Model -> DOM (L1 隔离) ──
  render() {
    this.root.innerHTML = "";
    this.model.forEach((node) => {
      const el = this._createNode(node);
      this.root.appendChild(el);
    });
  }

  _createNode(node) {
    let el;
    if (node.type === "paragraph") {
      el = document.createElement("p");
      node.children.forEach((child) => {
        const span = document.createElement("span");
        span.textContent = child.text;
        if (child.bold) span.style.fontWeight = "bold";
        el.appendChild(span);
      });
    } else if (node.type === "image") {
      el = document.createElement("img");
      el.src = node.url;
    }
    return el;
  }

  // ── 变更层：Action -> Model -> Render (单一真相源) ──
  applyAction(action) {
    if (action.type === "insert_text") {
      // 找到光标位置对应的节点并修改数据
      this._insertTextInModel(action.path, action.offset, action.text);
    }
    this.render(); // 重新渲染（生产环境会使用 Virtual DOM 局部更新）
  }
}
```

> **本质洞察**：富文本编辑器的演进史就是 **"夺回 DOM 控制权"** 的历史。L0 编辑器（ContentEditable）由浏览器控制，行为不可测；L1 编辑器通过劫持输入（BeforeInput）和管理数据模型，实现了行为的一致性。**数据即真理 (Single Source of Truth)** 是复杂编辑器的根基。

#### 2. Selection/Range API 的核心应用

```javascript
// ─────────────────────────────────────────────────
//  SelectionUtils — 光标与选区处理
// ─────────────────────────────────────────────────

function getSelectionInfo() {
  const selection = window.getSelection();
  if (!selection.rangeCount) return null;

  const range = selection.getRangeAt(0);
  return {
    startNode: range.startContainer,
    startOffset: range.startOffset,
    endNode: range.endContainer,
    endOffset: range.endOffset,
    isCollapsed: range.collapsed, // 是否为光标（无选区）
    text: range.toString(),
  };
}

function wrapWithBold() {
  const range = window.getSelection()?.getRangeAt(0);
  if (!range || range.collapsed) return;

  const strong = document.createElement("strong");
  // 核心 API：surroundContents 将选区包裹进新节点
  range.surroundContents(strong);
}
```

#### 3. 协同编辑：OT 算法核心原理

OT 的核心是在操作冲突时，通过变换（Transformation）使各端最终状态一致。

```javascript
// ─────────────────────────────────────────────────
//  OT-Algorithm — 操作变换原理示意
// ─────────────────────────────────────────────────

// 场景：A 和 B 同时编辑 "abc"
// A: Insert 'X' at 0 -> "Xabc"
// B: Insert 'Y' at 3 -> "abcY"

function transform(opA, opB) {
  // 如果 opB 在 opA 之后生效，且 opA 插入了字符
  // 则 opB 的索引需要顺移
  if (opA.type === "insert" && opB.type === "insert") {
    if (opB.index >= opA.index) {
      return { ...opB, index: opB.index + opA.text.length };
    }
  }
  return opB;
}
```

---

### 3.3.2 代码编辑器集成 ⭐⭐⭐

**要求：** 封装并深度定制业界主流的代码编辑器引擎。

- **实战要点：**
  - **Monaco 定制**：自定义主题、扩展右键菜单。
  - **语法高亮原理**：词法分析 (Lexical Analysis) 与着色。
  - **LSP 对接**：代码提示与补全。

#### 1. 语法高亮原理解析

语法高亮不是正则表达式的简单堆砌，而是 **Tokenization** 过程。

```javascript
// ─────────────────────────────────────────────────
//  Lexer-Mock — 词法分析器模拟
// ─────────────────────────────────────────────────

const rules = [
  { type: "keyword", regex: /^(if|else|for|function|return)/ },
  { type: "number", regex: /^\d+/ },
  { type: "string", regex: /^".*?"/ },
  { type: "identifier", regex: /^[a-zA-Z_]\w*/ },
];

function tokenize(code) {
  let tokens = [];
  let remaining = code;

  while (remaining) {
    let matched = false;
    for (const rule of rules) {
      const res = remaining.match(rule.regex);
      if (res) {
        tokens.push({ type: rule.type, value: res[0] });
        remaining = remaining.slice(res[0].length).trim();
        matched = true;
        break;
      }
    }
    if (!matched) break; // 简单处理
  }
  return tokens;
}
```

> **本质洞察**：Monaco 等编辑器的渲染分两步：**解析 (Tokenize)** 决定单词是什么，**排版 (Layout)** 决定单词画在哪。LSP (Language Server Protocol) 的伟大在于它将"语义理解"从前端剥离到了后端，实现了万能插件化。

---

### 3.3.3 Markdown 编辑器 ⭐⭐⭐

**要求：** 实现一个支持实时预览与语法扩展的高性能 Markdown 编辑工具。

- **核心功能：**
  - **实时预览**：按需更新策略。
  - **语法扩展**：Remark 插件。
  - **目录生成 (TOC)**：深度优先遍历。

#### 1. 高性能实时预览 (防抖与精细化更新)

```javascript
// ─────────────────────────────────────────────────
//  MarkdownEditor — 实时预览逻辑
// ─────────────────────────────────────────────────

class MarkdownEditor {
  constructor(textarea, previewArea) {
    this.textarea = textarea;
    this.previewArea = previewArea;
    this.timer = null;

    this.textarea.addEventListener("input", () => {
      // 防抖，减少重渲染压力
      clearTimeout(this.timer);
      this.timer = setTimeout(() => this.updatePreview(), 200);
    });
  }

  updatePreview() {
    const raw = this.textarea.value;
    // 生产环境应使用 remark().use(rehype).processSync(raw)
    const html = this._simpleMarkdownParser(raw);
    this.previewArea.innerHTML = html;
  }

  _simpleMarkdownParser(md) {
    return md
      .replace(/^# (.*$)/gim, "<h1>$1</h1>")
      .replace(/^## (.*$)/gim, "<h2>$1</h2>")
      .replace(/\*\*(.*)\*\*/gim, "<b>$1</b>");
  }
}
```

---

## 质量指标

- **稳定性**：复杂的撤销重做 (Undo/Redo) 栈管理是否产生内存泄漏。
- **性能**：万级字符输入时的响应延迟（LCP/FID 指标）。
- **兼容性**：不同浏览器对 Range API 的碎片化实现处理。
