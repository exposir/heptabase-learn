<!--
- [INPUT]: 幂等性设计、RSA/AES 加密、MutationObserver、Web Crypto
- [OUTPUT]: 前端纵深防御体系与稳定性兜底方案
- [POS]: 编程题/ 模块的核心专题，构建企业级应用的安全底座
- [PROTOCOL]: 变更时更新此头部，然后检查 CLAUDE.md
-->

# 2.6 安全与稳定性场景深度剖析

前端是应用安全的最前沿，也是最脆弱的一环。**安全与稳定性的本质是：不信任任何外部输入（包括用户点击），并通过"纵深防御（Defense in Depth）"与"自愈机制"将风险控制在可控范围内。**

---

### 2.6.1 防重复提交 (Anti-Double-Submission) ⭐⭐⭐

**现象**：用户快速点击按钮导致产生重复订单或脏数据。
**本质**：**全链路幂等性设计。**

#### 纵深防御层次

1.  **UI 层 (Visual Lock)**：点击后立即置灰按钮并显示 Loading，解决 90% 的物理重复触发。
2.  **请求层 (Traffic Control)**：利用请求 ID 锁。在当前请求未返回前，忽略后续相同参数的请求。
3.  **服务端 (Idempotent Key)**：由前端生成 UUID 作为幂等键随请求发送，服务端通过 Redis 缓存该键并拒绝重复操作。

#### 完整实现：三层纵深防御

```typescript
// ============================================================
//  Layer 1: UI 视觉锁 — React Hook 封装
//  核心思想：将 loading 状态与按钮禁用绑定为原子操作
// ============================================================

function useSubmitLock() {
  const [loading, setLoading] = useState(false);

  const run = useCallback(async <T>(fn: () => Promise<T>): Promise<T | undefined> => {
    if (loading) return;          // 物理屏障：正在提交时直接返回
    setLoading(true);
    try {
      return await fn();
    } finally {
      setLoading(false);          // finally 保证状态恢复，即使异常
    }
  }, [loading]);

  return { loading, run };
}

// 使用
function OrderButton() {
  const { loading, run } = useSubmitLock();

  const handleClick = () => run(async () => {
    await api.createOrder(data);
  });

  return (
    <button disabled={loading} onClick={handleClick}>
      {loading ? '提交中...' : '提交订单'}
    </button>
  );
}


// ============================================================
//  Layer 2: 请求层流量管控 — 基于请求签名的去重拦截器
//  核心思想：相同参数的请求在飞行中时，后续请求直接复用
// ============================================================

const pendingRequests = new Map<string, Promise<any>>();

function createRequestKey(url: string, data: unknown): string {
  return `${url}::${JSON.stringify(data)}`;
}

async function deduplicatedRequest<T>(
  url: string, data: unknown, requestFn: () => Promise<T>
): Promise<T> {
  const key = createRequestKey(url, data);

  // 存在飞行中的相同请求 → 直接复用其 Promise
  if (pendingRequests.has(key)) {
    return pendingRequests.get(key)!;
  }

  const promise = requestFn().finally(() => {
    pendingRequests.delete(key);  // 请求完成后释放锁
  });

  pendingRequests.set(key, promise);
  return promise;
}


// ============================================================
//  Layer 3: 幂等键 — 前端生成 UUID，服务端做最终裁决
//  核心思想：即使前两层全部失效，服务端仍可通过幂等键拒绝重复
// ============================================================

function generateIdempotentKey(): string {
  return crypto.randomUUID();     // Web Crypto API，浏览器原生
}

async function submitOrder(orderData: OrderPayload) {
  const idempotentKey = generateIdempotentKey();

  return fetch('/api/order', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Idempotent-Key': idempotentKey,   // 服务端据此去重
    },
    body: JSON.stringify(orderData),
  });
}

// 服务端伪代码（Redis 实现）：
// if (redis.setnx(`idempotent:${key}`, 1, 'EX', 3600)) {
//   processOrder();   // 首次提交 → 处理
// } else {
//   return cachedResult;  // 重复提交 → 返回缓存结果
// }
```

**架构洞察**：三层防御形成"漏斗模型"——UI 层过滤 90%，请求层过滤 9%，幂等键兜底最后 1%。每一层独立运作、互不依赖，任何一层失效都不影响整体安全性。

---

### 2.6.2 前端加密传输 (Frontend Encryption) ⭐⭐⭐

**现象**：敏感信息（密码、密钥）在 HTTPS 之外需要额外的保障。
**本质**：非对称加密保护对称密钥。

#### 工业级加密流程

- **混合加密**：
  1.  前端随机生成一个 **AES 密钥**（对称加密，效率高）。
  2.  用服务端的 **RSA 公钥** 加密这个 AES 密钥。
  3.  用 AES 密钥加密原始数据包。
  4.  发送加密后的 AES 密钥 + 加密后的数据包。
- **优势**：既保证了大量数据传输的性能，又利用非对称加密解决了密钥分发安全。

#### 完整实现：基于 Web Crypto API 的混合加密

```typescript
// ============================================================
//  工具函数：ArrayBuffer ↔ Base64 互转
// ============================================================

function bufferToBase64(buffer: ArrayBuffer): string {
  return btoa(String.fromCharCode(...new Uint8Array(buffer)));
}

function base64ToBuffer(base64: string): ArrayBuffer {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

// ============================================================
//  Step 1: 导入服务端 RSA 公钥 (PEM → CryptoKey)
// ============================================================

async function importRSAPublicKey(pem: string): Promise<CryptoKey> {
  // 剥离 PEM 头尾标记，提取纯 Base64 内容
  const pemBody = pem
    .replace(/-----BEGIN PUBLIC KEY-----/, "")
    .replace(/-----END PUBLIC KEY-----/, "")
    .replace(/\s/g, "");

  const der = base64ToBuffer(pemBody);

  return crypto.subtle.importKey(
    "spki", // SubjectPublicKeyInfo 格式
    der,
    { name: "RSA-OAEP", hash: "SHA-256" },
    false, // 不可导出
    ["encrypt"], // 仅用于加密
  );
}

// ============================================================
//  Step 2: 生成一次性 AES 会话密钥
// ============================================================

async function generateAESKey(): Promise<CryptoKey> {
  return crypto.subtle.generateKey(
    { name: "AES-GCM", length: 256 },
    true, // 可导出（需要用 RSA 加密后发送）
    ["encrypt", "decrypt"],
  );
}

// ============================================================
//  Step 3: AES-GCM 加密数据
// ============================================================

async function encryptData(
  aesKey: CryptoKey,
  plaintext: string,
): Promise<{ ciphertext: string; iv: string }> {
  const iv = crypto.getRandomValues(new Uint8Array(12)); // GCM 推荐 12 字节 IV
  const encoded = new TextEncoder().encode(plaintext);

  const cipherBuffer = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    aesKey,
    encoded,
  );

  return {
    ciphertext: bufferToBase64(cipherBuffer),
    iv: bufferToBase64(iv), // IV 不需要保密，但必须随密文一起传输
  };
}

// ============================================================
//  Step 4: RSA 加密 AES 密钥
// ============================================================

async function encryptAESKey(
  rsaPublicKey: CryptoKey,
  aesKey: CryptoKey,
): Promise<string> {
  const rawKey = await crypto.subtle.exportKey("raw", aesKey);

  const encryptedKey = await crypto.subtle.encrypt(
    { name: "RSA-OAEP" },
    rsaPublicKey,
    rawKey,
  );

  return bufferToBase64(encryptedKey);
}

// ============================================================
//  完整加密流程：一键调用
// ============================================================

async function hybridEncrypt(
  plaintext: string,
  serverPublicKeyPem: string,
): Promise<{ encryptedKey: string; ciphertext: string; iv: string }> {
  const rsaPublicKey = await importRSAPublicKey(serverPublicKeyPem);
  const aesKey = await generateAESKey();

  const { ciphertext, iv } = await encryptData(aesKey, plaintext);
  const encryptedKey = await encryptAESKey(rsaPublicKey, aesKey);

  return { encryptedKey, ciphertext, iv };
}

// 使用示例
async function sendSensitiveData(data: object) {
  const PUBLIC_KEY = await fetch("/api/public-key").then((r) => r.text());

  const encrypted = await hybridEncrypt(JSON.stringify(data), PUBLIC_KEY);

  // 服务端收到后：
  // 1. 用 RSA 私钥解密 encryptedKey → 得到 AES 密钥
  // 2. 用 AES 密钥 + iv 解密 ciphertext → 得到原始数据
  return fetch("/api/sensitive", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(encrypted),
  });
}
```

**架构洞察**：混合加密的精髓在于"用慢的（RSA）保护快的（AES），用快的加密多的（数据）"。RSA 加密开销大但只加密 32 字节的密钥；AES 加密快但密钥分发不安全——两者互补，缺一不可。

---

### 2.6.3 水印方案与防删除机制 ⭐⭐⭐

**现象**：内部数据展示页面需要防截图追溯。
**本质**：**不可移除的视觉层叠加。**

#### 实现方式与攻防

| 方式             | 优点                     | 缺点                 | 场景         |
| :--------------- | :----------------------- | :------------------- | :----------- |
| **Canvas/SVG**   | 灵活、支持动态内容       | DOM 节点可直接删除   | 通用场景     |
| **CSS 背景水印** | 性能最佳，不易选中       | 无法承载动态安全信息 | 轻量级防盗   |
| **暗水印 (LSD)** | 人眼不可见，截图后可解析 | 算法复杂，性能损耗   | 极高安全级别 |

**防删除机制**：
利用 `MutationObserver` 监听水印容器及其父节点。一旦发现水印节点被 `remove`、`hide` 或样式被篡改，立即在微任务队列中**重新渲染（Re-render）**水印，并触发安全预警上报。

#### 完整实现：Canvas 水印 + MutationObserver 防篡改

```typescript
// ============================================================
//  Part 1: Canvas 水印生成器
//  核心思想：将用户信息绘制为半透明 Canvas，转为 DataURL 铺满容器
// ============================================================

interface WatermarkOptions {
  text: string; // 水印文字（通常为 用户名 + 工号）
  fontSize?: number;
  color?: string; // 推荐极低透明度，如 rgba(0,0,0,0.08)
  rotate?: number; // 旋转角度（度）
  gap?: number; // 水印间距
}

function createWatermarkBg(options: WatermarkOptions): string {
  const {
    text,
    fontSize = 14,
    color = "rgba(0, 0, 0, 0.08)",
    rotate = -22,
    gap = 100,
  } = options;

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d")!;

  // 计算单个水印块尺寸
  ctx.font = `${fontSize}px sans-serif`;
  const metrics = ctx.measureText(text);
  const blockW = metrics.width + gap;
  const blockH = fontSize + gap;

  canvas.width = blockW;
  canvas.height = blockH;

  // 旋转绘制
  ctx.translate(blockW / 2, blockH / 2);
  ctx.rotate((rotate * Math.PI) / 180);
  ctx.font = `${fontSize}px sans-serif`;
  ctx.fillStyle = color;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, 0, 0);

  return canvas.toDataURL();
}

// ============================================================
//  Part 2: 水印挂载 — 创建覆盖全屏的水印层
// ============================================================

function mountWatermark(
  container: HTMLElement,
  options: WatermarkOptions,
): HTMLDivElement {
  const watermarkDiv = document.createElement("div");
  const bgUrl = createWatermarkBg(options);

  // 关键样式：铺满容器、禁止交互、禁止选中
  Object.assign(watermarkDiv.style, {
    position: "fixed",
    top: "0",
    left: "0",
    width: "100vw",
    height: "100vh",
    backgroundImage: `url(${bgUrl})`,
    backgroundRepeat: "repeat",
    pointerEvents: "none", // 不拦截鼠标事件
    userSelect: "none",
    zIndex: "99999",
  });

  watermarkDiv.setAttribute("data-watermark", "true");
  container.appendChild(watermarkDiv);
  return watermarkDiv;
}

// ============================================================
//  Part 3: MutationObserver 防篡改守卫
//  核心思想：监听一切可能的篡改行为，立即恢复水印
// ============================================================

function guardWatermark(
  container: HTMLElement,
  options: WatermarkOptions,
  onTamper?: () => void, // 篡改时触发的安全上报回调
): () => void {
  let watermarkEl = mountWatermark(container, options);

  // ---- 恢复函数：销毁旧水印，重新挂载 ----
  const restore = () => {
    // 用 queueMicrotask 确保在当前 DOM 变更回调结束后再操作
    queueMicrotask(() => {
      // 清除可能残留的旧节点
      container
        .querySelectorAll("[data-watermark]")
        .forEach((el) => el.remove());

      watermarkEl = mountWatermark(container, options);
      onTamper?.(); // 触发安全预警上报
    });
  };

  // ---- 判定是否为篡改行为 ----
  const isTampered = (mutations: MutationRecord[]): boolean => {
    for (const mutation of mutations) {
      // 场景 1: 水印节点被直接删除
      if (mutation.type === "childList") {
        for (const removed of mutation.removedNodes) {
          if (removed === watermarkEl) return true;
        }
      }
      // 场景 2: 水印样式被修改（display:none, opacity:0, etc.）
      if (mutation.type === "attributes" && mutation.target === watermarkEl) {
        return true;
      }
    }
    return false;
  };

  // ---- 启动观察器 ----
  const observer = new MutationObserver((mutations) => {
    if (isTampered(mutations)) {
      restore();
    }
  });

  observer.observe(container, {
    childList: true, // 监听子节点增删
    subtree: true, // 监听整个子树
    attributes: true, // 监听属性变化
    attributeFilter: ["style", "class", "hidden"],
  });

  // 返回清理函数
  return () => {
    observer.disconnect();
    watermarkEl.remove();
  };
}

// ============================================================
//  使用示例
// ============================================================

const cleanup = guardWatermark(
  document.body,
  { text: "张三 工号10086" },
  () => {
    // 安全预警上报：谁、何时、尝试删除水印
    fetch("/api/security/alert", {
      method: "POST",
      body: JSON.stringify({
        event: "WATERMARK_TAMPER",
        userId: currentUser.id,
        timestamp: Date.now(),
      }),
    });
  },
);

// 页面卸载时清理
// cleanup();
```

**攻防纵深分析**：

| 攻击手段                       | 防御措施                                                   |
| :----------------------------- | :--------------------------------------------------------- |
| DevTools 删除水印 DOM          | MutationObserver 微任务恢复                                |
| 修改水印 `style` 属性          | attributes 监听 + 立即复原                                 |
| `document.body.innerHTML = ''` | 整个 body 被清空也会触发 childList，恢复逻辑重新挂载       |
| 禁用 JavaScript                | **无解** — 但可在 `<noscript>` 中显示 CSS 纯背景水印作降级 |
| 截图后 PS 去除                 | **暗水印 (LSB)** — 人眼不可见的像素级信息编码              |

---

## 哲学启示

安全是一场 **"成本不对称"** 的博弈。前端安全的目标不是绝对无法破解，而是将攻击者的成本（时间、精力、技术门槛）提高到超过获利价值的程度。

> **"安全不是一堵墙，而是一片沼泽。"** 墙可以翻越，沼泽却让每一步都代价高昂。纵深防御的每一层都不需要完美，它们的组合效应才是真正的壁垒。
